# GIF文件格式完整技术规范

## 一、GIF格式深度概述

### 1.1 历史与版本
- **GIF87a** (1987年)：基础版本，支持静态图像
- **GIF89a** (1989年)：增加透明度、动画、文本和应用程序扩展

### 1.2 文件结构层次
```
GIF文件
├── 文件头部分
│   ├── 签名 (3字节)
│   └── 版本 (3字节)
├── 逻辑屏幕部分
│   ├── 逻辑屏幕描述符 (7字节)
│   └── 全局颜色表 (可选，3×2^(N+1)字节)
├── 数据流部分 (可重复)
│   ├── 扩展块 (多种类型)
│   └── 图像块
│       ├── 图像描述符 (10字节)
│       ├── 局部颜色表 (可选)
│       └── 图像数据 (LZW压缩)
└── 文件结束符 (1字节)
```

## 二、详细字节级结构

### 2.1 **文件头（Header）详解**

```
偏移  字节  字段名           值范围          说明
+00   3    Signature       "GIF"          固定ASCII字符串
+03   3    Version         "87a"/"89a"    版本标识符
```

**十六进制示例：**
```hex
47 49 46 38 39 61  // "GIF89a"
G  I  F  8  9  a
```

### 2.2 **逻辑屏幕描述符（LSD）详解**

```
偏移  字节  字段名                    说明
+00   2    Logical Screen Width     画布宽度（像素，小端序）
+02   2    Logical Screen Height    画布高度（像素，小端序）
+04   1    Packed Fields           打包字段（见下方）
+05   1    Background Color Index   背景色在全局颜色表中的索引
+06   1    Pixel Aspect Ratio      像素宽高比
```

**打包字段（Packed Fields）位详解：**
```
Bit 7     (0x80): Global Color Table Flag
                  1 = 全局颜色表存在
                  0 = 全局颜色表不存在

Bits 6-4  (0x70): Color Resolution
                  颜色分辨率 = 值 + 1
                  表示原始图像的每个颜色分量的位数

Bit 3     (0x08): Sort Flag
                  1 = 全局颜色表按重要性排序
                  0 = 未排序

Bits 2-0  (0x07): Size of Global Color Table
                  全局颜色表大小 = 2^(值+1)
                  例：值=7时，颜色数=2^8=256
```

**像素宽高比计算：**
```
如果值为0：没有宽高比信息
如果值非0：宽高比 = (Pixel Aspect Ratio + 15) / 64
```

**实际示例：**
```hex
偏移  数据              解析
+00   C8 00            宽度 = 0x00C8 = 200像素
+02   C8 00            高度 = 0x00C8 = 200像素
+04   F7               打包字段 = 11110111
                       - 全局颜色表：有(1)
                       - 颜色分辨率：111(8位)
                       - 排序标志：0(未排序)
                       - 颜色表大小：111(256色)
+05   00               背景色索引 = 0
+06   00               像素宽高比 = 0(无信息)
```

### 2.3 **全局颜色表（GCT）详解**

```
结构：连续的RGB三元组
大小：3 × 2^(Size of GCT + 1) 字节

每个颜色项：
偏移  字节  说明
+00   1    Red   (0-255)
+01   1    Green (0-255)
+02   1    Blue  (0-255)
```

**256色颜色表示例：**
```hex
索引  R  G  B   十六进制
000: 00 00 00  // 黑色
001: FF FF FF  // 白色
002: FF 00 00  // 红色
003: 00 FF 00  // 绿色
004: 00 00 FF  // 蓝色
...
255: XX XX XX  // 第256个颜色
```

## 三、扩展块详细规范

### 3.1 **扩展块通用结构**
```
偏移  字节  说明
+00   1    Extension Introducer (0x21)  扩展标识符
+01   1    Extension Label              扩展类型标签
+02   N    Extension Data               扩展数据(可变长)
+XX   1    Block Terminator (0x00)      块终止符
```

### 3.2 **图形控制扩展（0x21F9）**
```
偏移  字节  字段名               说明
+00   1    Introducer          0x21 (固定)
+01   1    Label               0xF9 (图形控制扩展)
+02   1    Block Size          0x04 (固定大小)
+03   1    Packed Fields       打包字段
+04   2    Delay Time          延迟时间(1/100秒，小端序)
+06   1    Transparent Index   透明色索引
+07   1    Terminator          0x00 (块终止符)
```

**Packed Fields位详解：**
```
Bits 7-5 (0xE0): Reserved (保留，设为0)

Bits 4-2 (0x1C): Disposal Method (处置方法)
                 0 - 无指定处置
                 1 - 不处置，保留图像
                 2 - 恢复为背景色
                 3 - 恢复为前一帧
                 4-7 - 保留

Bit 1    (0x02): User Input Flag
                 1 = 等待用户输入后继续
                 0 = 不等待

Bit 0    (0x01): Transparent Color Flag
                 1 = 使用透明色
                 0 = 不使用透明色
```

**实例：**
```hex
21 F9 04 05 64 00 00 00
解析：
- 扩展类型：图形控制扩展
- 打包字段：00000101 (处置方法=2，有透明色)
- 延迟：0x0064 = 100 (1秒)
- 透明色索引：0
```

### 3.3 **应用程序扩展（0x21FF）**

```
偏移  字节  字段名                  说明
+00   1    Introducer             0x21
+01   1    Label                  0xFF
+02   1    Block Size             0x0B (11字节)
+03   8    Application Identifier  应用程序标识符(8字符)
+11   3    Application Auth Code   认证码(3字符)
+14   N    Application Data        应用数据(子块序列)
+XX   1    Terminator             0x00
```

**NETSCAPE2.0循环扩展：**
```hex
21 FF 0B                     // 应用程序扩展头
4E 45 54 53 43 41 50 45      // "NETSCAPE"
32 2E 30                     // "2.0"
03                           // 子块大小
01                           // 子块ID (1=循环)
FF FF                        // 循环次数 (0=无限)
00                           // 块终止符
```

### 3.4 **注释扩展（0x21FE）**
```
偏移  字节  说明
+00   1    Introducer (0x21)
+01   1    Label (0xFE)
+02   N    Comment Data (子块序列)
+XX   1    Terminator (0x00)
```

### 3.5 **纯文本扩展（0x2101）**
```
偏移  字节  字段名                说明
+00   1    Introducer           0x21
+01   1    Label                0x01
+02   1    Block Size           0x0C (12字节)
+03   2    Text Grid Left       文本网格左边位置
+05   2    Text Grid Top        文本网格顶部位置
+07   2    Text Grid Width      文本网格宽度
+09   2    Text Grid Height     文本网格高度
+11   1    Character Cell Width  字符单元宽度
+12   1    Character Cell Height 字符单元高度
+13   1    Text Foreground Color 文本前景色索引
+14   1    Text Background Color 文本背景色索引
+15   N    Plain Text Data      文本数据(子块序列)
+XX   1    Terminator           0x00
```

## 四、图像数据块详细规范

### 4.1 **图像描述符（Image Descriptor）**
```
偏移  字节  字段名          说明
+00   1    Separator      0x2C (图像分隔符)
+01   2    Left Position  图像左边位置(小端序)
+03   2    Top Position   图像顶部位置(小端序)
+05   2    Width          图像宽度(小端序)
+07   2    Height         图像高度(小端序)
+09   1    Packed Fields  打包字段
```

**Packed Fields位详解：**
```
Bit 7    (0x80): Local Color Table Flag
                 1 = 有局部颜色表
                 0 = 无局部颜色表

Bit 6    (0x40): Interlace Flag
                 1 = 图像交错存储
                 0 = 顺序存储

Bit 5    (0x20): Sort Flag
                 1 = 局部颜色表已排序
                 0 = 未排序

Bits 4-3 (0x18): Reserved (保留)

Bits 2-0 (0x07): Size of Local Color Table
                 局部颜色表大小 = 2^(值+1)
```

### 4.2 **交错（Interlace）存储顺序**
```
Pass 1: 从第0行开始，每8行 (0, 8, 16, 24, ...)
Pass 2: 从第4行开始，每8行 (4, 12, 20, 28, ...)
Pass 3: 从第2行开始，每4行 (2, 6, 10, 14, ...)
Pass 4: 从第1行开始，每2行 (1, 3, 5, 7, ...)
```

## 五、LZW压缩算法详解

### 5.1 **LZW数据结构**
```
偏移  字节  说明
+00   1    LZW Minimum Code Size (2-8)
+01   N    Data Sub-blocks
```

### 5.2 **数据子块结构**
```
重复结构：
+00   1    Block Size (1-255)
+01   N    Data Bytes
...
+XX   1    Block Terminator (0x00)
```

### 5.3 **LZW编码表**
```
代码范围            含义
0 - (2^n-1)        颜色索引
2^n                清除码 (Clear Code)
2^n + 1            结束码 (End of Information)
2^n + 2 及以上      字典条目
```

### 5.4 **LZW解压缩算法**
```python
def lzw_decompress(data, min_code_size):
    clear_code = 1 << min_code_size
    end_code = clear_code + 1
    
    # 初始化字典
    dictionary = {}
    for i in range(clear_code):
        dictionary[i] = bytes([i])
    
    next_code = end_code + 1
    code_size = min_code_size + 1
    max_code = (1 << code_size) - 1
    
    # 读取码流
    bits_reader = BitReader(data)
    result = []
    
    code = bits_reader.read(code_size)
    if code == clear_code:
        # 重置字典
        pass
    elif code == end_code:
        return result
    
    # 解压主循环
    old_code = code
    result.append(dictionary[code])
    
    while True:
        code = bits_reader.read(code_size)
        
        if code == clear_code:
            # 重置
            dictionary.clear()
            for i in range(clear_code):
                dictionary[i] = bytes([i])
            next_code = end_code + 1
            code_size = min_code_size + 1
            max_code = (1 << code_size) - 1
            
            code = bits_reader.read(code_size)
            old_code = code
            result.append(dictionary[code])
            
        elif code == end_code:
            break
            
        else:
            if code in dictionary:
                entry = dictionary[code]
            else:
                entry = dictionary[old_code] + dictionary[old_code][0:1]
            
            result.append(entry)
            
            # 添加新字典条目
            dictionary[next_code] = dictionary[old_code] + entry[0:1]
            next_code += 1
            
            # 调整码长
            if next_code > max_code and code_size < 12:
                code_size += 1
                max_code = (1 << code_size) - 1
            
            old_code = code
    
    return b''.join(result)
```

## 六、完整的GIF解析器实现

```python
import struct
from typing import List, Dict, Optional, Tuple

class GIFParser:
    def __init__(self, filename: str):
        self.filename = filename
        self.file = None
        self.header = {}
        self.logical_screen = {}
        self.global_color_table = []
        self.frames = []
        
    def parse(self):
        """完整解析GIF文件"""
        with open(self.filename, 'rb') as self.file:
            self._parse_header()
            self._parse_logical_screen_descriptor()
            
            if self.logical_screen['global_color_table_flag']:
                self._parse_global_color_table()
            
            self._parse_data_stream()
            
    def _parse_header(self):
        """解析文件头"""
        data = self.file.read(6)
        self.header['signature'] = data[0:3].decode('ascii')
        self.header['version'] = data[3:6].decode('ascii')
        
        if self.header['signature'] != 'GIF':
            raise ValueError("不是有效的GIF文件")
        
        if self.header['version'] not in ['87a', '89a']:
            raise ValueError(f"不支持的GIF版本: {self.header['version']}")
    
    def _parse_logical_screen_descriptor(self):
        """解析逻辑屏幕描述符"""
        data = self.file.read(7)
        
        self.logical_screen['width'] = struct.unpack('<H', data[0:2])[0]
        self.logical_screen['height'] = struct.unpack('<H', data[2:4])[0]
        
        packed = data[4]
        self.logical_screen['global_color_table_flag'] = bool(packed & 0x80)
        self.logical_screen['color_resolution'] = (packed & 0x70) >> 4
        self.logical_screen['sort_flag'] = bool(packed & 0x08)
        self.logical_screen['global_color_table_size'] = 2 ** ((packed & 0x07) + 1)
        
        self.logical_screen['background_color_index'] = data[5]
        self.logical_screen['pixel_aspect_ratio'] = data[6]
        
    def _parse_global_color_table(self):
        """解析全局颜色表"""
        size = self.logical_screen['global_color_table_size']
        data = self.file.read(size * 3)
        
        self.global_color_table = []
        for i in range(0, len(data), 3):
            self.global_color_table.append({
                'r': data[i],
                'g': data[i+1],
                'b': data[i+2]
            })
    
    def _parse_data_stream(self):
        """解析数据流"""
        while True:
            separator = self.file.read(1)
            if not separator:
                break
                
            if separator[0] == 0x21:  # 扩展块
                self._parse_extension()
            elif separator[0] == 0x2C:  # 图像块
                self._parse_image()
            elif separator[0] == 0x3B:  # 文件结束
                break
            elif separator[0] == 0x00:  # 块终止符
                continue
            else:
                print(f"未知分隔符: 0x{separator[0]:02X}")
    
    def _parse_extension(self):
        """解析扩展块"""
        label = self.file.read(1)[0]
        
        if label == 0xF9:  # 图形控制扩展
            self._parse_graphic_control_extension()
        elif label == 0xFF:  # 应用程序扩展
            self._parse_application_extension()
        elif label == 0xFE:  # 注释扩展
            self._parse_comment_extension()
        elif label == 0x01:  # 纯文本扩展
            self._parse_plain_text_extension()
        else:
            # 跳过未知扩展
            self._skip_data_sub_blocks()
    
    def _parse_graphic_control_extension(self):
        """解析图形控制扩展"""
        block_size = self.file.read(1)[0]
        if block_size != 4:
            raise ValueError("图形控制扩展块大小错误")
        
        data = self.file.read(4)
        packed = data[0]
        
        gce = {
            'disposal_method': (packed & 0x1C) >> 2,
            'user_input_flag': bool(packed & 0x02),
            'transparent_color_flag': bool(packed & 0x01),
            'delay_time': struct.unpack('<H', data[1:3])[0],
            'transparent_color_index': data[3]
        }
        
        self.file.read(1)  # 块终止符
        
        # 保存到当前帧
        if not hasattr(self, 'current_frame'):
            self.current_frame = {}
        self.current_frame['graphic_control'] = gce
    
    def _parse_image(self):
        """解析图像数据"""
        # 图像描述符
        data = self.file.read(9)
        
        image = {
            'left': struct.unpack('<H', data[0:2])[0],
            'top': struct.unpack('<H', data[2:4])[0],
            'width': struct.unpack('<H', data[4:6])[0],
            'height': struct.unpack('<H', data[6:8])[0]
        }
        
        packed = data[8]
        image['local_color_table_flag'] = bool(packed & 0x80)
        image['interlace_flag'] = bool(packed & 0x40)
        image['sort_flag'] = bool(packed & 0x20)
        image['local_color_table_size'] = 2 ** ((packed & 0x07) + 1) if image['local_color_table_flag'] else 0
        
        # 局部颜色表
        if image['local_color_table_flag']:
            size = image['local_color_table_size']
            color_data = self.file.read(size * 3)
            image['local_color_table'] = []
            for i in range(0, len(color_data), 3):
                image['local_color_table'].append({
                    'r': color_data[i],
                    'g': color_data[i+1],
                    'b': color_data[i+2]
                })
        
        # LZW压缩数据
        lzw_min_code_size = self.file.read(1)[0]
        image['lzw_min_code_size'] = lzw_min_code_size
        image['compressed_data'] = self._read_data_sub_blocks()
        
        # 组合帧数据
        if hasattr(self, 'current_frame'):
            image.update(self.current_frame)
            del self.current_frame
        
        self.frames.append(image)
    
    def _parse_application_extension(self):
        """解析应用程序扩展"""
        block_size = self.file.read(1)[0]
        if block_size != 11:
            self._skip_data_sub_blocks()
            return
        
        app_id = self.file.read(8).decode('ascii')
        auth_code = self.file.read(3)
        
        if app_id == 'NETSCAPE' and auth_code == b'2.0':
            # NETSCAPE循环扩展
            sub_block = self.file.read(1)[0]
            if sub_block == 3:
                sub_block_id = self.file.read(1)[0]
                if sub_block_id == 1:
                    loop_count = struct.unpack('<H', self.file.read(2))[0]
                    self.logical_screen['loop_count'] = loop_count
            self.file.read(1)  # 块终止符
        else:
            self._skip_data_sub_blocks()
    
    def _parse_comment_extension(self):
        """解析注释扩展"""
        comment_data = self._read_data_sub_blocks()
        if 'comments' not in self.logical_screen:
            self.logical_screen['comments'] = []
        self.logical_screen['comments'].append(comment_data.decode('ascii', errors='ignore'))
    
    def _parse_plain_text_extension(self):
        """解析纯文本扩展"""
        block_size = self.file.read(1)[0]
        text_grid = self.file.read(block_size)
        text_data = self._read_data_sub_blocks()
        # 处理文本数据...
    
    def _read_data_sub_blocks(self) -> bytes:
        """读取数据子块序列"""
        data = b''
        while True:
            block_size = self.file.read(1)[0]
            if block_size == 0:
                break
            data += self.file.read(block_size)
        return data
    
    def _skip_data_sub_blocks(self):
        """跳过数据子块序列"""
        while True:
            block_size = self.file.read(1)[0]
            if block_size == 0:
                break
            self.file.seek(block_size, 1)
    
    def get_info(self) -> Dict:
        """获取GIF信息"""
        return {
            'header': self.header,
            'logical_screen': self.logical_screen,
            'global_color_table_size': len(self.global_color_table),
            'frame_count': len(self.frames),
            'frames': self.frames
        }

# 使用示例
if __name__ == "__main__":
    parser = GIFParser("example.gif")
    parser.parse()
    info = parser.get_info()
    
    print(f"GIF版本: {info['header']['version']}")
    print(f"画布大小: {info['logical_screen']['width']}×{info['logical_screen']['height']}")
    print(f"帧数: {info['frame_count']}")
    
    if 'loop_count' in info['logical_screen']:
        print(f"循环次数: {info['logical_screen']['loop_count']}")
    
    for i, frame in enumerate(info['frames']):
        print(f"\n帧 {i+1}:")
        print(f"  位置: ({frame['left']}, {frame['top']})")
        print(f"  大小: {frame['width']}×{frame['height']}")
        if 'graphic_control' in frame:
            gc = frame['graphic_control']
            print(f"  延迟: {gc['delay_time']/100}秒")
            if gc['transparent_color_flag']:
                print(f"  透明色索引: {gc['transparent_color_index']}")
```

## 七、实际GIF文件十六进制分析

### 7.1 **最小GIF文件示例（1×1像素）**
```hex
地址    十六进制                                ASCII
000000  47 49 46 38 39 61 01 00 01 00 80 00 00 FF FF FF  GIF89a..........
000010  00 00 00 21 F9 04 01 00 00 00 00 2C 00 00 00 00  ...!.......,....
000020  01 00 01 00 00 02 02 44 01 00 3B                 .......D..;

解析：
000000: "GIF89a"                   - 文件头
000006: 01 00 01 00               - 1×1像素画布
00000A: 80                        - 有全局颜色表，2色
00000B: 00 00                     - 背景色索引0，无宽高比
00000D: FF FF FF 00 00 00         - 2色：白色、黑色
000013: 21 F9                     - 图形控制扩展
000015: 04 01 00 00 00 00         - 透明，无延迟
00001B: 2C                        - 图像分隔符
00001C: 00 00 00 00 01 00 01 00   - 位置(0,0)，大小1×1
000024: 00                        - 无局部颜色表
000025: 02                        - LZW最小码长=2
000026: 02 44 01                  - 压缩数据
000029: 00                        - 数据块结束
00002A: 3B                        - 文件结束
```

### 7.2 **动画GIF示例结构**
```hex
文件头和逻辑屏幕
├─ GIF89a
├─ 逻辑屏幕描述符
├─ 全局颜色表
│
应用程序扩展（循环）
├─ 21 FF 0B
├─ NETSCAPE2.0
├─ 03 01 00 00 00    // 无限循环
│
第1帧
├─ 21 F9 04          // 图形控制扩展
├─ 05 0A 00 00 00    // 处置=2，延迟=10
├─ 2C ...            // 图像数据
│
第2帧
├─ 21 F9 04
├─ 05 0A 00 00 00
├─ 2C ...
│
更多帧...
│
3B                    // 文件结束
```

## 八、常见问题和优化技巧

### 8.1 **颜色表优化**
```python
def optimize_color_table(colors: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
    """优化颜色表，去除未使用的颜色"""
    from collections import Counter
    
    # 统计颜色使用频率
    color_freq = Counter(colors)
    
    # 按频率排序
    sorted_colors = sorted(color_freq.items(), key=lambda x: x[1], reverse=True)
    
    # 限制为256色
    optimized = [color for color, freq in sorted_colors[:256]]
    
    # 填充到2的幂
    size = 2
    while size < len(optimized):
        size *= 2
    
    while len(optimized) < size:
        optimized.append((0, 0, 0))
    
    return optimized
```

### 8.2 **帧差分压缩**
```python
def calculate_frame_diff(prev_frame, curr_frame):
    """计算帧差异，只保存变化的区域"""
    diff_region = {
        'left': float('inf'),
        'top': float('inf'),
        'right': 0,
        'bottom': 0
    }
    
    has_diff = False
    
    for y in range(len(prev_frame)):
        for x in range(len(prev_frame[0])):
            if prev_frame[y][x] != curr_frame[y][x]:
                has_diff = True
                diff_region['left'] = min(diff_region['left'], x)
                diff_region['top'] = min(diff_region['top'], y)
                diff_region['right'] = max(diff_region['right'], x)
                diff_region['bottom'] = max(diff_region['bottom'], y)
    
    if not has_diff:
        return None
    
    return {
        'x': diff_region['left'],
        'y': diff_region['top'],
        'width': diff_region['right'] - diff_region['left'] + 1,
        'height': diff_region['bottom'] - diff_region['top'] + 1
    }
```

### 8.3 **错误处理和验证**
```python
class GIFValidator:
    @staticmethod
    def validate_gif(data: bytes) -> List[str]:
        """验证GIF文件的完整性"""
        errors = []
        
        # 检查文件大小
        if len(data) < 13:
            errors.append("文件太小，不是有效的GIF")
            return errors
        
        # 检查签名
        if data[0:3] != b'GIF':
            errors.append("无效的GIF签名")
        
        # 检查版本
        version = data[3:6]
        if version not in [b'87a', b'89a']:
            errors.append(f"不支持的版本: {version}")
        
        # 检查逻辑屏幕描述符
        width = struct.unpack('<H', data[6:8])[0]
        height = struct.unpack('<H', data[8:10])[0]
        
        if width == 0 or height == 0:
            errors.append("无效的画布尺寸")
        
        if width > 65535 or height > 65535:
            errors.append("画布尺寸超出限制")
        
        # 检查文件结束符
        if data[-1] != 0x3B:
            errors.append("缺少文件结束符")
        
        return errors
```

## 九、性能优化建议

### 9.1 **内存映射文件处理**
```python
import mmap

class GIFStreamParser:
    def __init__(self, filename):
        self.file = open(filename, 'rb')
        self.mmap = mmap.mmap(self.file.fileno(), 0, access=mmap.ACCESS_READ)
        self.position = 0
    
    def read(self, size):
        data = self.mmap[self.position:self.position + size]
        self.position += size
        return data
    
    def seek(self, offset, whence=0):
        if whence == 0:
            self.position = offset
        elif whence == 1:
            self.position += offset
        elif whence == 2:
            self.position = len(self.mmap) + offset
    
    def close(self):
        self.mmap.close()
        self.file.close()
```

### 9.2 **并行处理**
```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import multiprocessing

def decode_frame(frame_data):
    """解码单个帧"""
    # LZW解压缩
    # 颜色映射
    # 返回像素数据
    pass

def parallel_decode_gif(frames):
    """并行解码GIF帧"""
    cpu_count = multiprocessing.cpu_count()
    
    with ProcessPoolExecutor(max_workers=cpu_count) as executor:
        decoded_frames = list(executor.map(decode_frame, frames))
    
    return decoded_frames
```

## 十、GIF格式限制和替代方案

### 10.1 **GIF格式限制**
- 最多256色（8位颜色深度）
- 仅支持完全透明（1位Alpha通道）
- 文件体积较大（特别是动画）
- LZW压缩效率有限

### 10.2 **现代替代格式**
| 格式 | 优势 | 适用场景 |
|------|------|----------|
| WebP | 更好的压缩，支持24位色和Alpha | Web动画 |
| APNG | PNG的动画扩展，支持24位色 | 需要高质量的动画 |
| AVIF | 最新格式，极高压缩率 | 现代浏览器 |
| WebM | 视频格式，适合长动画 | 视频类动画 |

