# PNG文件结构详解（扩展版）

## 一、PNG文件概述

### 1.1 PNG格式历史与特点


**核心特点：**
```
优势：
├── 无损压缩（基于DEFLATE算法）
├── 支持透明度（Alpha通道）
├── 支持48位真彩色和16位灰度
├── 渐进式显示（Adam7隔行扫描）
├── 伽马校正和颜色管理
├── 完整性检查（CRC-32）
└── 专利免费

劣势：
├── 不支持动画（需要APNG或MNG）
├── 文件体积通常比JPEG大（照片类）
└── 不支持CMYK色彩空间
```

### 1.2 字节序规定

PNG统一使用**网络字节序（Big-Endian）**：
```c
// 4字节整数在文件中的存储顺序
uint32_t value = 0x12345678;
// 文件中字节序列：12 34 56 78（高位在前）
```

## 二、文件整体结构（详细版）

### 2.1 结构层次图

```
PNG文件
├── 文件签名（8字节，固定）
└── 数据块序列
    ├── 关键数据块（Critical Chunks）
    │   ├── IHDR（必须，第一个）
    │   ├── PLTE（索引色图像必须）
    │   ├── IDAT（必须，可多个）
    │   └── IEND（必须，最后一个）
    └── 辅助数据块（Ancillary Chunks）
        ├── 透明信息：tRNS
        ├── 颜色空间：gAMA, cHRM, sRGB, iCCP
        ├── 文本信息：tEXt, zTXt, iTXt
        ├── 杂项信息：bKGD, pHYs, sBIT, sPLT
        └── 时间信息：tIME
```

### 2.2 数据块顺序规则

```
固定顺序要求：
1. IHDR 必须第一个
2. PLTE 必须在IDAT之前（如果存在）
3. IDAT 可以连续多个
4. IEND 必须最后一个

推荐顺序：
IHDR → [gAMA] → [cHRM] → [sRGB/iCCP] → [sBIT] → 
[PLTE] → [tRNS] → [hIST] → [bKGD] → [pHYs] → 
[sPLT] → [tIME] → [iTXt/tEXt/zTXt] → IDAT → IEND
```

## 三、PNG文件签名（深入解析）

### 3.1 签名字节详解

```hexdump
偏移  十六进制           ASCII    说明
0000: 89 50 4E 47      .PNG     魔数+文件类型
0004: 0D 0A 1A 0A      ....     换行符检测序列
```

**设计目的：**
```
89        → 非ASCII字符（>127）
          → 检测是否被当作7位ASCII传输
          → 防止某些编辑器误识别为文本

50 4E 47  → "PNG"的ASCII码
          → 人类可读的文件类型标识

0D 0A     → CR+LF（Windows换行）
          → 检测不当的换行符转换

1A        → SUB字符（Ctrl+Z）
          → DOS/Windows的文本文件结束符
          → 防止type命令意外显示

0A        → LF（Unix换行）
          → 再次检测换行符转换问题
```

### 3.2 签名验证代码

```python
def verify_png_signature(data):
    """验证PNG文件签名的完整性"""
    PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'
    
    if len(data) < 8:
        return False, "文件太小"
    
    if data[:8] != PNG_SIGNATURE:
        # 详细诊断错误原因
        if data[0] != 0x89:
            return False, "首字节错误，可能被当作ASCII处理"
        if data[1:4] != b'PNG':
            return False, "不是PNG文件"
        if data[4:6] != b'\r\n':
            return False, "CR+LF被修改，可能经过错误的换行符转换"
        if data[6] != 0x1A:
            return False, "SUB字符丢失"
        if data[7] != 0x0A:
            return False, "LF被修改"
    
    return True, "签名正确"
```

## 四、数据块（Chunk）结构详解

### 4.1 数据块内存布局

```c
typedef struct {
    uint32_t length;        // 数据域长度（大端序）
    char     type[4];       // 块类型（4个ASCII字符）
    uint8_t  data[length];  // 数据域（可变长度）
    uint32_t crc;          // CRC-32校验和
} PNGChunk;
```

### 4.2 块类型（Chunk Type）编码规则

**每个字母的比特位含义：**

```
第5位（从0开始）决定大小写：
  0 = 大写（0x40-0x5F）
  1 = 小写（0x60-0x7F）

类型字符规则矩阵：
┌─────────┬─────────────────────┬─────────────────────┐
│ 字母位置 │ 大写（bit5=0）       │ 小写（bit5=1）       │
├─────────┼─────────────────────┼─────────────────────┤
│ 第1个   │ 关键块（Critical）   │ 辅助块（Ancillary）  │
│ 第2个   │ 公共块（Public）     │ 私有块（Private）    │
│ 第3个   │ 保留（Reserved）     │ [未定义-必须大写]    │
│ 第4个   │ 不安全复制           │ 安全复制            │
└─────────┴─────────────────────┴─────────────────────┘
```

**示例分析：**
```
IHDR: 关键-公共-保留-不安全
tEXt: 辅助-公共-保留-安全复制
pHYs: 辅助-公共-保留-安全复制
```

### 4.3 CRC-32计算

```python
def calculate_crc32(chunk_type, chunk_data):
    """计算PNG数据块的CRC-32值"""
    import zlib
    # CRC计算包括类型和数据，不包括长度
    crc = zlib.crc32(chunk_type + chunk_data) & 0xffffffff
    return crc

def verify_chunk_crc(chunk_type, chunk_data, stored_crc):
    """验证数据块CRC的正确性"""
    calculated = calculate_crc32(chunk_type, chunk_data)
    stored = struct.unpack('>I', stored_crc)[0]
    return calculated == stored
```

## 五、关键数据块详解

### 5.1 IHDR（图像头数据块）完整解析

```c
// IHDR数据结构（13字节）
struct IHDR {
    uint32_t width;           // 0-3: 宽度（1-2^31）
    uint32_t height;          // 4-7: 高度（1-2^31）
    uint8_t  bit_depth;       // 8: 位深度
    uint8_t  color_type;      // 9: 颜色类型
    uint8_t  compression;     // 10: 压缩方法（必须为0）
    uint8_t  filter;          // 11: 滤波方法（必须为0）
    uint8_t  interlace;       // 12: 隔行扫描方法
};
```

**颜色类型与位深度组合表：**

```
┌────────────┬──────────────────┬─────────────────────┐
│ Color Type │ 允许的位深度      │ 每像素位数          │
├────────────┼──────────────────┼─────────────────────┤
│ 0 (灰度)    │ 1,2,4,8,16      │ 1,2,4,8,16         │
│ 2 (RGB)     │ 8,16            │ 24,48              │
│ 3 (索引)    │ 1,2,4,8         │ 1,2,4,8            │
│ 4 (灰度+A)  │ 8,16            │ 16,32              │
│ 6 (RGBA)    │ 8,16            │ 32,64              │
└────────────┴──────────────────┴─────────────────────┘
```

**样本计算示例：**
```python
def calculate_image_size(width, height, color_type, bit_depth):
    """计算未压缩图像数据大小"""
    # 每像素位数
    bits_per_pixel = {
        0: bit_depth,                    # 灰度
        2: bit_depth * 3,                # RGB
        3: bit_depth,                    # 索引
        4: bit_depth * 2,                # 灰度+Alpha
        6: bit_depth * 4                 # RGBA
    }[color_type]
    
    # 每行字节数（需要向上取整）
    bytes_per_row = (width * bits_per_pixel + 7) // 8
    
    # 加上每行的滤波器字节
    bytes_per_row += 1
    
    # 总大小
    total_size = bytes_per_row * height
    
    return total_size
```

### 5.2 PLTE（调色板）高级特性

```python
class PaletteChunk:
    def __init__(self, data):
        self.entries = []
        for i in range(0, len(data), 3):
            self.entries.append({
                'red': data[i],
                'green': data[i+1],
                'blue': data[i+2],
                'index': i // 3
            })
    
    def optimize(self):
        """优化调色板：排序、去重、压缩"""
        # 1. 统计使用频率
        # 2. 按频率重排
        # 3. 移除未使用颜色
        pass
    
    def to_bytes(self):
        """转换回字节数据"""
        data = bytearray()
        for entry in self.entries:
            data.extend([entry['red'], entry['green'], entry['blue']])
        return bytes(data)
```

### 5.3 IDAT数据处理流程

```
原始像素数据
    ↓
[滤波处理] ← 选择最优滤波器
    ↓
滤波后数据
    ↓
[zlib压缩] ← DEFLATE算法
    ↓
压缩数据流
    ↓
[分块存储] ← 可分割为多个IDAT
    ↓
IDAT数据块
```

**滤波算法实现：**

```python
class PNGFilter:
    @staticmethod
    def filter_none(row, prev_row, bpp):
        """Type 0: 无滤波"""
        return b'\x00' + row
    
    @staticmethod
    def filter_sub(row, prev_row, bpp):
        """Type 1: 左侧差值"""
        filtered = bytearray([1])  # 滤波类型标记
        for i in range(len(row)):
            left = row[i-bpp] if i >= bpp else 0
            filtered.append((row[i] - left) & 0xff)
        return bytes(filtered)
    
    @staticmethod
    def filter_up(row, prev_row, bpp):
        """Type 2: 上方差值"""
        filtered = bytearray([2])
        for i in range(len(row)):
            up = prev_row[i] if prev_row else 0
            filtered.append((row[i] - up) & 0xff)
        return bytes(filtered)
    
    @staticmethod
    def filter_average(row, prev_row, bpp):
        """Type 3: 平均值"""
        filtered = bytearray([3])
        for i in range(len(row)):
            left = row[i-bpp] if i >= bpp else 0
            up = prev_row[i] if prev_row else 0
            filtered.append((row[i] - (left + up)//2) & 0xff)
        return bytes(filtered)
    
    @staticmethod
    def filter_paeth(row, prev_row, bpp):
        """Type 4: Paeth预测"""
        def paeth_predictor(left, above, upper_left):
            p = left + above - upper_left
            pa = abs(p - left)
            pb = abs(p - above)
            pc = abs(p - upper_left)
            
            if pa <= pb and pa <= pc:
                return left
            elif pb <= pc:
                return above
            else:
                return upper_left
        
        filtered = bytearray([4])
        for i in range(len(row)):
            left = row[i-bpp] if i >= bpp else 0
            above = prev_row[i] if prev_row else 0
            upper_left = prev_row[i-bpp] if prev_row and i >= bpp else 0
            
            prediction = paeth_predictor(left, above, upper_left)
            filtered.append((row[i] - prediction) & 0xff)
        
        return bytes(filtered)
```

### 5.4 Adam7隔行扫描

```
Adam7将图像分为7个子图像逐步传输：

Pass 1 (1/64像素):     Pass 2 (1/64像素):
1 . . . . . . .        . . . . 5 . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .

Pass 3 (1/32像素):     Pass 4 (1/16像素):
. . 3 . . . 7 .        . 2 . . . 6 . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .
. . . . . . . .        . . . . . . . .

完整的7-pass模式矩阵：
1 6 4 6 2 6 4 6
7 7 7 7 7 7 7 7
5 6 5 6 5 6 5 6
7 7 7 7 7 7 7 7
3 6 4 6 3 6 4 6
7 7 7 7 7 7 7 7
5 6 5 6 5 6 5 6
7 7 7 7 7 7 7 7
```

## 六、辅助数据块详解

### 6.1 透明度处理（tRNS）

```python
class tRNSChunk:
    """透明度信息块处理"""
    
    def __init__(self, data, color_type):
        self.color_type = color_type
        
        if color_type == 0:  # 灰度
            # 2字节：透明的灰度值
            self.gray = struct.unpack('>H', data)[0]
            
        elif color_type == 2:  # RGB
            # 6字节：透明的RGB值
            self.red = struct.unpack('>H', data[0:2])[0]
            self.green = struct.unpack('>H', data[2:4])[0]
            self.blue = struct.unpack('>H', data[4:6])[0]
            
        elif color_type == 3:  # 索引
            # n字节：每个调色板条目的Alpha值
            self.alpha_values = list(data)
```

### 6.2 颜色管理块

**gAMA（伽马值）：**
```python
def parse_gama(data):
    """解析伽马值（×100000存储）"""
    gamma_int = struct.unpack('>I', data)[0]
    gamma = gamma_int / 100000.0
    return gamma

def create_gama(gamma):
    """创建gAMA块数据"""
    gamma_int = int(gamma * 100000)
    return struct.pack('>I', gamma_int)
```

**cHRM（色度信息）：**
```python
class cHRMChunk:
    """CIE 1931色度坐标"""
    
    def __init__(self, data):
        values = struct.unpack('>IIIIIIII', data)
        # 所有值都×100000存储
        self.white_x = values[0] / 100000.0
        self.white_y = values[1] / 100000.0
        self.red_x = values[2] / 100000.0
        self.red_y = values[3] / 100000.0
        self.green_x = values[4] / 100000.0
        self.green_y = values[5] / 100000.0
        self.blue_x = values[6] / 100000.0
        self.blue_y = values[7] / 100000.0
```

### 6.3 文本信息块

**三种文本块对比：**

```
┌──────┬────────┬──────────┬────────────┬──────────┐
│ 类型  │ 压缩   │ 编码     │ 国际化     │ 用途     │
├──────┼────────┼──────────┼────────────┼──────────┤
│ tEXt │ 否     │ Latin-1  │ 否         │ 简单文本 │
│ zTXt │ 是     │ Latin-1  │ 否         │ 压缩文本 │
│ iTXt │ 可选   │ UTF-8    │ 是（语言） │ 国际文本 │
└──────┴────────┴──────────┴────────────┴──────────┘
```

**iTXt结构（最复杂）：**
```python
class iTXtChunk:
    def __init__(self, data):
        # Null分隔的字段
        parts = data.split(b'\x00')
        
        self.keyword = parts[0].decode('latin-1')
        self.compression_flag = parts[1][0]  # 0或1
        self.compression_method = parts[1][1]  # 0=deflate
        self.language_tag = parts[2].decode('ascii')
        self.translated_keyword = parts[3].decode('utf-8')
        
        text_data = b'\x00'.join(parts[4:])
        if self.compression_flag:
            self.text = zlib.decompress(text_data).decode('utf-8')
        else:
            self.text = text_data.decode('utf-8')
```

### 6.4 物理尺寸（pHYs）

```python
class pHYsChunk:
    """物理像素尺寸"""
    
    def __init__(self, data):
        self.pixels_per_unit_x = struct.unpack('>I', data[0:4])[0]
        self.pixels_per_unit_y = struct.unpack('>I', data[4:8])[0]
        self.unit = data[8]  # 0=未知, 1=米
        
    def get_dpi(self):
        """转换为DPI（如果单位是米）"""
        if self.unit == 1:
            # 像素/米 转 DPI（像素/英寸）
            dpi_x = self.pixels_per_unit_x * 0.0254
            dpi_y = self.pixels_per_unit_y * 0.0254
            return dpi_x, dpi_y
        return None, None
```

## 七、完整的PNG解析器实现

```python
import struct
import zlib
from io import BytesIO

class PNGParser:
    def __init__(self, filename):
        self.filename = filename
        self.chunks = []
        self.image_data = b''
        self.metadata = {}
        
    def parse(self):
        """完整解析PNG文件"""
        with open(self.filename, 'rb') as f:
            # 验证签名
            signature = f.read(8)
            if signature != b'\x89PNG\r\n\x1a\n':
                raise ValueError("Invalid PNG signature")
            
            # 解析所有数据块
            while True:
                chunk = self._read_chunk(f)
                if not chunk:
                    break
                    
                self.chunks.append(chunk)
                self._process_chunk(chunk)
                
                if chunk['type'] == 'IEND':
                    break
        
        return self.metadata
    
    def _read_chunk(self, f):
        """读取单个数据块"""
        # 读取长度
        length_data = f.read(4)
        if len(length_data) < 4:
            return None
            
        length = struct.unpack('>I', length_data)[0]
        
        # 读取类型
        chunk_type = f.read(4)
        if len(chunk_type) < 4:
            return None
            
        # 读取数据
        data = f.read(length) if length > 0 else b''
        
        # 读取CRC
        crc = f.read(4)
        
        # 验证CRC
        calculated_crc = zlib.crc32(chunk_type + data) & 0xffffffff
        stored_crc = struct.unpack('>I', crc)[0]
        
        return {
            'type': chunk_type.decode('ascii'),
            'length': length,
            'data': data,
            'crc': stored_crc,
            'crc_valid': calculated_crc == stored_crc
        }
    
    def _process_chunk(self, chunk):
        """处理特定类型的数据块"""
        chunk_type = chunk['type']
        data = chunk['data']
        
        if chunk_type == 'IHDR':
            self._process_ihdr(data)
        elif chunk_type == 'PLTE':
            self._process_plte(data)
        elif chunk_type == 'IDAT':
            self.image_data += data
        elif chunk_type == 'tEXt':
            self._process_text(data)
        elif chunk_type == 'pHYs':
            self._process_phys(data)
        elif chunk_type == 'tIME':
            self._process_time(data)
        # ... 其他块类型
    
    def _process_ihdr(self, data):
        """处理IHDR块"""
        width = struct.unpack('>I', data[0:4])[0]
        height = struct.unpack('>I', data[4:8])[0]
        bit_depth = data[8]
        color_type = data[9]
        compression = data[10]
        filter_method = data[11]
        interlace = data[12]
        
        self.metadata['width'] = width
        self.metadata['height'] = height
        self.metadata['bit_depth'] = bit_depth
        self.metadata['color_type'] = color_type
        self.metadata['compression'] = compression
        self.metadata['filter'] = filter_method
        self.metadata['interlace'] = interlace
        
        # 计算通道数和每像素字节数
        channels = {0:1, 2:3, 3:1, 4:2, 6:4}[color_type]
        self.metadata['channels'] = channels
        self.metadata['bytes_per_pixel'] = (channels * bit_depth + 7) // 8
    
    def _process_plte(self, data):
        """处理调色板"""
        palette = []
        for i in range(0, len(data), 3):
            palette.append((data[i], data[i+1], data[i+2]))
        self.metadata['palette'] = palette
    
    def _process_text(self, data):
        """处理文本信息"""
        null_pos = data.index(b'\x00')
        keyword = data[:null_pos].decode('latin-1')
        text = data[null_pos+1:].decode('latin-1')
        
        if 'text' not in self.metadata:
            self.metadata['text'] = {}
        self.metadata['text'][keyword] = text
    
    def _process_phys(self, data):
        """处理物理尺寸"""
        ppux = struct.unpack('>I', data[0:4])[0]
        ppuy = struct.unpack('>I', data[4:8])[0]
        unit = data[8]
        
        self.metadata['phys'] = {
            'x': ppux,
            'y': ppuy,
            'unit': 'meter' if unit == 1 else 'unknown'
        }
        
        if unit == 1:
            self.metadata['dpi_x'] = ppux * 0.0254
            self.metadata['dpi_y'] = ppuy * 0.0254
    
    def _process_time(self, data):
        """处理时间戳"""
        year = struct.unpack('>H', data[0:2])[0]
        month = data[2]
        day = data[3]
        hour = data[4]
        minute = data[5]
        second = data[6]
        
        self.metadata['last_modified'] = {
            'year': year,
            'month': month,
            'day': day,
            'hour': hour,
            'minute': minute,
            'second': second
        }
    
    def decompress_image_data(self):
        """解压缩图像数据"""
        try:
            decompressed = zlib.decompress(self.image_data)
            return decompressed
        except zlib.error as e:
            print(f"Decompression error: {e}")
            return None
    
    def reconstruct_pixels(self):
        """重建像素数据（反滤波）"""
        decompressed = self.decompress_image_data()
        if not decompressed:
            return None
        
        width = self.metadata['width']
        height = self.metadata['height']
        bpp = self.metadata['bytes_per_pixel']
        
        # 每行的字节数（包括滤波器字节）
        row_bytes = width * bpp + 1
        
        pixels = []
        prev_row = None
        
        for y in range(height):
            row_start = y * row_bytes
            filter_type = decompressed[row_start]
            row_data = decompressed[row_start + 1 : row_start + row_bytes]
            
            # 反滤波
            reconstructed = self._unfilter_row(
                filter_type, row_data, prev_row, bpp
            )
            pixels.append(reconstructed)
            prev_row = reconstructed
        
        return pixels
    
    def _unfilter_row(self, filter_type, row, prev_row, bpp):
        """反滤波单行数据"""
        result = bytearray(len(row))
        
        if filter_type == 0:  # None
            result[:] = row
            
        elif filter_type == 1:  # Sub
            for i in range(len(row)):
                left = result[i-bpp] if i >= bpp else 0
                result[i] = (row[i] + left) & 0xff
                
        elif filter_type == 2:  # Up
            for i in range(len(row)):
                up = prev_row[i] if prev_row else 0
                result[i] = (row[i] + up) & 0xff
                
        elif filter_type == 3:  # Average
            for i in range(len(row)):
                left = result[i-bpp] if i >= bpp else 0
                up = prev_row[i] if prev_row else 0
                result[i] = (row[i] + (left + up)//2) & 0xff
                
        elif filter_type == 4:  # Paeth
            for i in range(len(row)):
                left = result[i-bpp] if i >= bpp else 0
                up = prev_row[i] if prev_row else 0
                upper_left = prev_row[i-bpp] if prev_row and i >= bpp else 0
                
                p = left + up - upper_left
                pa = abs(p - left)
                pb = abs(p - up)
                pc = abs(p - upper_left)
                
                if pa <= pb and pa <= pc:
                    pr = left
                elif pb <= pc:
                    pr = up
                else:
                    pr = upper_left
                
                result[i] = (row[i] + pr) & 0xff
        
        return bytes(result)
```

## 八、PNG优化技术

### 8.1 文件大小优化策略

```python
class PNGOptimizer:
    """PNG优化器"""
    
    def __init__(self, png_data):
        self.png_data = png_data
        self.optimizations = []
    
    def optimize_color_type(self):
        """优化颜色类型"""
        # 分析图像特征
        unique_colors = self.count_unique_colors()
        has_transparency = self.check_transparency()
        
        if unique_colors <= 256:
            if has_transparency:
                # 使用索引色+tRNS
                self.convert_to_indexed_with_trns()
            else:
                # 使用纯索引色
                self.convert_to_indexed()
        elif self.is_grayscale():
            if has_transparency:
                # 灰度+Alpha
                self.convert_to_grayscale_alpha()
            else:
                # 纯灰度
                self.convert_to_grayscale()
    
    def optimize_bit_depth(self):
        """优化位深度"""
        if self.png_data['color_type'] == 3:  # 索引色
            colors_count = len(self.png_data['palette'])
            if colors_count <= 2:
                self.png_data['bit_depth'] = 1
            elif colors_count <= 4:
                self.png_data['bit_depth'] = 2
            elif colors_count <= 16:
                self.png_data['bit_depth'] = 4
            else:
                self.png_data['bit_depth'] = 8
    
    def optimize_filtering(self):
        """为每行选择最优滤波器"""
        optimized_rows = []
        
        for row_index, row_data in enumerate(self.png_data['rows']):
            best_filter = None
            best_size = float('inf')
            
            # 测试所有滤波器
            for filter_type in range(5):
                filtered = self.apply_filter(filter_type, row_data)
                compressed_size = len(zlib.compress(filtered, 9))
                
                if compressed_size < best_size:
                    best_size = compressed_size
                    best_filter = filter_type
            
            optimized_rows.append((best_filter, row_data))
        
        return optimized_rows
    
    def strip_chunks(self, keep_list=None):
        """移除不必要的辅助块"""
        if keep_list is None:
            # 默认保留的块
            keep_list = ['IHDR', 'PLTE', 'tRNS', 'IDAT', 'IEND']
        
        filtered_chunks = []
        for chunk in self.png_data['chunks']:
            if chunk['type'] in keep_list:
                filtered_chunks.append(chunk)
            else:
                self.optimizations.append(f"Removed {chunk['type']}")
        
        self.png_data['chunks'] = filtered_chunks
    
    def optimize_palette(self):
        """优化调色板"""
        if self.png_data['color_type'] != 3:
            return
        
        # 1. 统计颜色使用频率
        color_usage = self.analyze_color_usage()
        
        # 2. 按使用频率排序
        sorted_palette = sorted(
            color_usage.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        # 3. 重建调色板和索引映射
        new_palette = []
        index_map = {}
        
        for new_index, (old_index, _) in enumerate(sorted_palette):
            new_palette.append(self.png_data['palette'][old_index])
            index_map[old_index] = new_index
        
        # 4. 更新图像数据中的索引
        self.remap_indices(index_map)
        self.png_data['palette'] = new_palette
```

### 8.2 压缩级别优化

```python
def find_optimal_compression(data):
    """寻找最优压缩级别"""
    results = []
    
    for level in range(10):  # 0-9压缩级别
        start_time = time.time()
        compressed = zlib.compress(data, level)
        compression_time = time.time() - start_time
        
        results.append({
            'level': level,
            'size': len(compressed),
            'time': compression_time,
            'ratio': len(compressed) / len(data)
        })
    
    # 选择最优（平衡大小和时间）
    # 可以根据需求调整权重
    best = min(results, key=lambda x: x['size'] + x['time'] * 1000)
    
    return best['level']
```

### 8.3 渐进式编码优化

```python
class ProgressiveEncoder:
    """Adam7渐进式编码"""
    
    # Adam7的7个pass的起始位置和步长
    ADAM7_PATTERN = [
        (0, 0, 8, 8),  # Pass 1
        (4, 0, 8, 8),  # Pass 2
        (0, 4, 4, 8),  # Pass 3
        (2, 0, 4, 4),  # Pass 4
        (0, 2, 2, 4),  # Pass 5
        (1, 0, 2, 2),  # Pass 6
        (0, 1, 1, 2),  # Pass 7
    ]
    
    def encode_progressive(self, image_data, width, height):
        """将图像编码为Adam7格式"""
        passes = []
        
        for pass_num, (x_start, y_start, x_step, y_step) in enumerate(self.ADAM7_PATTERN):
            pass_data = self.extract_pass(
                image_data, width, height,
                x_start, y_start, x_step, y_step
            )
            
            if pass_data:  # 某些pass可能为空（小图像）
                passes.append(pass_data)
        
        return passes
    
    def extract_pass(self, data, width, height, x_start, y_start, x_step, y_step):
        """提取单个pass的数据"""
        pass_data = []
        
        for y in range(y_start, height, y_step):
            row = []
            for x in range(x_start, width, x_step):
                pixel = self.get_pixel(data, x, y, width)
                row.append(pixel)
            
            if row:
                pass_data.append(row)
        
        return pass_data
```

## 九、PNG安全性考虑

### 9.1 安全隐患检测

```python
class PNGSecurityScanner:
    """PNG安全扫描器"""
    
    def __init__(self, max_size=100*1024*1024):  # 100MB限制
        self.max_size = max_size
        self.warnings = []
        self.errors = []
    
    def scan_file(self, filename):
        """扫描PNG文件的安全问题"""
        file_size = os.path.getsize(filename)
        
        # 1. 文件大小检查
        if file_size > self.max_size:
            self.errors.append(f"File too large: {file_size} bytes")
            return False
        
        with open(filename, 'rb') as f:
            # 2. 签名验证
            if not self.verify_signature(f):
                return False
            
            # 3. 块扫描
            while True:
                chunk = self.read_chunk_header(f)
                if not chunk:
                    break
                
                # 检查块大小
                if chunk['length'] > self.max_size:
                    self.errors.append(f"Chunk too large: {chunk['type']}")
                    return False
                
                # 检查关键块
                if chunk['type'] == 'IHDR':
                    if not self.verify_ihdr(f, chunk['length']):
                        return False
                
                # 跳过数据和CRC
                f.seek(chunk['length'] + 4, 1)
                
                if chunk['type'] == 'IEND':
                    break
        
        return len(self.errors) == 0
    
    def verify_ihdr(self, f, length):
        """验证IHDR块的合理性"""
        if length != 13:
            self.errors.append("Invalid IHDR length")
            return False
        
        data = f.read(13)
        width = struct.unpack('>I', data[0:4])[0]
        height = struct.unpack('>I', data[4:8])[0]
        
        # 检查尺寸溢出（防止整数溢出攻击）
        if width == 0 or height == 0:
            self.errors.append("Invalid dimensions: zero size")
            return False
        
        if width > 65535 or height > 65535:
            self.warnings.append("Very large dimensions")
        
        # 检查潜在的内存消耗
        bit_depth = data[8]
        color_type = data[9]
        
        bytes_per_pixel = self.calculate_bytes_per_pixel(color_type, bit_depth)
        total_memory = width * height * bytes_per_pixel
        
        if total_memory > 500 * 1024 * 1024:  # 500MB
            self.errors.append(f"Excessive memory requirement: {total_memory} bytes")
            return False
        
        return True
```

### 9.2 隐写术检测

```python
class SteganographyDetector:
    """PNG隐写术检测"""
    
    def detect_lsb(self, image_data):
        """检测LSB（最低有效位）隐写"""
        # 统计LSB分布
        lsb_distribution = [0, 0]  # 0和1的计数
        
        for byte in image_data:
            lsb_distribution[byte & 1] += 1
        
        total = sum(lsb_distribution)
        ratio = lsb_distribution[0] / total
        
        # 正常图像的LSB应该接近随机分布（约0.5）
        # 如果偏差太大，可能存在隐写
        if abs(ratio - 0.5) > 0.1:
            return True, f"Suspicious LSB distribution: {ratio:.2f}"
        
        return False, "Normal LSB distribution"
    
    def detect_chunk_anomalies(self, chunks):
        """检测异常数据块"""
        suspicious = []
        
        for chunk in chunks:
            # 检查私有块
            if chunk['type'][1].islower():
                suspicious.append(f"Private chunk found: {chunk['type']}")
            
            # 检查文本块内容
            if chunk['type'] in ['tEXt', 'zTXt', 'iTXt']:
                if self.check_text_chunk(chunk['data']):
                    suspicious.append(f"Suspicious text in {chunk['type']}")
        
        return suspicious
```

## 十、实用工具和脚本

### 10.1 PNG信息提取工具

```python
#!/usr/bin/env python3
"""
PNG信息提取工具
用法: python png_info.py image.png
"""

import sys
import struct
from datetime import datetime

def format_bytes(size):
    """格式化字节大小"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size < 1024.0:
            return f"{size:.2f} {unit}"
        size /= 1024.0
    return f"{size:.2f} TB"

def analyze_png(filename):
    """分析PNG文件并输出详细信息"""
    print(f"\n=== PNG File Analysis: {filename} ===\n")
    
    parser = PNGParser(filename)
    metadata = parser.parse()
    
    # 基本信息
    print("Basic Information:")
    print(f"  Dimensions: {metadata['width']} × {metadata['height']} pixels")
    print(f"  Color Type: {get_color_type_name(metadata['color_type'])}")
    print(f"  Bit Depth: {metadata['bit_depth']}")
    print(f"  Channels: {metadata['channels']}")
    print(f"  Interlaced: {'Yes (Adam7)' if metadata['interlace'] else 'No'}")
    
    # 物理尺寸
    if 'dpi_x' in metadata:
        print(f"  DPI: {metadata['dpi_x']:.0f} × {metadata['dpi_y']:.0f}")
    
    # 调色板信息
    if 'palette' in metadata:
        print(f"  Palette Colors: {len(metadata['palette'])}")
    
    # 块统计
    print("\nChunk Statistics:")
    chunk_stats = {}
    total_size = 0
    
    for chunk in parser.chunks:
        chunk_type = chunk['type']
        chunk_size = chunk['length'] + 12  # 加上头部和CRC
        
        if chunk_type not in chunk_stats:
            chunk_stats[chunk_type] = {'count': 0, 'size': 0}
        
        chunk_stats[chunk_type]['count'] += 1
        chunk_stats[chunk_type]['size'] += chunk_size
        total_size += chunk_size
    
    # 按大小排序输出
    sorted_chunks = sorted(
        chunk_stats.items(), 
        key=lambda x: x[1]['size'], 
        reverse=True
    )
    
    for chunk_type, stats in sorted_chunks:
        percentage = (stats['size'] / total_size) * 100
        print(f"  {chunk_type}: {stats['count']} chunk(s), "
              f"{format_bytes(stats['size'])} ({percentage:.1f}%)")
    
    print(f"\nTotal Size: {format_bytes(total_size)}")
    
    # 文本信息
    if 'text' in metadata:
        print("\nText Metadata:")
        for key, value in metadata['text'].items():
            print(f"  {key}: {value}")
    
    # 时间信息
    if 'last_modified' in metadata:
        tm = metadata['last_modified']
        dt = datetime(tm['year'], tm['month'], tm['day'],
                     tm['hour'], tm['minute'], tm['second'])
        print(f"\nLast Modified: {dt.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # 压缩信息
    if parser.image_data:
        compressed_size = len(parser.image_data)
        decompressed = parser.decompress_image_data()
        if decompressed:
            decompressed_size = len(decompressed)
            ratio = compressed_size / decompressed_size
            print(f"\nCompression:")
            print(f"  Compressed: {format_bytes(compressed_size)}")
            print(f"  Uncompressed: {format_bytes(decompressed_size)}")
            print(f"  Ratio: {ratio:.2%}")

def get_color_type_name(color_type):
    """获取颜色类型名称"""
    names = {
        0: "Grayscale",
        2: "RGB",
        3: "Indexed",
        4: "Grayscale + Alpha",
        6: "RGB + Alpha"
    }
    return names.get(color_type, f"Unknown ({color_type})")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python png_info.py <image.png>")
        sys.exit(1)
    
    try:
        analyze_png(sys.argv[1])
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
```

### 10.2 PNG修复工具

```python
class PNGRepairer:
    """PNG文件修复工具"""
    
    def repair(self, input_file, output_file):
        """尝试修复损坏的PNG文件"""
        repairs = []
        
        with open(input_file, 'rb') as f:
            data = f.read()
        
        # 1. 修复签名
        if data[:8] != b'\x89PNG\r\n\x1a\n':
            data = b'\x89PNG\r\n\x1a\n' + data[8:]
            repairs.append("Fixed PNG signature")
        
        # 2. 修复块CRC
        pos = 8
        chunks = []
        
        while pos < len(data):
            # 读取块头
            if pos + 8 > len(data):
                break
                
            length = struct.unpack('>I', data[pos:pos+4])[0]
            chunk_type = data[pos+4:pos+8]
            
            if pos + 12 + length > len(data):
                # 块不完整，截断
                repairs.append(f"Truncated incomplete chunk at {pos}")
                break
            
            chunk_data = data[pos+8:pos+8+length]
            stored_crc = data[pos+8+length:pos+12+length]
            
            # 重新计算CRC
            calc_crc = struct.pack('>I', 
                zlib.crc32(chunk_type + chunk_data) & 0xffffffff)
            
            if stored_crc != calc_crc:
                repairs.append(f"Fixed CRC for {chunk_type.decode('ascii', 'ignore')}")
                stored_crc = calc_crc
            
            # 重建块
            chunks.append(
                struct.pack('>I', length) + 
                chunk_type + 
                chunk_data + 
                stored_crc
            )
            
            pos += 12 + length
            
            if chunk_type == b'IEND':
                break
        
        # 3. 确保有IEND块
        if not chunks or chunks[-1][4:8] != b'IEND':
            chunks.append(b'\x00\x00\x00\x00IEND\xae\x42\x60\x82')
            repairs.append("Added missing IEND chunk")
        
        # 写入修复后的文件
        with open(output_file, 'wb') as f:
            f.write(b'\x89PNG\r\n\x1a\n')
            for chunk in chunks:
                f.write(chunk)
        
        return repairs
```

## 十一、性能优化建议

### 11.1 读取优化

```python
class FastPNGReader:
    """高性能PNG读取器"""
    
    def __init__(self, filename):
        self.filename = filename
        self.file = None
        self.mmap_data = None
    
    def __enter__(self):
        self.file = open(self.filename, 'rb')
        # 使用内存映射提高大文件读取性能
        self.mmap_data = mmap.mmap(
            self.file.fileno(), 0, 
            access=mmap.ACCESS_READ
        )
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.mmap_data:
            self.mmap_data.close()
        if self.file:
            self.file.close()
    
    def read_chunks_lazy(self):
        """惰性读取块，节省内存"""
        pos = 8  # 跳过签名
        
        while pos < len(self.mmap_data):
            # 只读取块头信息
            length = struct.unpack('>I', self.mmap_data[pos:pos+4])[0]
            chunk_type = self.mmap_data[pos+4:pos+8].decode('ascii')
            
            yield {
                'type': chunk_type,
                'length': length,
                'position': pos + 8,  # 数据开始位置
                'get_data': lambda p=pos+8, l=length: self.mmap_data[p:p+l]
            }
            
            pos += 12 + length
            
            if chunk_type == 'IEND':
                break
```

### 11.2 并行处理

```python
import concurrent.futures
from multiprocessing import cpu_count

class ParallelPNGProcessor:
    """并行PNG处理器"""
    
    def process_multiple_files(self, filenames, process_func):
        """并行处理多个PNG文件"""
        max_workers = min(cpu_count(), len(filenames))
        
        with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
            futures = {
                executor.submit(process_func, fn): fn 
                for fn in filenames
            }
            
            results = {}
            for future in concurrent.futures.as_completed(futures):
                filename = futures[future]
                try:
                    results[filename] = future.result()
                except Exception as e:
                    results[filename] = {'error': str(e)}
            
            return results
    
    def parallel_filter(self, image_data, width, height):
        """并行应用滤波器"""
        rows = self.split_into_rows(image_data, width, height)
        
        with concurrent.futures.ThreadPoolExecutor() as executor:
            # 为每行并行选择最优滤波器
            futures = []
            for i, row in enumerate(rows):
                prev_row = rows[i-1] if i > 0 else None
                future = executor.submit(
                    self.find_best_filter, row, prev_row
                )
                futures.append(future)
            
            # 收集结果
            filtered_rows = []
            for future in futures:
                filtered_rows.append(future.result())
            
            return filtered_rows
```

