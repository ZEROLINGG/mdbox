{"Java/核心类库/Java集合框架/List-接口":{"slug":"Java/核心类库/Java集合框架/List-接口","filePath":"Java/核心类库/Java集合框架/List 接口.md","title":"List 接口","links":[],"tags":[],"content":"一、List 接口概述\njava.util.List&lt;E&gt; 接口定义了一个元素有序、可重复的集合，其中每个元素都有其对应的索引位置（从 0 开始）。\n主要特性：\n\n元素按插入顺序排序；\n允许添加重复元素；\n允许插入 null（视具体实现而定）；\n提供基于索引的访问方法（如 get(int index)）；\n可通过 ListIterator 进行双向迭代。\n\n\n二、常用实现类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类名底层结构线程安全查询效率插入/删除效率备注ArrayList动态数组否高较低（尤其在中间插入）最常用，适合读多写少场景LinkedList双向链表否较低高（在头尾插入/删除）支持队列、栈操作Vector动态数组是高较低已过时，建议用 ArrayListCopyOnWriteArrayList动态数组是（读写分离）读高写低写操作会复制整个数组适用于读多写少的并发环境\n\n三、常用方法（以 ArrayList 为例）\n1. 添加元素\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;Java&quot;);\nlist.add(&quot;Python&quot;);\nlist.add(1, &quot;C++&quot;);  // 在索引 1 处插入\n2. 获取元素\nString value = list.get(0);  // 获取第一个元素\n3. 修改元素\nlist.set(1, &quot;Go&quot;);  // 修改索引 1 的元素为 &quot;Go&quot;\n4. 删除元素\nlist.remove(&quot;Python&quot;);  // 删除指定元素\nlist.remove(0);         // 删除指定索引的元素\n5. 查找元素\nint index = list.indexOf(&quot;Go&quot;);     // 第一次出现的索引\nint lastIndex = list.lastIndexOf(&quot;Go&quot;); // 最后一次出现的索引\nboolean contains = list.contains(&quot;Java&quot;);\n6. 子列表\nList&lt;String&gt; subList = list.subList(1, 3);  // 左闭右开：[1, 3)\n\n四、遍历方式\n1. for-each 循环\nfor (String item : list) {\n    System.out.println(item);\n}\n2. 使用 Iterator\nIterator&lt;String&gt; it = list.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n3. 使用 ListIterator（支持双向遍历）\nListIterator&lt;String&gt; lit = list.listIterator();\nwhile (lit.hasNext()) {\n    System.out.println(lit.next());\n}\n\n五、线程安全方案\n\n\nList 本身不是线程安全的；\n\n\n如果需要线程安全的列表：\n\n\n使用 Collections.synchronizedList(...)\n\n\nList&lt;String&gt; syncList = Collections.synchronizedList(new ArrayList&lt;&gt;());\n\n使用并发包中的 CopyOnWriteArrayList\n\n\n六、性能比较：ArrayList vs LinkedList\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作类型ArrayListLinkedList随机访问（get）快（O(1)）慢（O(n)）插入/删除头部慢（O(n)）快（O(1)）插入/删除中部慢（O(n)）慢（O(n)）内存占用较少较多（节点+指针）\n\n七、典型应用场景\n\nArrayList：适用于查找频繁、修改少的场景；\nLinkedList：适用于频繁插入/删除的队列或栈结构；\nCopyOnWriteArrayList：适用于并发读多、写少的场景（如监听器列表）；\n\n\n八、示例代码\npublic class ListExample {\n    public static void main(String[] args) {\n        List&lt;String&gt; languages = new ArrayList&lt;&gt;();\n        languages.add(&quot;Java&quot;);\n        languages.add(&quot;Python&quot;);\n        languages.add(&quot;C++&quot;);\n \n        for (String lang : languages) {\n            System.out.println(lang);\n        }\n \n        if (languages.contains(&quot;Java&quot;)) {\n            System.out.println(&quot;Java is in the list.&quot;);\n        }\n \n        languages.remove(&quot;C++&quot;);\n        System.out.println(&quot;After removal: &quot; + languages);\n    }\n}\n\n九、总结\nList 接口是 Java 集合中最常用的一种类型，提供了丰富的操作方法来处理有序数据集合。合理选择其实现类（ArrayList、LinkedList、Vector、CopyOnWriteArrayList）对于提升程序性能和可维护性具有重要意义。"},"Java/核心类库/Java集合框架/Map-接口":{"slug":"Java/核心类库/Java集合框架/Map-接口","filePath":"Java/核心类库/Java集合框架/Map 接口.md","title":"Map 接口","links":[],"tags":[],"content":"Map 接口是 Java 集合框架中用于存储键值对（key-value）的一种结构。与 **Collection** 接口不同，**Map** 不是 **Collection** 的子接口。它专门用于****通过键来快速访问对应的值，并且键不能重复（基于 equals() 和 hashCode()）。\n\n一、Map 接口的基本特征\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性说明键值对结构每个元素都由一个键（key）和一个值（value）组成。键唯一同一个 Map中不能有重复的键。值可重复值可以重复，不受限制。无序大多数实现类（如 HashMap）不保证顺序。\n\n二、常见实现类对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n实现类特点HashMap无序，键值允许 null，非线程安全，性能高。LinkedHashMap保持插入顺序，适合需要顺序访问的场景。TreeMap自动按键排序（自然顺序或自定义排序），基于红黑树。Hashtable线程安全，古老实现，不推荐使用。ConcurrentHashMap高性能并发 Map，线程安全，适合多线程环境。EnumMap专为枚举类型键设计，效率极高。\n\n三、常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法描述put(K key, V value)添加或替换键值对。get(Object key)根据键获取值。remove(Object key)删除指定键的映射。containsKey(Object key)是否包含指定键。containsValue(Object value)是否包含指定值。size()获取映射数量。isEmpty()是否为空映射。clear()清空所有键值对。keySet()返回所有键的 Set视图。values()返回所有值的 Collection视图。entrySet()返回所有键值对的 Set&lt;Map.Entry&lt;K,V&gt;&gt;视图。\n\n四、示例：使用 HashMap\nimport java.util.HashMap;\nimport java.util.Map;\n \npublic class MapExample {\n    public static void main(String[] args) {\n        // 创建一个 Map 实例\n        Map&lt;String, Integer&gt; scores = new HashMap&lt;&gt;();\n \n        // 添加元素\n        scores.put(&quot;Alice&quot;, 85);\n        scores.put(&quot;Bob&quot;, 90);\n        scores.put(&quot;Charlie&quot;, 78);\n \n        // 替换已有键的值\n        scores.put(&quot;Alice&quot;, 88); // Alice 原来的 85 被替换为 88\n \n        // 获取值\n        System.out.println(&quot;Bob的成绩: &quot; + scores.get(&quot;Bob&quot;));\n \n        // 遍历键值对\n        System.out.println(&quot;所有成绩:&quot;);\n        for (Map.Entry&lt;String, Integer&gt; entry : scores.entrySet()) {\n            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());\n        }\n \n        // 判断是否包含某键或某值\n        System.out.println(&quot;是否包含 Alice: &quot; + scores.containsKey(&quot;Alice&quot;));\n        System.out.println(&quot;是否包含成绩 100: &quot; + scores.containsValue(100));\n \n        // 删除键值对\n        scores.remove(&quot;Charlie&quot;);\n \n        // 输出剩余键值对\n        System.out.println(&quot;删除后的Map: &quot; + scores);\n \n        // 获取键集合\n        System.out.println(&quot;所有学生: &quot; + scores.keySet());\n \n        // 获取值集合\n        System.out.println(&quot;所有成绩: &quot; + scores.values());\n    }\n}\n\n示例输出：\nBob的成绩: 90\n所有成绩:\nAlice: 88\nBob: 90\n是否包含 Alice: true\n是否包含成绩 100: false\n删除后的Map: {Alice=88, Bob=90}\n所有学生: [Alice, Bob]\n所有成绩: [88, 90]\n\n五、底层机制简要分析\nHashMap\n\n基于哈希表（数组 + 链表 / 红黑树）。\n插入时根据 key.hashCode() 计算哈希位置。\nJDK 1.8 起，链表长度超过 8 转为红黑树以提升效率。\n\nTreeMap\n\n使用红黑树存储，自动对键进行排序。\n插入与查找的时间复杂度为 O(log n)。\n\nLinkedHashMap\n\n内部维护一个双向链表记录插入顺序。\n适用于需要顺序遍历的场景，如缓存（可结合 LRU 策略使用）。\n\n\n六、线程安全说明\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型是否线程安全建议用途HashMap否单线程或外部同步使用Hashtable是（过时）不推荐使用ConcurrentHashMap是并发访问环境下的首选\n\n七、TreeMap\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n场景推荐实现无需顺序，性能优先HashMap保持插入顺序LinkedHashMap需要键排序TreeMap多线程安全ConcurrentHashMap键为枚举类型EnumMap\n✅ 一、什么是 TreeMap？\nTreeMap 是 Java 集合框架中的一种基于红黑树（Red-Black Tree）实现的有序映射表（Map）。它实现了 NavigableMap 接口，并保证键值对按照键的自然顺序（或指定的比较器）进行排序。\n\n✅ 二、TreeMap 的主要特点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性说明有序性自动按照键进行升序排序（默认按自然顺序排序）基于红黑树内部使用红黑树结构，保证查找/插入/删除的时间复杂度为 O(log n)不允许 null键与 HashMap不同，TreeMap中键不能为空；值可以为 null线程不安全如果用于多线程环境，需手动同步或使用 Collections.synchronizedMap()可自定义排序可通过构造方法传入 Comparator来自定义排序规则\n\n✅ 三、基本语法与构造方法\nTreeMap&lt;K, V&gt; map = new TreeMap&lt;&gt;();\nTreeMap&lt;K, V&gt; map = new TreeMap&lt;&gt;(Comparator&lt;? super K&gt; comparator); // 自定义排序\nTreeMap&lt;K, V&gt; map = new TreeMap&lt;&gt;(Map&lt;? extends K, ? extends V&gt; m); // 从其他Map复制\n\n✅ 四、常用方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能说明put(K key, V value)添加键值对get(Object key)获取指定键的值remove(Object key)删除指定键firstKey()获取最小的键lastKey()获取最大的键ceilingKey(K key)≥ 指定键的最小键floorKey(K key)≤ 指定键的最大键higherKey(K key)&gt; 指定键的最小键lowerKey(K key)&lt; 指定键的最大键subMap(K fromKey, K toKey)获取部分视图（[fromKey, toKey)）descendingMap()返回逆序视图\n\n✅ 五、使用示例\n1. 基本使用：自动按键排序\nimport java.util.*;\n \npublic class TreeMapExample {\n    public static void main(String[] args) {\n        TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();\n \n        map.put(3, &quot;C&quot;);\n        map.put(1, &quot;A&quot;);\n        map.put(2, &quot;B&quot;);\n        map.put(4, &quot;D&quot;);\n \n        System.out.println(&quot;TreeMap 自动按 key 升序排序：&quot;);\n        for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {\n            System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());\n        }\n    }\n}\n2. 使用自定义排序（字符串按降序）\nimport java.util.*;\n \npublic class TreeMapCustomSort {\n    public static void main(String[] args) {\n        TreeMap&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(Comparator.reverseOrder());\n \n        map.put(&quot;Banana&quot;, 2);\n        map.put(&quot;Apple&quot;, 5);\n        map.put(&quot;Mango&quot;, 3);\n \n        System.out.println(&quot;TreeMap 按字符串 key 降序排序：&quot;);\n        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {\n            System.out.println(entry.getKey() + &quot; =&gt; &quot; + entry.getValue());\n        }\n    }\n}\n3. 应用：统计并按分数排序（学生成绩）\nimport java.util.*;\n \npublic class StudentScores {\n    public static void main(String[] args) {\n        TreeMap&lt;Integer, String&gt; scores = new TreeMap&lt;&gt;();\n \n        scores.put(85, &quot;Alice&quot;);\n        scores.put(92, &quot;Bob&quot;);\n        scores.put(75, &quot;Charlie&quot;);\n        scores.put(90, &quot;Diana&quot;);\n \n        System.out.println(&quot;按分数升序输出学生成绩：&quot;);\n        for (Map.Entry&lt;Integer, String&gt; entry : scores.entrySet()) {\n            System.out.println(&quot;分数: &quot; + entry.getKey() + &quot;, 学生: &quot; + entry.getValue());\n        }\n    }\n}\n\n✅ 六、TreeMap 与其他 Map 的对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性HashMapLinkedHashMapTreeMap是否有序否插入顺序按键排序（有序）基本结构哈希表哈希表 + 链表红黑树空键是否允许允许 1 个 null 键允许❌ 不允许 null 键性能查询性能最高查询快且有顺序有序但性能略低应用场景快速查找保留插入顺序需要自动排序时\n\n✅ 七、适用场景总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n场景建议使用快速查找、不关心顺序HashMap保留插入顺序LinkedHashMap自动排序、范围查询、按键范围统计等✅ TreeMap"},"Java/核心类库/Java集合框架/Set-接口":{"slug":"Java/核心类库/Java集合框架/Set-接口","filePath":"Java/核心类库/Java集合框架/Set 接口.md","title":"Set 接口","links":[],"tags":[],"content":"Set 接口是 Java 集合框架中用于存储不重复元素的数据结构。它继承自 Collection 接口，与 List 不同的是，Set不保证元素的顺序，并且不允许包含重复元素（即元素的 equals() 和 hashCode() 相同）。\n\n一、Set 接口的主要特征\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性描述唯一性所有元素必须唯一，不能有重复项。无序性大多数实现类（如 HashSet）不保证元素的插入顺序。无索引Set不支持使用索引访问元素，如 get(index)。\n\n二、常见的 Set 实现类及其特点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n实现类特点HashSet基于哈希表，元素无序，访问速度快，不允许重复元素。LinkedHashSet保持插入顺序，基于哈希表+链表。TreeSet元素自动排序（默认按自然顺序，或可使用 Comparator），基于红黑树。EnumSet专为枚举类型设计，效率高，不能用于非枚举。CopyOnWriteArraySet线程安全的 Set，用于并发环境，写时复制策略。\n\n三、常用方法（继承自 Collection 接口）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法描述add(E e)添加元素，如果元素已存在则添加失败。remove(Object o)删除指定元素。contains(Object o)判断是否包含元素。size()返回元素数量。isEmpty()判断集合是否为空。clear()清空集合。iterator()返回一个迭代器，用于遍历元素。\n\n四、典型示例\n示例：使用 HashSet\nimport java.util.HashSet;\nimport java.util.Set;\n \npublic class SetExample {\n    public static void main(String[] args) {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n \n        // 添加元素\n        set.add(&quot;Apple&quot;);\n        set.add(&quot;Banana&quot;);\n        set.add(&quot;Cherry&quot;);\n        set.add(&quot;Apple&quot;); // 重复元素不会被添加\n \n        // 打印所有元素（无特定顺序）\n        System.out.println(&quot;Set内容: &quot; + set);\n \n        // 判断是否包含某元素\n        System.out.println(&quot;是否包含 Banana: &quot; + set.contains(&quot;Banana&quot;));\n \n        // 删除元素\n        set.remove(&quot;Cherry&quot;);\n \n        // 遍历Set（增强for循环）\n        System.out.println(&quot;遍历Set:&quot;);\n        for (String fruit : set) {\n            System.out.println(fruit);\n        }\n \n        // 集合大小\n        System.out.println(&quot;Set大小: &quot; + set.size());\n    }\n}\n\n示例输出（注意：HashSet 无顺序）\nSet内容: [Banana, Apple, Cherry]\n是否包含 Banana: true\n遍历Set:\nBanana\nApple\nSet大小: 2\n\n五、HashSet 背后的原理简述\n\n内部使用 HashMap 来存储元素，元素作为键（key），值（value）是一个固定的常量。\n元素的唯一性依赖于 hashCode() 和 equals() 方法。\n添加新元素时，先计算其哈希值，查找是否已有等值元素，若无则插入。\n\n\n六、选择使用哪种 Set\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用场景推荐实现无序，快速查找HashSet保持插入顺序LinkedHashSet自动排序TreeSet枚举集合EnumSet多线程环境CopyOnWriteArraySet、Collections.synchronizedSet()"},"Java/核心类库/Java集合框架/概览":{"slug":"Java/核心类库/Java集合框架/概览","filePath":"Java/核心类库/Java集合框架/概览.md","title":"概览","links":[],"tags":[],"content":"一、集合框架的总体结构\nJava 集合框架主要包括以下几个核心部分：\n\n接口（Interfaces）：定义了集合的基本行为，如 Collection、List、Set、Map、Queue 等。\n实现类（Implementations）：实现上述接口的具体类，如 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等。\n算法（Algorithms）：主要通过 Collections 类提供一组静态方法，如排序、查找、填充、复制、反转等操作。\n工具类（Utility Classes）：如 Collections 和 Arrays，提供对集合和数组的辅助方法。\n迭代器（Iterators）：如 Iterator、ListIterator 和 Enumeration，用于遍历集合中的元素。\n\n\n二、核心接口及其继承关系\nIterable\n                      |\n                   Collection\n         _____________|___________\n        |             |           |\n      List           Set        Queue\n        |             |           |\nArrayList/      HashSet/       LinkedList/\nLinkedList     TreeSet        PriorityQueue\n \n                 Map（不继承 Collection）\n                /   \\\n         HashMap   TreeMap\n1. Collection 接口\n\n是所有集合类的根接口，定义了基本的增删查操作。\n子接口包括 List、Set 和 Queue。\n\n2. List 接口\n\n\n元素有序且可重复，支持按索引访问。\n\n\n实现类：\n\n\nArrayList：基于动态数组，查询快，插入/删除慢。\n\n\nLinkedList：基于双向链表，插入/删除快，查询慢。\n\n\nVector（已不推荐）：线程安全，性能低于 ArrayList。\n\n\n3. Set 接口\n\n\n元素无序且不可重复。\n\n\n实现类：\n\n\nHashSet：基于哈希表，性能较好，不保证顺序。\n\n\nLinkedHashSet：维护插入顺序。\n\n\nTreeSet：基于红黑树，元素自动排序。\n\n\n4. Queue 接口\n\n\n支持队列操作，先进先出（FIFO）。\n\n\n实现类：\n\n\nLinkedList：既可以作为队列，也可以作为双端队列。\n\n\nPriorityQueue：带有优先级的队列，元素排序基于自然排序或比较器。\n\n\n5. Map 接口\n\n\n键值对存储结构，不继承自 Collection 接口。\n\n\n键唯一，值可重复。\n\n\n实现类：\n\n\nHashMap：最常用的实现，线程不安全。\n\n\nLinkedHashMap：维护插入顺序。\n\n\nTreeMap：基于红黑树，按键排序。\n\n\nHashtable：线程安全，已过时。\n\n\n\n三、常用类功能对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类名底层结构是否有序是否允许重复是否线程安全ArrayList动态数组是（按索引）是否LinkedList双向链表是（按顺序）是否HashSet哈希表否否否LinkedHashSet哈希表+链表是（插入顺序）否否TreeSet红黑树是（排序）否否HashMap哈希表否键不能重复否LinkedHashMap哈希表+链表是（插入顺序）键不能重复否TreeMap红黑树是（按键排序）键不能重复否\n\n四、集合框架的常见算法\n使用 Collections 类提供的工具方法可以对集合进行如下操作：\n\n排序：Collections.sort(List&lt;T&gt; list)\n二分查找：Collections.binarySearch(List&lt;T&gt; list, T key)\n打乱顺序：Collections.shuffle(List&lt;T&gt; list)\n填充：Collections.fill(List&lt;T&gt; list, T obj)\n反转：Collections.reverse(List&lt;T&gt; list)\n最值查找：Collections.max(Collection&lt;? extends T&gt;)、Collections.min(...)\n\n\n五、线程安全的集合\n默认集合类大多是非线程安全的。可通过以下方式实现线程安全：\n\n\n使用同步包装器：Collections.synchronizedList(...)\n\n\n使用并发集合类：\n\n\nConcurrentHashMap\n\n\nCopyOnWriteArrayList\n\n\nBlockingQueue（如 LinkedBlockingQueue）\n\n"},"Java/概览":{"slug":"Java/概览","filePath":"Java/概览.md","title":"概览","links":[],"tags":[],"content":"一、Java 基础\n1. Java 简介\n\nJava 语言的定义与特点\nJava 应用场景与市场地位\n\n2. Java 语言发展史\n\nJava 语言的历史背景\nJava 版本演变与主要特性\n\n3. JDK、JRE、JVM 区别与关系\n\nJDK（Java Development Kit）详解\nJRE（Java Runtime Environment）详解\nJVM（Java Virtual Machine）详解\n它们之间的关系与作用\n\n4. Java 程序运行机制\n\nJava 编译过程\nJava 程序的执行过程（从编译到运行）\nJava 程序的内存管理与垃圾回收机制（GC）\n\n5. 开发环境配置\n\n安装 JDK\n配置环境变量\n使用 IDE（如 IntelliJ IDEA、Eclipse）\n\n6. 基础语法\n\n标识符与关键字\n数据类型与变量\n运算符与表达式\n控制流程（if、switch、for、while、do-while）\n数组\n\n7. 面向对象编程（OOP）\n\n类与对象\n构造方法\nthis 关键字\n封装、继承、多态\n方法重载与重写（Overload vs Override）\nstatic 与 final 关键字\n抽象类与接口\n\n\n二、Java 核心类库\n1. 常用类\n\nObject 类方法\nString、StringBuilder、StringBuffer\n包装类（Integer、Double 等）\nMath、Arrays、Collections\n\n2. 集合框架\n\nList、Set、Map 接口与实现类\nArrayList、LinkedList、HashSet、TreeSet\nHashMap、TreeMap、LinkedHashMap\n集合遍历方式（Iterator、增强 for、Stream）\n\n3. 异常处理\n\n异常体系（Checked vs Unchecked）\ntry-catch-finally\nthrows 与 throw\n自定义异常\n\n4. 常用工具类与包\n\njava.util、java.lang、java.io、java.time\n自动装箱与拆箱\n\n\n三、Java 进阶\n1. Java I/O（输入输出）\n\n字节流与字符流（InputStream、OutputStream、Reader、Writer）\n文件操作（File 类）\n缓冲流、对象流、序列化\n\n2. 多线程与并发\n\nThread 类与 Runnable 接口\n线程生命周期\n同步（synchronized、Lock）\n线程通信（wait/notify）\n线程池（Executors）\n并发工具类（CountDownLatch、Semaphore、CyclicBarrier）\n\n3. 网络编程\n\nSocket 通信模型\nTCP 与 UDP 编程\nURL 与 HttpURLConnection\n简单客户端/服务器示例\n\n4. 反射机制\n\nClass 类\n动态创建对象与调用方法\n注解与反射结合使用\n\n5. 注解（Annotation）\n\n元注解（@Target、@Retention 等）\n自定义注解\n注解与 APT、反射结合使用\n\n\n四、Java 高级应用\n1. 泛型（Generics）\n\n泛型类与方法\n通配符 ?、extends、super\n泛型与集合框架结合\n\n2. 枚举与注解\n\n枚举类定义与使用\n枚举实现接口\n注解机制原理\n\n3. Java 8 新特性\n\nLambda 表达式\n函数式接口（Function、Consumer、Supplier、Predicate 等）\nStream API\nOptional 类\n方法引用与构造器引用\n\n4. Java 9+ 新特性（可选）\n\n模块系统（Module）\n改进的 API（如 List.of() 等）\nJShell 工具\n\n\n五、Java 开发实践\n1. 单元测试\n\nJUnit（4/5）\nMockito 简介\n\n2. 日志系统\n\nLog4j、SLF4J、Logback\n\n3. 构建工具\n\nMaven、Gradle 使用\n\n4. 代码规范\n\n命名规范\n注释规范\n代码格式化与重构习惯\n\n\n六、Java Web 开发基础（延伸）\n1. Servlet 与 JSP\n\nServlet 生命周期与概念\nJSP 标签与 EL（Expression Language）\n\n2. Tomcat 使用\n\nTomcat 配置与部署\nWeb 应用开发与管理\n\n3. Spring 框架（Spring、Spring Boot）\n\nSpring 核心概念\nSpring Boot 快速入门\nSpring 配置与依赖注入\n\n4. MyBatis、Hibernate\n\nMyBatis 简介与使用\nHibernate 简介与 ORM\n\n5. RESTful API 开发\n\nRESTful 风格设计\n使用 Spring Boot 开发 RESTful 服务\n基于 Spring 的 JSON 数据处理与跨域请求支持\n"},"README":{"slug":"README","filePath":"README.md","title":"README","links":[],"tags":[],"content":"mdbox - 多领域知识库笔记\n介绍\n欢迎来到 mdbox 知识库！本仓库用于整理和归档多个技术方向的学习笔记，涵盖编程语言、网络安全、CTF、数据库等主题。所有内容都以 Markdown 形式编写，并适配 Obsidian 使用。\n当然也可以在线使用： 在线网址\n主要分类\n\n编程语言: Python、Java、C/C++、汇编\n网络安全: Web 安全、KALI、CTF 题解\n脚本语言: PowerShell、VBScript、JavaScript\n数据库: MySQL、SQLite\n\n协作指导\n如何参与\n\n\nFork 仓库:\n\n点击右上角的 Fork 按钮，创建仓库的副本到你自己的 GitHub 账户中。\n在你的 GitHub 账户中，你将拥有该仓库的完整控制权限，可以自由修改。\n\n\n\n克隆仓库到本地:\n\n通过 Git 将仓库克隆到你本地的计算机，以便进行更改：\ngit clone github.com/ZEROLINGG/mdbox.git\n\n\n\n\n创建新分支:\n\n在进行修改之前，你可以选择创建一个新的分支以避免直接修改主分支。分支名称应简洁且有描述性。\ngit checkout -b one\n\none 替换为你要进行的修改或新增功能的名称。\n\n\n\n编辑文档:\n\n使用你熟悉的编辑器（如 Obsidian 或 Visual Studio Code）打开 .md 文件进行修改。可以在各个分类下添加新的内容、更新现有文档或修正拼写错误。\n确保所有新内容都符合现有的文档结构和格式。\n\n\n\n提交更改:\n\n在本地提交你的更改时，确保提交信息简洁明了，并准确描述修改内容。遵循 Commit Message Convention 规范：\ngit add .\ngit commit -m &quot;添加了新的知识&quot;\n\n\n\n\n推送更改:\n\n将修改推送到 GitHub 仓库中：\ngit push -u origin main\n\n推送后，你可以在 GitHub 仓库中看到你的修改已上传。\n\n\n\n提交 Pull Request:\n\n在 GitHub 上打开你的仓库，点击 Pull Requests，然后点击 New Pull Request。\n选择你刚才创建的分支（如果创建了）和主仓库的 main 分支进行对比。\n在提交 Pull Request 时，确保说明清楚你所做的更改和修改的目的。例如：\n添加 Python 基础知识部分，并更新了部分格式。\n修正了 C++ 部分的拼写错误。\n\n\n\n\n\n审查与合并:\n\n项目维护者定期审查 Pull Request。在合并之前，确保所有修改通过了检查并且没有引入任何不一致的格式或错误。\n如果有任何问题或需要改进的地方，会要求修改并重新提交。\n\n\n\n协作规则与最佳实践\n\n\n命名规范:\n\n在创建分支时，请使用简短且有描述性的名称，说明所做的修改内容。例如，add-python-functions，fix-markdown-syntax。\n\n\n\n文档格式与一致性:\n\n请严格遵循 Markdown 格式，保持文档的简洁性和清晰性。你可以参考已有文档的格式。\n对于代码片段，可以使用 ``` 代码块 语法，确保代码可读性：\ndef hello_world():\n    print(&quot;Hello, world!&quot;)\n\n\n\n\n详细的提交信息:\n\n提交信息应简洁且描述明确。避免使用含糊不清的提交信息（如 fix bug，update files），应具体说明修改的内容（如 修复 Python 示例代码中的错误，更新 MySQL 连接配置部分）。\n\n\n\nPull Request 审查:\n\n提交 Pull Request 后，等待项目维护者审查并合并。如果有反馈，及时进行修改并更新 PR。\n记得在提交 PR 后留意评论和审查建议，及时回复和调整。\n\n\n\n避免直接在 main 分支上进行修改:\n\n所有更改都应通过新建分支并提交 Pull Request 的方式进行，这样可以确保仓库的稳定性。\n\n\n\n问题反馈与讨论\n\n\n报告问题:\n\n如果你在使用过程中发现问题，或在修改过程中遇到障碍，可以使用 Issues 功能报告问题。\n在仓库的 Issues 页面，点击 New Issue，并提供详细的问题描述，附带错误日志、截图或复现步骤。\n\n\n\n讨论与提问:\n\n如果你有任何疑问或想要与其他人讨论某个问题，可以在仓库的 Discussions 中发起讨论。\n在 Discussions 页面，选择 New Discussion，并选择讨论类型（如问题、提案等）。\n\n\n\n标签使用:\n\n为 Issues 和 Pull Requests 添加适当的标签，例如 bug、enhancement、question 等，以便分类管理。\n\n\n\n其他资源\n\nObsidian: 本仓库中的笔记适合使用 Obsidian 打开，以便获得最佳的浏览体验和图谱功能。\nMarkdown 语法: 如果你不熟悉 Markdown 格式，可以参考 Markdown 官方文档 和Markdown 菜鸟教程进行学习。\n\n贡献者\n感谢每一位参与者，你的贡献对本项目至关重要！通过大家的共同努力，我们的知识库将不断完善，并帮助更多学习者。\n\n\n注意: 请在进行任何修改之前，先确保自己理解当前文档的内容，并尽量避免对已有内容做不必要的更改。如果有疑问或不确定的地方，请随时在 Issues 或 Discussions 中提问。\n"},"c++/基础知识/变量声明与初始化":{"slug":"c++/基础知识/变量声明与初始化","filePath":"c++/基础知识/变量声明与初始化.md","title":"变量声明与初始化","links":[],"tags":[],"content":"一、变量声明\n变量声明就是告诉编译器你要使用一个什么类型的变量，并为它分配内存空间。声明变量的基本语法如下：\n类型 变量名;\n示例：\nint age;\ndouble price;\nchar grade;\n此时，age 是一个整型变量，price 是一个双精度浮点型变量，grade 是一个字符型变量。\n\n二、变量初始化\n变量初始化就是在声明变量的同时给它赋一个初始值。初始化可以在声明时进行，也可以在声明后赋值。\n1. 声明时初始化\nint age = 18;\ndouble price = 99.99;\nchar grade = &#039;A&#039;;\n2. 声明后赋值（赋值不是初始化）\nint age;\nage = 18;\n\n三、C++中的初始化方式\nC++ 支持多种初始化方式，主要有以下几种：\n1. 括号初始化（构造函数风格）\nint a(10);\ndouble b(3.14);\n2. 等号初始化（拷贝初始化）\nint a = 10;\ndouble b = 3.14;\n3. 列表初始化（C++11 引入）\nint a{10};\ndouble b{3.14};\nint c{}; // 初始化为0\n注意：\n\n列表初始化可以防止窄化（narrowing）转换，比如 int a{3.14}; 会报错。\nint c{}; 这种写法会将变量初始化为0。\n\n\n四、未初始化变量的风险\n\n局部变量（在函数内部声明的变量）如果没有初始化，其值是未定义的（随机值）。\n全局变量、静态变量如果没有初始化，会被自动初始化为0。\n\n示例：\nvoid func() {\n    int x; // 未初始化，值不确定\n    std::cout &lt;&lt; x &lt;&lt; std::endl; // 可能输出任意值\n}\n\n五、常量声明与初始化\n常量必须在声明时初始化，且值不能再改变。\nconst int maxSize = 100;\n\n六、auto 关键字（类型自动推断，C++11）\nauto x = 10;      // x 被推断为 int\nauto y = 3.14;    // y 被推断为 double\nauto z = &#039;A&#039;;     // z 被推断为 char\n\n七、总结\n\n声明：告诉编译器变量的类型和名字。\n初始化：为变量赋初值。\nC++ 支持多种初始化方式，推荐使用列表初始化（{}）以避免隐式类型转换带来的问题。\n局部变量未初始化会有随机值，需注意。\n\n\n八、完整示例\n#include &lt;iostream&gt;\nusing namespace std;\n \nint globalVar; // 全局变量，自动初始化为0\n \nint main() {\n    int a = 5;         // 等号初始化\n    double b(3.14);    // 括号初始化\n    char c{&#039;A&#039;};       // 列表初始化\n    int d{};           // 初始化为0\n \n    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\n    cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;\n    cout &lt;&lt; &quot;globalVar = &quot; &lt;&lt; globalVar &lt;&lt; endl;\n \n    return 0;\n}\n"},"c++/基础知识/基本语法规范":{"slug":"c++/基础知识/基本语法规范","filePath":"c++/基础知识/基本语法规范.md","title":"基本语法规范","links":[],"tags":[],"content":"基本语法规范详细讲解\n1. 标识符（Identifiers）\n标识符是程序中用于命名变量、函数、类、命名空间等实体的名称。\n\n由字母（A-Z, a-z）、数字（0-9）和下划线（_）组成，但不能以数字开头。\n区分大小写，例如 Variable 与 variable 是不同的标识符。\n避免使用与C++关键字相同的名称。\n尽量使用有意义且简洁的命名，遵守命名规范（如驼峰式命名、下划线命名等）。\n\n示例：\nint age;\ndouble salaryRate;\nvoid calculateSalary();\n2. 关键字（Keywords）\nC++语言中预定义的保留词，具有特殊意义，不能用作标识符。\n示例关键字：int, float, if, else, while, class, return 等。\n3. 语句（Statements）\n程序执行的最小单位，以分号（;）结束。\n例如赋值语句：\nint a = 10;\na = a + 5;\n4. 注释（Comments）\n注释用于解释代码，编译器忽略注释内容。\n\n单行注释：//后面的内容直到行尾。\n多行注释：/* ... */之间的内容。\n\n示例：\n// 这是单行注释\n/* 这是\n   多行注释 */\n5. 数据类型（Data Types）\nC++是一种强类型语言，变量必须声明数据类型。常用数据类型包括：\n\n整型（int, short, long, long long）\n浮点型（float, double, long double）\n字符型（char）\n布尔型（bool）\n空类型（void，表示无返回值或无类型）\n\n可以使用signed或unsigned修饰整数类型。\n6. 变量声明与初始化\n变量必须先声明，后使用。初始化是给变量赋初值。\n示例：\nint x = 5;          // 声明并初始化\ndouble price;       \nprice = 19.99;      // 先声明后赋值\n推荐在声明时即初始化，避免未定义行为。\n7. 常量（Constants）\n不可更改的值，使用const关键字声明。\n示例：\nconst double PI = 3.14159;\n也可以使用constexpr声明编译期常量，提升效率。\n8. 运算符（Operators）\n用于进行各种计算和操作。常见运算符类别：\n\n算术运算符：+, -, *, /, %\n赋值运算符：=, +=, -=, *=, /=\n比较运算符：==, !=, &lt;, &gt;, &lt;=, &gt;=\n逻辑运算符：&amp;&amp;, ||, !\n位运算符：&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;\n其他：条件运算符（?:）、逗号运算符（,）等\n\n运算符优先级与结合性决定表达式的计算顺序，建议使用括号明确优先级。\n9. 表达式（Expressions）\n由运算符和操作数组成的代码片段，最终计算出一个值。\n示例：\nint result = (a + b) * c;\n10. 代码块与作用域\n代码块由大括号 {} 包围，定义一个局部作用域。\n变量的作用域限制在其定义所在的代码块内。\n示例：\n{\n    int temp = 100;   // temp作用域仅限于此块内\n}\n// temp不可访问\n11. 控制结构基本语法\n\n条件语句：\n\nif (condition) {\n    // 语句块\n} else {\n    // 语句块\n}\n\n循环语句：\n\nfor (int i = 0; i &lt; 10; ++i) {\n    // 循环体\n}\n \nwhile (condition) {\n    // 循环体\n}\n\n跳转语句：break, continue, goto（慎用）\n\n12. 函数基本语法\n函数声明和定义遵循格式：\n返回类型 函数名(参数列表) {\n    // 函数体\n    return 返回值;\n}\n示例：\nint add(int x, int y) {\n    return x + y;\n}\n13. 格式规范建议\n\n缩进：统一使用空格或Tab，通常4个空格为一层缩进。\n命名风格：变量名使用小写字母和下划线分隔（snake_case）或驼峰命名法（camelCase），类名首字母大写（PascalCase）。\n大括号风格：K&amp;R或Allman风格，根据团队规范统一。\n每条语句后加分号，避免遗漏。\n代码注释清晰简洁，便于维护。\n\n\n总结\nC++基本语法规范涵盖标识符命名、数据类型声明、语句结构、运算符使用、控制结构以及函数定义等内容。掌握这些基础语法是编写正确、规范、可维护C++程序的前提。"},"c++/基础知识/常量与字面量":{"slug":"c++/基础知识/常量与字面量","filePath":"c++/基础知识/常量与字面量.md","title":"常量与字面量","links":[],"tags":[],"content":"这两个概念紧密相关，但有着本质的区别。简单来说：\n\n字面量 (Literal)：是源代码中直接表示一个固定值的符号。它是“值”本身。例如 123, 3.14, &#039;A&#039;, &quot;hello&quot;。\n常量 (Constant)：是一个有名字的、其值在初始化后不能被改变的变量。它像一个贴了标签的、内容不可更改的盒子。例如 const int MAX_SIZE = 100;。\n\n下面我们分两大部分来详细剖析。\n\n第一部分：字面量 (Literals)\n字面量是 C++ 语言中最基本的元素之一，它们是值的直接表示形式，不需要计算。\n1. 整型字面量 (Integer Literals)\n表示整数值。\n\n十进制 (Decimal)：最常见的形式，由 0-9 组成，不能以 0 开头（除非这个数就是 0）。\n\nint a = 10;\nint b = -123;\n\n八进制 (Octal)：以 0 开头。\n\nint c = 077; // 7*8^1 + 7*8^0 = 56 + 7 = 63 (十进制)\n\n十六进制 (Hexadecimal)：以 0x 或 0X 开头。\n\nint d = 0xFF;  // 15*16^1 + 15*16^0 = 240 + 15 = 255 (十进制)\nint e = 0xabc;\n\n二进制 (Binary) (C++14+)：以 0b 或 0B 开头。\n\nint f = 0b1010; // 1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 8 + 2 = 10 (十进制)\n类型后缀 (Type Suffixes)：可以为整型字面量添加后缀来明确其类型。\n\nu 或 U：unsigned (无符号)\nl 或 L：long (长整型)\nll 或 LL：long long (长长整型, C++11)\n\n这些后缀可以组合使用，例如 100UL 表示一个 unsigned long 类型的字面量。\nauto val1 = 123;   // int\nauto val2 = 123U;  // unsigned int\nauto val3 = 123L;  // long\nauto val4 = 123ULL; // unsigned long long\n2. 浮点型字面量 (Floating-Point Literals)\n表示小数值。\n\n标准表示法：3.14159, -0.001\n科学计数法：6.022e23 (表示 6.022 x 10²³), 1.6e-19\n\n默认情况下，浮点字面量是 double 类型。\n类型后缀 (Type Suffixes)：\n\nf 或 F：float (单精度)\nl 或 L：long double (长双精度)\n\nauto f1 = 3.14;   // double\nauto f2 = 3.14f;  // float\nauto f3 = 3.14L;  // long double\n3. 字符字面量 (Character Literals)\n表示单个字符，用单引号 &#039; &#039; 括起来。\n\n\n普通字符：&#039;a&#039;, &#039;B&#039;, &#039;7&#039;\n\n\n转义序列：用于表示特殊字符。\n\n\n&#039;\\n&#039; (换行), &#039;\\t&#039; (水平制表), &#039;\\&#039;&#039; (单引号), &#039;\\&quot;&#039; (双引号), &#039;\\\\&#039; (反斜杠)\n\n\n&#039;\\xHH&#039; (用两位十六进制表示字符，如 &#039;\\x41&#039; 代表 ‘A’)\n\n\n宽字符和多字节字符前缀 (用于国际化):\n\n\nL&#039;A&#039;：wchar_t 类型\n\n\nu8&#039;A&#039;：char 类型 (UTF-8, C++17)\n\n\nu&#039;A&#039;：char16_t 类型 (UTF-16, C++11)\n\n\nU&#039;A&#039;：char32_t 类型 (UTF-32, C++11)\n\n\n4. 字符串字面量 (String Literals)\n表示一个字符序列，用双引号 &quot; &quot; 括起来。\n&quot;Hello, World!&quot;\n\n它在内存中是一个 const char 数组，并以一个空字符 &#039;\\0&#039; 结尾。所以 &quot;hello&quot; 的实际长度是 6。\n相邻的字符串字面量会自动拼接：&quot;hello&quot; &quot; world&quot; 等同于 &quot;hello world&quot;。\n同样支持字符字面量的转义序列和前缀（L&quot;&quot;, u8&quot;&quot;, u&quot;&quot;, U&quot;&quot;）。\n原始字符串字面量 (Raw String Literals, C++11)：\n\n// 普通字符串，需要转义\nstd::string path1 = &quot;C:\\\\Users\\\\Guest\\\\Documents&quot;;\n// 原始字符串，无需转义\nstd::string path2 = R&quot;(C:\\Users\\Guest\\Documents)&quot;;\n\n语法：R&quot;(...)&quot;\n用于避免转义反斜杠 \\，在写正则表达式或 Windows 文件路径时非常有用。\n\n5. 布尔字面量 (Boolean Literals)\n只有两个：true 和 false。\nbool is_ready = true;\nbool is_finished = false;\n6. 指针字面量 (Pointer Literal)\nC++11 引入了 nullptr，它是一个表示空指针的字面量。\nint* ptr = nullptr;\nnullptr 是类型安全的，优于旧式的 NULL 或 0。\n\n第二部分：常量 (Constants)\n常量是具有名称的标识符，其值在定义后不能修改。使用常量可以增强代码的可读性和可维护性，并提供类型安全。\nC++ 中定义常量主要有以下几种方式：\n1. const 关键字\n这是定义常量最常用、最基本的方式。\nconst double PI = 3.14159;\nconst int MAX_USERS = 100;\n// PI = 3.14; // 编译错误！不能修改 const 变量\nconst 的优点：\n\n类型安全：编译器知道它的类型，会进行类型检查。\n有作用域：const 变量遵循普通变量的作用域规则。\n可调试：在调试器中可以看到它的名字和值。\n\nconst 与指针：这是一个常见的难点，关键是看 const 修饰的是什么。\n\n指向常量的指针 (Pointer to const)：指针指向的值不能被修改，但指针本身可以指向别处。\n\nconst int val = 10;\nconst int* ptr = &amp;val; // ptr 指向一个常量\n// *ptr = 20; // 错误！不能通过 ptr 修改 val\nint another_val = 20;\nptr = &amp;another_val;   // 正确，指针可以指向另一个（常量或非常量）地址\nint const* ptr 和 const int* ptr 是等价的。\n\n常量指针 (const Pointer)：指针本身的值（即它存储的地址）不能被修改，但它指向的数据可以被修改（如果数据本身不是 const 的话）。\n\nint val = 10;\nint* const ptr = &amp;val; // ptr 是一个常量指针，必须在声明时初始化\n*ptr = 20;            // 正确，可以修改所指向的值\nint another_val = 30;\n// ptr = &amp;another_val; // 错误！不能修改 ptr 使其指向别处\n\n指向常量的常量指针 (const Pointer to const)：指针本身和它指向的值都不能被修改。\n\nconst int val = 10;\nconst int* const ptr = &amp;val;\n// *ptr = 20;          // 错误\n// ptr = &amp;another_val; // 错误\n2. constexpr 关键字 (C++11 及以后)\nconstexpr (Constant Expression, 常量表达式) 是 const 的加强版。它不仅表示“只读”，还强调其值必须在编译时就能确定。\nconstexpr double PI = 3.14159;\nconstexpr int MAX_SIZE = 10 * 10;\n \n// constexpr 还可以用于函数，表示函数在编译时可以被求值\nconstexpr int get_array_size() {\n    return 5;\n}\n \nint my_array[get_array_size() + 1]; // 正确，数组大小必须是编译时常量\nconst vs constexpr：\n\nconst 变量的值可能在运行时才确定。\n\nint n;\nstd::cin &gt;&gt; n;\nconst int SIZE = n; // SIZE 的值在运行时确定\n\nconstexpr 变量的值必须在编译时就确定。\n\nint n;\nstd::cin &gt;&gt; n;\n// constexpr int SIZE = n; // 编译错误！n 的值在编译时未知\n最佳实践：如果一个常量的值在编译时就可以确定，优先使用 constexpr。这能给编译器更多优化的机会，并能用在更多需要编译时常量的场景（如数组大小、模板参数等）。\n3. 枚举 (enum)\n用于定义一组相关的整型常量。\n\n传统 enum\n\nenum Color { RED, GREEN, BLUE }; // RED=0, GREEN=1, BLUE=2\nint c = RED; // 隐式转换为 int\n缺点：枚举成员会污染所在的作用域，且会隐式转换为整型，不够类型安全。\n\n作用域枚举 (enum class, C++11)\n\nenum class Color { RED, GREEN, BLUE };\nenum class Status { OK, FAILED };\n \nColor c = Color::RED; // 必须使用作用域解析符\n// int status_code = Status::OK; // 错误！不能隐式转换为 int\nif (c == Color::RED) {\n    // ...\n}\n强烈推荐使用 enum class，因为它解决了传统 enum 的所有缺点，更加类型安全和模块化。\n4. #define 预处理器指令\n这是 C 语言遗留下来的方式，在 C++ 中强烈不推荐用它来定义常量。\n#define PI 3.14159 // 不推荐！\n#define 的缺点：\n\n无类型安全：它只是简单的文本替换，在预处理阶段完成，编译器根本不知道 PI 是什么类型。\n无作用域：一旦定义，在整个文件中（直到 #undef）都有效，容易引起命名冲突。\n难以调试：预处理后，代码中的 PI 已经变成了 3.14159，调试时看不到 PI 这个符号。\n可能违反封装：如果定义在头文件中，会污染所有包含该头文件的代码。\n\n\n总结与最佳实践\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性字面量 (Literal)常量 (Constant)本质值的直接表示存储值的命名标识符形式123, 3.14f, &quot;hi&quot;, nullptrconst int a = 10;, constexpr ...是否有名字无有是否有类型有（如 123 是 int, 3.14f 是 float）有，且由编译器强制检查是否占内存通常不独立占内存（嵌入指令或数据段）通常有独立的内存地址（除非被优化掉）\n现代 C++ 最佳实践：\n\n优先使用 const 和 constexpr 而不是 #define 来定义常量。 这是 C++ 编程的基本准则。\n如果常量的值在编译时可知，优先使用 constexpr。 这能带来更好的性能和更广泛的用途。\n对于一组相关的整型常量，优先使用 enum class。 它提供了类型安全和作用域。\n对于空指针，总是使用 nullptr，而不是 0 或 NULL。\n在函数和方法中贯彻 const 正确性（const 参数、const 成员函数等），这能让接口更清晰，代码更健壮。\n使用字面量后缀（如 f, L, U）和前缀（如 R&quot;&quot;）来明确表达你的意图，避免不必要的类型转换和错误。\n"},"c++/基础知识/引用与指针":{"slug":"c++/基础知识/引用与指针","filePath":"c++/基础知识/引用与指针.md","title":"引用与指针","links":[],"tags":[],"content":"C++ 引用与指针详解\n在 C++ 中，指针 (Pointer) 和 引用 (Reference) 都提供了间接访问其他变量的能力。然而，它们在底层概念、语法和使用方式上有着本质的区别。理解这些区别对于编写安全、高效的 C++ 代码至关重要。\n一个简单的比喻：\n\n指针 就像一张写有朋友家庭住址的便签。你可以通过这张便签找到朋友的家，也可以擦掉这个地址，写上另一个地址，或者这张便签上什么都不写（空指针）。\n引用 就像一个人的“绰号”或“别名”。绰号就是这个人本身，它不是一个独立的东西，一旦起了绰号，它就一直代表这个人，不能再用作别人的绰号。\n\n一、 指针 (Pointer)\n1. 什么是指针？\n指针是一个变量，其值为另一个变量的内存地址。通过这个地址，我们可以间接地读取或修改那个变量的值。\n2. 语法和操作\n\n声明指针: 类型* 指针名; 例如: int* ptr;\n获取地址: 使用取地址符 &amp;。 例如: ptr = &amp;myVar;\n解引用: 使用解引用符 * 来访问指针所指向地址上的值。例如: *ptr = 20;\n\n3. 核心特性\n\n可以为空 (Nullable): 指针可以不指向任何对象，即可以被赋值为 nullptr (或 NULL)。在使用前必须检查其是否为空，否则解引用空指针会导致程序崩溃。\n可以被重新赋值: 一个指针可以在其生命周期内指向不同的对象。\n拥有自己的内存空间: 指针变量本身也占用内存空间（通常是 4 或 8 字节，取决于系统架构），用来存储地址值。\n支持指针算术: 可以对指针进行加减运算，使其指向相邻的内存单元，这在处理数组时非常有用。\n\n4. 代码示例\n#include &lt;iostream&gt;\n \nint main() {\n    int a = 10;\n    int b = 20;\n \n    // 1. 声明一个整型指针\n    int* ptr;\n \n    // 2. 将指针指向变量 a 的地址\n    ptr = &amp;a;\n    std::cout &lt;&lt; &quot;ptr 指向 a...&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a 的地址: &quot; &lt;&lt; &amp;a &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;ptr 存储的地址: &quot; &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;通过 ptr 访问 a 的值: &quot; &lt;&lt; *ptr &lt;&lt; std::endl;\n \n    // 3. 通过指针修改 a 的值\n    *ptr = 15;\n    std::cout &lt;&lt; &quot;通过 ptr 修改后, a 的值: &quot; &lt;&lt; a &lt;&lt; std::endl;\n \n    // 4. 重新赋值，让指针指向变量 b\n    ptr = &amp;b;\n    std::cout &lt;&lt; &quot;\\nptr 重新指向 b...&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;b 的地址: &quot; &lt;&lt; &amp;b &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;ptr 存储的新地址: &quot; &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;通过 ptr 访问 b 的值: &quot; &lt;&lt; *ptr &lt;&lt; std::endl;\n \n    // 5. 空指针\n    ptr = nullptr;\n    std::cout &lt;&lt; &quot;\\nptr 被设置为空指针。&quot; &lt;&lt; std::endl;\n    // if (ptr != nullptr) { *ptr = 30; } // 在使用前必须检查\n \n    return 0;\n}\n二、 引用 (Reference)\n1. 什么是引用？\n引用是一个已存在变量的别名。它不是一个新对象，也没有自己的内存地址。它仅仅是原变量的另一个名字。对引用的任何操作都等同于对原变量的操作。\n2. 语法和操作\n\n声明引用: 类型&amp; 引用名 = 变量名; 例如: int&amp; ref = myVar;\n\n3. 核心特性\n\n必须在声明时初始化: 引用必须在创建时就绑定到一个具体的变量上，不能只声明不初始化。\n不能为空 (Not Nullable): 引用不能像指针一样为空，它必须始终指向一个有效的对象。这使得使用引用比使用指针更安全。\n不能被重新赋值: 引用一旦被初始化，就不能再“引用”到另一个对象。它将终生绑定到最初的那个变量上。对引用赋值，实际上是修改它所引用的原始变量的值。\n不拥有自己的内存空间: 引用与其引用的变量共享同一块内存地址。sizeof(ref) 返回的是原始变量的大小。\n\n4. 代码示例\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 100;\n \n    // 1. 声明一个引用并初始化，它是 x 的别名\n    int&amp; ref = x;\n \n    std::cout &lt;&lt; &quot;x 的值: &quot; &lt;&lt; x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;ref 的值: &quot; &lt;&lt; ref &lt;&lt; std::endl;\n \n    std::cout &lt;&lt; &quot;\\nx 的地址: &quot; &lt;&lt; &amp;x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;ref 的地址: &quot; &lt;&lt; &amp;ref &lt;&lt; std::endl; // 注意：地址与 x 完全相同\n \n    // 2. 通过引用修改值\n    ref = 200;\n    std::cout &lt;&lt; &quot;\\n通过 ref 修改后, x 的值: &quot; &lt;&lt; x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;ref 的值也变为: &quot; &lt;&lt; ref &lt;&lt; std::endl;\n \n    // 3. 尝试将引用“重新赋值”给另一个变量\n    int y = 300;\n    ref = y; // 这不是让 ref 引用 y！\n             // 而是将 y 的值 (300) 赋给 ref 所引用的变量 (x)\n             \n    std::cout &lt;&lt; &quot;\\n执行 ref = y; 之后...&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;x 的值: &quot; &lt;&lt; x &lt;&lt; std::endl;   // x 的值变成了 300\n    std::cout &lt;&lt; &quot;y 的值: &quot; &lt;&lt; y &lt;&lt; std::endl;   // y 的值不变\n    std::cout &lt;&lt; &quot;ref 的值: &quot; &lt;&lt; ref &lt;&lt; std::endl; // ref 仍然是 x 的别名，所以值也是 300\n    std::cout &lt;&lt; &quot;ref 的地址仍然是 x 的地址: &quot; &lt;&lt; &amp;ref &lt;&lt; std::endl;\n \n    return 0;\n}\n三、 核心区别对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性指针 (Pointer)引用 (Reference)初始化可以在任何时候初始化，也可以不初始化。必须在声明时初始化。空值可以是 nullptr，表示不指向任何对象。不能为空，必须引用一个有效的对象。可重赋值性可以在生命周期内指向不同的对象。一旦初始化，不能再引用其他对象。内存地址拥有自己独立的内存地址和空间。与其引用的变量共享同一内存地址。**sizeof** 运算sizeof(ptr) 返回指针本身的大小（如4或8字节）。sizeof(ref) 返回其引用的原始变量的大小。语法使用 * 和 &amp; 进行操作，语法相对复杂。像普通变量一样使用，语法更简洁、自然。\n四、 使用场景\n推荐使用引用的场景：\n\n函数参数传递 (Pass-by-Reference):\n\n\n目的：避免大型对象拷贝带来的性能开销，并允许函数修改调用者传入的变量。\n优点：比指针更安全（无需检查空值）且语法更清晰。\n\n// 使用引用避免了 Person 对象的复制\nvoid printPersonInfo(const Person&amp; person); // const 保证函数不会修改对象\nvoid increaseAge(Person&amp; person); // 非 const 允许函数修改对象\n\n范围 **for** 循环 (Range-based for loop):\n\n\n目的：修改容器中的元素，或避免复制元素。\n\nstd::vector&lt;int&gt; nums = {1, 2, 3};\n// 使用引用&amp;，可以直接修改 vector 中的元素\nfor (int&amp; num : nums) {\n    num *= 2;\n}\n\n函数返回值 (需谨慎):\n\n\n目的：避免返回大型对象的拷贝。\n警告：绝对不能返回对函数内部局部变量的引用，因为函数返回后局部变量被销毁，引用会变成“悬垂引用”，导致未定义行为。\n\n// 错误示例：返回局部变量的引用\nint&amp; badFunction() {\n    int local = 10;\n    return local; // 危险！local 在函数结束后销毁\n}\n推荐使用指针的场景：\n\n表示“可能不存在”的对象:\n\n\n目的：当一个变量可能指向一个对象，也可能什么都不指向时，使用指针并将其设为 nullptr 是最直接的表达方式。\n例子：链表中的 next 节点，树中的子节点，它们可能存在也可能不存在（为 nullptr）。\n\nstruct Node {\n    int data;\n    Node* next; // 可能没有下一个节点，所以用指针\n};\n\n动态内存管理:\n\n\n目的：在堆 (Heap) 上手动创建和销毁对象。new 操作符返回的就是一个指向新分配内存的指针。\n\nint* dynamicArray = new int[100];\n// ... 使用数组 ...\ndelete[] dynamicArray; // 必须手动释放内存\n现代 C++ 建议: 优先使用智能指针 (std::unique_ptr, std::shared_ptr) 来自动管理动态内存，以避免内存泄漏。\n\n与 C 语言库或底层 API 交互:\n\n\n很多 C 语言风格的 API 都是通过指针来操作数据的，与它们交互时必须使用指针。\n\n总结\n“能用引用就用引用，不得已才用指针。”\n这是一个广为流传的 C++ 编程准则。\n\n引用更安全、更易用。当你确定需要一个变量的别名，并且这个别名在初始化后不会改变指向时，引用是首选。\n指针更灵活、更强大，但也更危险。当你需要处理“可能为空”的情况、动态内存分配或需要重新指向不同对象时，就必须使用指针。\n\n掌握它们之间的区别和各自的适用场景，是成为一名优秀 C++ 程序员的关键一步。"},"c++/基础知识/数据类型与变量":{"slug":"c++/基础知识/数据类型与变量","filePath":"c++/基础知识/数据类型与变量.md","title":"数据类型与变量","links":[],"tags":[],"content":"一、数据类型（Data Types）\nC++是一门强类型语言，所有变量在使用前必须声明其数据类型。数据类型决定了变量所占用的内存大小、存储的取值范围以及支持的操作方式。\n1. 基本内置数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型说明大小（通常，平台相关）取值范围（示例）char字符类型，占1字节1字节-128 ～ 127 (signed char) 或 0 ～ 255 (unsigned char)bool布尔类型，取值true或false1字节true/ falseint整数类型，平台相关大小通常4字节-2,147,483,648 ～ 2,147,483,647（32位系统示例）short短整型通常2字节-32,768 ～ 32,767long长整型4或8字节，依平台而定平台相关long long更长整型（C++11起支持）通常8字节-9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807float单精度浮点数4字节大约 ±3.4E±38，约7位有效数字double双精度浮点数8字节大约 ±1.7E±308，约15位有效数字long double扩展精度浮点数8字节或更多，依平台相关更高精度void无类型，常用于函数无返回值无无\n2. 修饰符（Modifiers）\n\nsigned 和 unsigned：修饰整数类型，分别表示带符号和无符号整数。int默认是signed。\nshort 和 long：修饰整数类型，表示占用更少或更多字节。\n\n示例：\nunsigned int u = 100;    // 无符号整数\nsigned short s = -10;    // 有符号短整型\nlong long bigNum = 123456789012345;\n3. 枚举类型（enum）\n枚举用于定义一组命名的整型常量，提升代码可读性与安全性。\n示例：\nenum Color { Red, Green, Blue };\nColor c = Red;\n\n二、变量（Variables）\n变量是程序运行时用于存储数据的命名内存单元。\n1. 变量声明\n变量声明时必须指定数据类型。\n示例：\nint age;\ndouble salary;\nchar grade;\n2. 变量初始化\n推荐声明时立即初始化，避免未定义行为。\n示例：\nint count = 0;\ndouble pi = 3.14159;\nchar letter = &#039;A&#039;;\n3. 变量赋值\n变量声明后可以多次赋值。\ncount = 10;\npi = 3.14;\nletter = &#039;B&#039;;\n4. 变量命名规则\n\n由字母（A-Z，a-z）、数字（0-9）、下划线（_）组成\n不能以数字开头\n避免使用C++关键字（如int、return等）\n区分大小写（value和Value是不同变量）\n建议使用有意义且符合项目规范的命名风格\n\n5. 作用域（Scope）\n变量的作用域决定其可访问的代码范围。\n\n\n局部变量：在函数或代码块内声明，仅在该范围内有效\n\n\n全局变量：在所有函数外部声明，整个程序范围内有效\n\n\n静态变量（static）：\n\n\n局部静态变量：在函数内声明，生命周期贯穿整个程序，但作用域局限于函数内部，函数多次调用共享该变量\n\n\n全局静态变量：限制变量在声明的文件内可见，防止命名冲突\n\n\n示例：\nint globalVar;  // 全局变量\n \nvoid func() {\n    int localVar = 10;         // 局部变量\n    static int staticVar = 0;  // 局部静态变量，保持状态\n    staticVar++;\n}\n6. 存储类型（Storage Class）\n\nauto：默认局部变量存储类型（C++11后不再强调）\nregister：建议将变量存储在CPU寄存器，已被废弃，不建议使用\nstatic：静态存储期，生命周期贯穿程序执行\nextern：声明外部变量，定义在其他文件\nmutable：允许在const对象中修改的成员变量（类中使用）\n\n\n三、特殊数据类型及用法\n1. const变量\n声明常量，值不可修改，增强代码安全性。\nconst int maxSize = 100;\n2. constexpr\n用于声明编译时常量，支持编译器优化和模板元编程。\nconstexpr int square(int x) { return x * x; }\nconstexpr int val = square(5);  // 编译期计算\n3. 引用类型（References）\n引用是已存在变量的别名，使用时与变量等价。\nint a = 10;\nint&amp; ref = a;  // ref是a的引用\nref = 20;      // 修改ref即修改a\n4. 指针类型（Pointers）\n指针存储变量地址，支持间接访问和操作内存。\nint b = 30;\nint* p = &amp;b;    // p指向b的地址\n*p = 40;        // 通过p修改b的值\n\n四、示例代码汇总\n#include &lt;iostream&gt;\n \nint globalCount = 100;  // 全局变量\n \nint main() {\n    const double PI = 3.14159;  // 常量\n    int age = 25;               // 初始化变量\n    int&amp; ageRef = age;          // age的引用\n    \n    std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; std::endl;\n    ageRef = 30;\n    std::cout &lt;&lt; &quot;Updated Age: &quot; &lt;&lt; age &lt;&lt; std::endl;\n    \n    int* ptr = &amp;age;            // 指针\n    *ptr = 35;\n    std::cout &lt;&lt; &quot;Age via pointer: &quot; &lt;&lt; age &lt;&lt; std::endl;\n \n    static int staticVar = 0;   // 静态变量\n    staticVar++;\n    std::cout &lt;&lt; &quot;Static variable: &quot; &lt;&lt; staticVar &lt;&lt; std::endl;\n \n    return 0;\n}\n\n五、总结\n\nC++内置多种基本数据类型，满足不同存储需求与计算精度。\n变量是存储数据的基本单元，声明时必须指定数据类型，推荐立即初始化。\n理解变量的作用域与存储类型，有助于编写高效且安全的代码。\nconst和constexpr关键字提高程序的安全性和性能。\n引用和指针提供强大的内存操作能力，是理解C++核心特性的关键。\n"},"c++/基础知识/正则":{"slug":"c++/基础知识/正则","filePath":"c++/基础知识/正则.md","title":"正则","links":[],"tags":[],"content":"核心组件\nC++ 正则表达式库主要由以下几个核心组件构成：\n\nstd::regex: 用于表示一个编译后的正则表达式的对象。将一个字符串形式的正则模式“编译”成 std::regex 对象，可以显著提高后续匹配操作的效率。\nstd::smatch (或 std::cmatch, std::wsmatch 等): 用于存储匹配结果的容器。\n\n\nsmatch 用于 std::string。\ncmatch 用于 C 风格字符串 (const char*)。\nwsmatch 用于 std::wstring。\n它们都是 std::match_results 的特化版本。smatch 是最常用的。\n\n\nstd::ssub_match: smatch 容器中的元素类型，代表一个单独的捕获组（sub-match）。\n算法函数:\n\n\nstd::regex_match(): 尝试将整个输入序列与正则表达式进行匹配。\nstd::regex_search(): 在输入序列中搜索第一个与正则表达式匹配的子序列。\nstd::regex_replace(): 搜索并替换所有与正则表达式匹配的子序列。\n\n\n迭代器:\n\n\nstd::sregex_iterator: 用于遍历输入字符串中所有不重叠的匹配项。\nstd::sregex_token_iterator: 功能更强大的迭代器，可以用于更复杂的切分和提取任务。\n\n\n基本使用步骤\n通常，使用 C++ 正则表达式遵循以下步骤：\n\n包含头文件 #include &lt;regex&gt;。\n定义一个字符串形式的正则表达式模式。\n创建一个 std::regex 对象来“编译”这个模式。\n准备好要进行匹配的目标字符串。\n选择合适的算法函数（regex_match, regex_search, regex_replace）执行操作。\n如果匹配成功，从 std::smatch 对象中提取结果。\n\n\n1. std::regex_match：完全匹配\nregex_match 用于判断一个字符串是否能被一个正则表达式完整地匹配。如果字符串有多余的字符，它就会返回 false。\n使用场景：验证输入格式，如邮箱、电话号码、日期等。\n示例代码：\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;regex&gt;\n \nvoid check_date_format(const std::string&amp; date_str) {\n    // 匹配 YYYY-MM-DD 格式的日期\n    // R&quot;(...)&quot; 是原始字符串字面量，可以避免大量使用反斜杠 \\\n    // \\d{4} - 匹配4个数字\n    // -     - 匹配字面量 -\n    // \\d{2} - 匹配2个数字\n    std::regex date_pattern(R&quot;(\\d{4}-\\d{2}-\\d{2})&quot;);\n \n    if (std::regex_match(date_str, date_pattern)) {\n        std::cout &lt;&lt; &quot;&#039;&quot; &lt;&lt; date_str &lt;&lt; &quot;&#039; is a valid date format.&quot; &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; &quot;&#039;&quot; &lt;&lt; date_str &lt;&lt; &quot;&#039; is NOT a valid date format.&quot; &lt;&lt; std::endl;\n    }\n}\n \nint main() {\n    check_date_format(&quot;2023-10-27&quot;);      // 成功\n    check_date_format(&quot;2023-10-27 extra&quot;); // 失败，因为有 &quot; extra&quot;\n    check_date_format(&quot;invalid-date&quot;);     // 失败\n    return 0;\n}\n输出：\n&#039;2023-10-27&#039; is a valid date format.\n&#039;2023-10-27 extra&#039; is NOT a valid date format.\n&#039;invalid-date&#039; is NOT a valid date format.\n\n2. std::regex_search：搜索子串\nregex_search 用于在一个字符串中查找第一个符合正则表达式的子串。这比 regex_match 更常用，因为它允许你在大段文本中寻找特定模式。\n使用场景：从一段日志中提取错误信息，从 HTML 中提取链接等。\n示例代码（提取捕获组）：\nsmatch 对象非常重要。如果匹配成功：\n\nmatch[0] 存储整个匹配到的子串。\nmatch[1] 存储第一个捕获组 (...) 的内容。\nmatch[2] 存储第二个捕获组 (...) 的内容，以此类推。\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;regex&gt;\n \nvoid find_name_and_age(const std::string&amp; text) {\n    // 捕获组用圆括号 () 表示\n    // (\\w+)   : 捕获一个或多个单词字符（字母、数字、下划线），作为名字\n    // is      : 匹配 &quot; is &quot;\n    // (\\d+)   : 捕获一个或多个数字，作为年龄\n    std::regex pattern(R&quot;((\\w+) is (\\d+))&quot;);\n    std::smatch match_result; // 用于存储匹配结果\n \n    if (std::regex_search(text, match_result, pattern)) {\n        std::cout &lt;&lt; &quot;Found a match in: &#039;&quot; &lt;&lt; text &lt;&lt; &quot;&#039;&quot; &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;Full match (match[0]): &quot; &lt;&lt; match_result[0].str() &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;Name (group 1, match[1]): &quot; &lt;&lt; match_result[1].str() &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;Age (group 2, match[2]): &quot; &lt;&lt; match_result[2].str() &lt;&lt; std::endl;\n        \n        // match_result.size() 返回捕获组数量 + 1 (包括完整匹配)\n        std::cout &lt;&lt; &quot;Total captured groups + full match: &quot; &lt;&lt; match_result.size() &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; &quot;No match found in: &#039;&quot; &lt;&lt; text &lt;&lt; &quot;&#039;&quot; &lt;&lt; std::endl;\n    }\n}\n \nint main() {\n    find_name_and_age(&quot;My cat Tom is 3 years old.&quot;);\n    std::cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; std::endl;\n    find_name_and_age(&quot;Alice is 25 and Bob is 30.&quot;); // 只会找到第一个\n    return 0;\n}\n输出：\nFound a match in: &#039;My cat Tom is 3 years old.&#039;\nFull match (match[0]): Tom is 3\nName (group 1, match[1]): Tom\nAge (group 2, match[2]): 3\nTotal captured groups + full match: 3\n--------------------\nFound a match in: &#039;Alice is 25 and Bob is 30.&#039;\nFull match (match[0]): Alice is 25\nName (group 1, match[1]): Alice\nAge (group 2, match[2]): 25\nTotal captured groups + full match: 3\n\n3. std::sregex_iterator：遍历所有匹配项\n如果想找到字符串中所有匹配的子串，而不是仅仅第一个，就需要使用迭代器。\n使用场景：提取一段文本中所有的 URL 或邮箱地址。\n示例代码：\n#include &lt;iostream&gt;     // 引入输入输出流库，用于输出匹配的数字结果\n#include &lt;string&gt;       // 引入字符串库，用于处理 std::string 类型\n#include &lt;regex&gt;        // 引入正则表达式库，用于执行模式匹配\n#include &lt;iterator&gt;     // 引入迭代器支持，用于正则匹配结果的迭代\n \n// 函数：find_all_numbers\n// 功能：查找并输出输入文本中所有的整数（以单词边界分隔的数字）\nvoid find_all_numbers(const std::string&amp; text) {\n    // 定义正则表达式：匹配一个或多个数字，且前后为单词边界（防止匹配子串）\n    std::regex num_pattern(R&quot;(\\b\\d+\\b)&quot;);\n \n    // 使用 std::sregex_iterator 创建迭代器，开始于文本开头，结束于文本末尾\n    auto words_begin = std::sregex_iterator(text.begin(), text.end(), num_pattern);\n \n    // 默认构造一个空的迭代器，作为结束标志\n    auto words_end = std::sregex_iterator();\n \n    // 输出原始字符串信息\n    std::cout &lt;&lt; &quot;Found numbers in &#039;&quot; &lt;&lt; text &lt;&lt; &quot;&#039;:&quot; &lt;&lt; std::endl;\n \n    // 遍历所有匹配项\n    for (auto i = words_begin; i != words_end; ++i) {\n        // 获取当前匹配结果，类型为 std::smatch\n        const std::smatch &amp;match = *i;\n \n        // 输出匹配到的字符串（即整数）\n        std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match.str() &lt;&lt; std::endl;\n    }\n}\n \n// 主函数入口\nint main() {\n    // 调用函数，传入待匹配的字符串\n    find_all_numbers(&quot;There are 3 apples, 10 oranges, and 123 bananas.&quot;);\n \n    // 返回 0，表示程序正常结束\n    return 0;\n}\n \n输出：\nFound numbers in &#039;There are 3 apples, 10 oranges, and 123 bananas.&#039;:\n  3\n  10\n  123\n\n4. std::regex_replace：搜索和替换\nregex_replace 是一个非常强大的工具，用于查找并替换文本。\n使用场景：数据清洗、格式转换、屏蔽敏感信息。\n在替换字符串中，可以使用特殊字符来引用捕获组：\n\n$&amp;: 代表整个匹配的子串。\n$1, $2, …: 代表第 N 个捕获组的内容。\n$:`: 代表匹配处之前的所有内容。\n$&#039;: 代表匹配处之后的所有内容。\n$$: 代表一个字面量 $。\n\n示例代码：\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;regex&gt;\n \nvoid reformat_date(const std::string&amp; text) {\n    // 捕获年、月、日\n    std::regex date_pattern(R&quot;((\\d{4})-(\\d{2})-(\\d{2}))&quot;);\n    \n    // 替换格式：将 YYYY-MM-DD 替换为 MM/DD/YYYY\n    // $2 代表第二个捕获组(月), $3 代表第三个(日), $1 代表第一个(年)\n    const std::string replacement_format = &quot;$2/$3/$1&quot;;\n \n    std::string result = std::regex_replace(text, date_pattern, replacement_format);\n \n    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; text &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Replaced: &quot; &lt;&lt; result &lt;&lt; std::endl;\n}\n \nint main() {\n    reformat_date(&quot;Today&#039;s date is 2023-10-27, tomorrow is 2023-10-28.&quot;);\n    return 0;\n}\n输出：\nOriginal: Today&#039;s date is 2023-10-27, tomorrow is 2023-10-28.\nReplaced: Today&#039;s date is 10/27/2023, tomorrow is 10/28/2023.\n\n错误处理和性能\n错误处理\n如果正则表达式的语法有误，std::regex 的构造函数会抛出 std::regex_error 异常。在生产环境中，最好用 try-catch 块包围它。\ntry {\n    std::regex bad_pattern(&quot;([a-z]&quot;); // 括号不匹配，是无效的正则\n} catch (const std::regex_error&amp; e) {\n    std::cerr &lt;&lt; &quot;Regex error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;\n    std::cerr &lt;&lt; &quot;Error code: &quot; &lt;&lt; e.code() &lt;&lt; std::endl;\n}\n性能考量\n构造 std::regex 对象是昂贵的操作，因为它需要解析和编译正则表达式。如果一个正则表达式需要被多次使用（例如在循环中），请务必在循环外创建 std::regex 对象，然后重复使用它。\n// 好的实践\nstd::regex r(R&quot;(\\w+)&quot;);\nfor (const auto&amp; s : my_string_list) {\n    if (std::regex_search(s, r)) {\n        // ...\n    }\n}\n \n// 不好的实践（每次循环都重新构造）\nfor (const auto&amp; s : my_string_list) {\n    if (std::regex_search(s, std::regex(R&quot;(\\w+)&quot;))) { // 非常低效！\n        // ...\n    }\n}\n正则表达式语法选项\nstd::regex 构造函数可以接受第二个参数，用于指定语法风格。最常用的是 std::regex::ECMAScript，它也是默认值。其他还包括 basic, extended, awk, grep 等。ECMAScript (基本就是 JavaScript 的正则语法) 功能强大且通用，建议始终使用它。\n另一个有用的标志是 std::regex::icase，用于不区分大小写的匹配。\n// 不区分大小写匹配 &quot;error&quot;\nstd::regex case_insensitive_pattern(&quot;error&quot;, std::regex::icase);\n \nstd::string text = &quot;An Error occurred, but it&#039;s not a big ERROR.&quot;;\nif (std::regex_search(text, case_insensitive_pattern)) {\n    std::cout &lt;&lt; &quot;Found &#039;error&#039; (case-insensitive).&quot; &lt;&lt; std::endl;\n}\n总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能C++ 组件/函数关键点定义模式std::regex昂贵的操作，应重复使用存储结果std::smatchm[0]是完整匹配, m[1]是第一个捕获组完全匹配std::regex_match整个字符串必须匹配，用于验证搜索子串std::regex_search查找第一个匹配项，用于提取查找全部std::sregex_iterator使用循环遍历所有不重叠的匹配替换std::regex_replace使用 $1, $2 等引用捕获组"},"c++/基础知识/输入输出操作":{"slug":"c++/基础知识/输入输出操作","filePath":"c++/基础知识/输入输出操作.md","title":"输入输出操作","links":[],"tags":[],"content":"C++ 的 I/O 系统是基于一个非常优雅的抽象概念——流 (Stream)。一个流就是一个字节序列，你可以从中读取（输入流）或向其写入（输出流）。这个抽象使得我们能用同样的方式来处理不同的 I/O 设备，例如键盘、屏幕、文件，甚至是内存中的字符串。\n整个 I/O 库的核心在三个头文件中：\n\n&lt;iostream&gt;: 用于标准输入/输出流（键盘、屏幕）。\n&lt;fstream&gt;: 用于文件流。\n&lt;sstream&gt;: 用于字符串流（在内存中进行 I/O）。\n\n\n第一部分：标准输入输出 (&lt;iostream&gt;)\n这是最常用、最基础的 I/O 操作。&lt;iostream&gt; 库定义了四个标准流对象：\n\nstd::cin: 标准输入流 (Standard Input)，通常关联到键盘。\nstd::cout: 标准输出流 (Standard Output)，通常关联到屏幕。\nstd::cerr: 标准错误流 (Standard Error)，通常也关联到屏幕。它是非缓冲的，意味着消息会立即显示，主要用于输出错误信息。\nstd::clog: 标准日志流 (Standard Log)，也关联到屏幕。它是缓冲的，意味着消息会先存放在缓冲区，待缓冲区满或刷新时才显示，用于输出日志信息。\n\n1. 基本操作符：&gt;&gt; 和 &lt;&lt;\n\n&lt;&lt; (插入运算符)：用于将数据“插入”到输出流。可以把它想象成数据流向的方向。\n&gt;&gt; (提取运算符)：用于从输入流中“提取”数据。\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    // ---- 输出操作 ----\n    std::cout &lt;&lt; &quot;Hello, C++!&quot; &lt;&lt; std::endl; // 输出字符串和换行符\n    int age = 25;\n    std::cout &lt;&lt; &quot;My age is: &quot; &lt;&lt; age &lt;&lt; std::endl; // 可以链式调用\n \n    // ---- 输入操作 ----\n    int your_age;\n    std::string name;\n \n    std::cout &lt;&lt; &quot;Please enter your name: &quot;;\n    std::cin &gt;&gt; name; // 读取一个单词（遇到空格、制表符或换行符停止）\n \n    std::cout &lt;&lt; &quot;Please enter your age: &quot;;\n    std::cin &gt;&gt; your_age;\n \n    std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;! You are &quot; &lt;&lt; your_age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;\n \n    return 0;\n}\n注意：std::cin &gt;&gt; name; 只会读取到第一个空白字符（空格、Tab、换行）之前的内容。如果输入 “John Doe”，name 只会得到 “John”。\n2. 读取整行文本：std::getline\n要解决上面 std::cin 读取单词的问题，我们需要使用 std::getline 函数来读取一整行。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::string full_name;\n    std::cout &lt;&lt; &quot;Please enter your full name: &quot;;\n    std::getline(std::cin, full_name); // 读取一整行，直到遇到换行符\n \n    std::cout &lt;&lt; &quot;Welcome, &quot; &lt;&lt; full_name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n常见陷阱：在 std::cin &gt;&gt; var; 和 std::getline() 混合使用时，&gt;&gt; 操作会把换行符 \\n 留在输入缓冲区中。getline 看到这个换行符会立即停止读取，导致得到一个空字符串。解决方法：在 getline 之前清除缓冲区中的换行符。\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt; // 需要这个头文件来用 numeric_limits\n \nint main() {\n    int id;\n    std::string name;\n \n    std::cout &lt;&lt; &quot;Enter ID: &quot;;\n    std::cin &gt;&gt; id;\n \n    // 清除留在缓冲区中的换行符\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#039;\\n&#039;); \n    // 上面这行代码会忽略缓冲区中所有字符，直到找到并丢弃一个换行符\n \n    std::cout &lt;&lt; &quot;Enter full name: &quot;;\n    std::getline(std::cin, name);\n \n    std::cout &lt;&lt; &quot;ID: &quot; &lt;&lt; id &lt;&lt; &quot;, Name: &quot; &lt;&lt; name &lt;&lt; std::endl;\n    return 0;\n}\n\n第二部分：输出格式化 (Manipulators)\n我们可以使用操纵符 (Manipulators) 来控制输出的格式。一些简单的操纵符在 &lt;iostream&gt; 中，而需要参数的操纵符在 &lt;iomanip&gt; 头文件中。\n\nstd::endl: 插入换行符并刷新 (flush) 输出缓冲区。\n&#039;\\n&#039;: 只插入换行符，不刷新缓冲区。在大量输出时性能更好。\nstd::flush: 强制刷新输出缓冲区。\nstd::setw(n): 设置下一个输出项的字段宽度为 n。\nstd::setprecision(n): 设置浮点数的输出精度为 n 位。\nstd::fixed: 使用定点表示法显示浮点数。\nstd::scientific: 使用科学计数法显示浮点数。\nstd::left, std::right: 设置对齐方式（需要 setw）。\nstd::setfill(c): 当宽度大于输出项时，用字符 c 填充。\nstd::hex, std::oct, std::dec: 设置整数的显示基数（十六/八/十进制）。\n\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt; // 必须包含这个头文件\n#include &lt;cmath&gt;\n \nint main() {\n    double pi = M_PI; // 3.14159265...\n \n    std::cout &lt;&lt; &quot;Default PI: &quot; &lt;&lt; pi &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;PI with precision 3: &quot; &lt;&lt; std::setprecision(3) &lt;&lt; pi &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;PI with precision 10: &quot; &lt;&lt; std::setprecision(10) &lt;&lt; pi &lt;&lt; std::endl;\n \n    // fixed 结合 setprecision 控制小数点后的位数\n    std::cout &lt;&lt; &quot;PI with fixed 4 decimal places: &quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(4) &lt;&lt; pi &lt;&lt; std::endl;\n \n    int num = 255;\n    std::cout &lt;&lt; &quot;Number formatting:&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::setw(10) &lt;&lt; &quot;Decimal:&quot; &lt;&lt; std::setw(10) &lt;&lt; std::dec &lt;&lt; num &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::setw(10) &lt;&lt; &quot;Hexadecimal:&quot; &lt;&lt; std::setw(10) &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::setw(10) &lt;&lt; &quot;Octal:&quot; &lt;&lt; std::setw(10) &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl;\n \n    // 演示 setfill 和 left/right 对齐\n    std::cout &lt;&lt; std::dec; // 切换回十进制\n    std::cout &lt;&lt; &quot;Left aligned: &quot; &lt;&lt; std::left &lt;&lt; std::setw(10) &lt;&lt; std::setfill(&#039;*&#039;) &lt;&lt; num &lt;&lt; &quot;END&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Right aligned: &quot; &lt;&lt; std::right &lt;&lt; std::setw(10) &lt;&lt; std::setfill(&#039;-&#039;) &lt;&lt; num &lt;&lt; &quot;END&quot; &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n第三部分：文件输入输出 (&lt;fstream&gt;)\n&lt;fstream&gt; 库提供了三个类来处理文件：\n\nstd::ifstream: 输入文件流 (Input File Stream)，用于从文件读取数据。\nstd::ofstream: 输出文件流 (Output File Stream)，用于向文件写入数据。\nstd::fstream: 文件流，可以同时进行读写操作。\n\n操作文件流和操作 cin/cout 几乎一模一样！\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n \nint main() {\n    // ---- 写入文件 (ofstream) ----\n    std::ofstream outFile(&quot;data.txt&quot;); // 创建并打开文件，如果文件已存在则清空内容\n \n    if (!outFile.is_open()) { // 检查文件是否成功打开\n        std::cerr &lt;&lt; &quot;Error opening file for writing!&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    outFile &lt;&lt; &quot;Hello, File!&quot; &lt;&lt; std::endl;\n    outFile &lt;&lt; 42 &lt;&lt; std::endl;\n    outFile &lt;&lt; 3.14 &lt;&lt; std::endl;\n \n    outFile.close(); // 关闭文件，释放资源\n \n    // ---- 从文件读取 (ifstream) ----\n    std::ifstream inFile(&quot;data.txt&quot;);\n \n    if (!inFile.is_open()) {\n        std::cerr &lt;&lt; &quot;Error opening file for reading!&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    std::string line;\n    int int_val;\n    double double_val;\n \n    // 读取一行\n    std::getline(inFile, line);\n    // 读取一个整数和一个浮点数\n    inFile &gt;&gt; int_val &gt;&gt; double_val;\n \n    inFile.close(); // 关闭文件\n \n    std::cout &lt;&lt; &quot;Read from file:&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Line: &quot; &lt;&lt; line &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Integer: &quot; &lt;&lt; int_val &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Double: &quot; &lt;&lt; double_val &lt;&lt; std::endl;\n \n    // ---- 循环读取整个文件 ----\n    inFile.open(&quot;data.txt&quot;); // 重新打开\n    std::cout &lt;&lt; &quot;\\nReading whole file line by line:&quot; &lt;&lt; std::endl;\n    while (std::getline(inFile, line)) {\n        std::cout &lt;&lt; line &lt;&lt; std::endl;\n    }\n    inFile.close();\n \n    // ---- 追加模式 (append) ----\n    std::ofstream appendFile(&quot;data.txt&quot;, std::ios::app); // 使用追加模式打开\n    appendFile &lt;&lt; &quot;This is an appended line.&quot; &lt;&lt; std::endl;\n    appendFile.close();\n \n    return 0;\n}\n\n第四部分：字符串流 (&lt;sstream&gt;)\n字符串流允许你像操作 cin/cout 一样来操作内存中的 std::string 对象。这在数据格式转换和解析字符串时非常有用。\n\nstd::stringstream: 可读可写的字符串流。\n\n常见用途：\n\n将多种数据类型拼接成一个字符串。\n从一个字符串中解析出多种数据类型。\n\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n \nint main() {\n    // ---- 1. 将数据转换为字符串 ----\n    std::stringstream ss;\n    std::string name = &quot;Alice&quot;;\n    int score = 95;\n    double height = 1.68;\n \n    // 像 cout 一样 &quot;打印&quot; 到 stringstream 中\n    ss &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Score: &quot; &lt;&lt; score &lt;&lt; &quot;, Height: &quot; &lt;&lt; height;\n \n    // 从 stringstream 中获取最终的字符串\n    std::string result = ss.str();\n    std::cout &lt;&lt; &quot;Generated string: &quot; &lt;&lt; result &lt;&lt; std::endl;\n \n    // ---- 2. 从字符串中解析数据 ----\n    ss.clear(); // 清空流的状态\n    ss.str(&quot;Bob 88 1.75&quot;); // 设置新的字符串内容\n \n    std::string parsed_name;\n    int parsed_score;\n    double parsed_height;\n \n    // 像 cin 一样从 stringstream 中读取\n    ss &gt;&gt; parsed_name &gt;&gt; parsed_score &gt;&gt; parsed_height;\n \n    std::cout &lt;&lt; &quot;\\nParsed data:&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; parsed_name &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Score: &quot; &lt;&lt; parsed_score &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Height: &quot; &lt;&lt; parsed_height &lt;&lt; std::endl;\n \n    return 0;\n}\n\n第五部分：错误处理和流状态\n流对象内部维护着状态位，你可以检查这些状态来判断操作是否成功。\n\ngood(): 所有都正常。\nfail(): 发生了可恢复的逻辑错误，如试图读取一个字母到 int 变量。\nbad(): 发生了不可恢复的系统级错误，如读写时设备故障。\neof(): (End-of-File) 到达了流的末尾。\n\n**检查方式：**流对象可以被隐式转换为 bool 类型。如果流处于 good 状态，它就是 true；否则是 false。\n// 常见的读取循环\nwhile (inFile &gt;&gt; data) {\n    // ... process data ...\n}\n// 这个循环会在读取失败（包括到达文件末尾）时自动终止\n// 因为 (inFile &gt;&gt; data) 的结果是 inFile 对象本身，它会被转换为 bool\n \n// 显式检查\nif (!std::cin) { // or if (std::cin.fail())\n    std::cerr &lt;&lt; &quot;Invalid input!&quot; &lt;&lt; std::endl;\n    // 清除错误状态\n    std::cin.clear();\n    // 丢弃缓冲区中的错误输入\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#039;\\n&#039;);\n}\n\n第六部分：性能和现代 C++\n性能优化\n默认情况下，C++ 的流 (cin/cout) 与 C 的标准 I/O (printf/scanf) 是同步的，这会带来一些性能开销。在高性能需求（如算法竞赛）的场景下，可以关闭同步并解绑 cin 和 cout 来提速。\n// 在 main 函数开头加入这两行\nstd::ios_base::sync_with_stdio(false);\nstd::cin.tie(nullptr);\n警告：执行此操作后，不要混用 C++ 的 cout/cin 和 C 的 printf/scanf，否则可能导致输出顺序混乱。\n现代方法：C++20 &lt;format&gt;\nC++20 引入了 &lt;format&gt; 库（受 Python 的 .format() 启发），提供了一种更安全、更高效、更易读的格式化方式。\n#include &lt;iostream&gt;\n#include &lt;format&gt; // C++20\n#include &lt;string&gt;\n \nint main() {\n    std::string name = &quot;David&quot;;\n    int age = 30;\n \n    // 创建一个格式化的字符串\n    std::string message = std::format(&quot;User {} is {} years old.&quot;, name, age);\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n \n    // C++23 甚至引入了 std::print，可以直接打印，无需 cout\n    // std::print(&quot;User {} is {} years old.\\n&quot;, name, age);\n}\n&lt;format&gt; 库是类型安全的，并且性能通常优于 iostream 和 sprintf，是现代 C++ 中推荐的文本格式化方式。"},"c++/基础知识/运算符":{"slug":"c++/基础知识/运算符","filePath":"c++/基础知识/运算符.md","title":"运算符","links":[],"tags":[],"content":"好的，我们来详细讲解 C++ 中的运算符 (Operators)。运算符是 C++ 语言中用于执行计算、比较、逻辑操作等功能的特殊符号。理解运算符是掌握 C++ 编程的基础。\n我们将从以下几个方面进行讲解：\n\n运算符的分类\n各类运算符详解（附代码示例）\n运算符的优先级和结合性\n运算符重载\n总结与最佳实践\n\n\n1. 运算符的分类\n我们可以从两个维度对运算符进行分类：\nA. 按操作数数量分类：\n\n一元运算符 (Unary Operator)：只对一个操作数进行操作。例如 !a (逻辑非), -b (取负), ++c (自增)。\n二元运算符 (Binary Operator)：对两个操作数进行操作。这是最常见的类型，例如 a + b, c &gt; d。\n三元运算符 (Ternary Operator)：对三个操作数进行操作。C++ 中只有一个三元运算符，即条件运算符 ? :。\n\nB. 按功能分类（我们将主要按此分类进行讲解）：\n\n算术运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符\n成员/指针运算符\n其他运算符 (如 sizeof, 条件运算符等)\n\n\n2. 各类运算符详解\na) 算术运算符 (Arithmetic Operators)\n用于执行基本的数学运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述+加法a + b计算两者之和-减法a - b计算两者之差*乘法a * b计算两者之积/除法a / b计算两者之商。注意：整数除法会舍弃小数部分%取模 (取余)a % b计算 a 除以 b 的余数。通常只用于整数。++自增a++ 或 ++a将操作数的值加 1--自减a-- 或 --a将操作数的值减 1\n代码示例：\n#include &lt;iostream&gt;\n \nint main() {\n    int a = 10, b = 4;\n    std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; (a + b) &lt;&lt; std::endl; // 14\n    std::cout &lt;&lt; &quot;a - b = &quot; &lt;&lt; (a - b) &lt;&lt; std::endl; // 6\n    std::cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; (a * b) &lt;&lt; std::endl; // 40\n    std::cout &lt;&lt; &quot;a / b = &quot; &lt;&lt; (a / b) &lt;&lt; std::endl; // 2 (整数除法，2.5 被截断)\n    std::cout &lt;&lt; &quot;a % b = &quot; &lt;&lt; (a % b) &lt;&lt; std::endl; // 2 (10 = 4*2 + 2)\n \n    // ++ 和 -- 的区别 (前缀与后缀)\n    int c = 5;\n    // 后缀 a++: 先使用 c 的值 (5)，再将 c 加 1\n    std::cout &lt;&lt; &quot;c++ is &quot; &lt;&lt; c++ &lt;&lt; std::endl; // 输出 5\n    std::cout &lt;&lt; &quot;Now c is &quot; &lt;&lt; c &lt;&lt; std::endl;   // 输出 6\n \n    int d = 5;\n    // 前缀 ++d: 先将 d 加 1，再使用 d 的新值 (6)\n    std::cout &lt;&lt; &quot;++d is &quot; &lt;&lt; ++d &lt;&lt; std::endl; // 输出 6\n    std::cout &lt;&lt; &quot;Now d is &quot; &lt;&lt; d &lt;&lt; std::endl;   // 输出 6\n}\nb) 关系运算符 (Relational Operators)\n用于比较两个值，结果为布尔值 true 或 false。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述==等于a == b如果 a 和 b 相等，返回 true!=不等于a != b如果 a 和 b 不相等，返回 true&gt;大于a &gt; b&lt;小于a &lt; b&gt;=大于等于a &gt;= b&lt;=小于等于a &lt;= b\n代码示例：\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 5, y = 5, z = 10;\n    std::cout &lt;&lt; std::boolalpha; // 让 cout 输出 &quot;true&quot;/&quot;false&quot; 而不是 1/0\n    std::cout &lt;&lt; &quot;x == y: &quot; &lt;&lt; (x == y) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; &quot;x != z: &quot; &lt;&lt; (x != z) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; &quot;x &lt; z: &quot; &lt;&lt; (x &lt; z) &lt;&lt; std::endl;   // true\n}\n常见错误： 把 == (比较) 写成 = (赋值)。if (x = 5) 是合法的，但它的意思是把 5 赋给 x，然后判断 5 的布尔值（非零为 true），这几乎总是逻辑错误。\nc) 逻辑运算符 (Logical Operators)\n用于组合多个布尔表达式。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述&amp;&amp;逻辑与 (AND)expr1 &amp;&amp; expr2只有当两个表达式都为 true 时，结果才为 true｜｜逻辑或 (OR)expr1 ｜｜ expr2只要任一表达式为 true，结果就为 true!逻辑非 (NOT)!expr如果表达式为 true，结果为 false，反之亦然\n短路求值 (Short-circuit Evaluation):\n\n对于 &amp;&amp;，如果第一个表达式为 false，则不再计算第二个表达式。\n对于 ||，如果第一个表达式为 true，则不再计算第二个表达式。\n这在代码中非常重要，例如 if (ptr != nullptr &amp;&amp; ptr-&gt;value &gt; 10) 可以安全地防止对空指针解引用。\n\n代码示例：\n#include &lt;iostream&gt;\n \nint main() {\n    int age = 25;\n    bool has_license = true;\n    std::cout &lt;&lt; std::boolalpha;\n \n    if (age &gt;= 18 &amp;&amp; has_license) {\n        std::cout &lt;&lt; &quot;Can drive.&quot; &lt;&lt; std::endl; // Can drive.\n    }\n \n    bool is_weekend = true;\n    bool is_holiday = false;\n    if (is_weekend || is_holiday) {\n        std::cout &lt;&lt; &quot;Can rest.&quot; &lt;&lt; std::endl; // Can rest.\n    }\n \n    if (!is_holiday) {\n        std::cout &lt;&lt; &quot;Need to work.&quot; &lt;&lt; std::endl; // Need to work.\n    }\n}\nd) 位运算符 (Bitwise Operators)\n直接对整数的二进制位进行操作。常用于低级编程、设备驱动和性能优化。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述&amp;按位与 (AND)a &amp; b对应位都为 1 时，结果位才为 1｜按位或 (OR)a ｜ b对应位只要有一个为 1，结果位为 1^按位异或 (XOR)a ^ b对应位不同时，结果位为 1~按位取反 (NOT)~a翻转所有位 (0变1，1变0)&lt;&lt;左移a &lt;&lt; n将 a 的所有位向左移动 n 位，右边补 0。相当于 a * 2^n&gt;&gt;右移a &gt;&gt; n将 a 的所有位向右移动 n 位。对于无符号数，左边补 0；对于有符号数，行为可能取决于实现（通常是补符号位）。相当于 a / 2^n\n代码示例：\n#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n \nint main() {\n    unsigned char a = 5;  // 00000101\n    unsigned char b = 12; // 00001100\n \n    std::cout &lt;&lt; &quot;a &amp; b = &quot; &lt;&lt; (a &amp; b) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(a &amp; b) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 4 (00000100)\n    std::cout &lt;&lt; &quot;a | b = &quot; &lt;&lt; (a | b) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(a | b) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 13 (00001101)\n    std::cout &lt;&lt; &quot;a ^ b = &quot; &lt;&lt; (a ^ b) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(a ^ b) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 9 (00001001)\n    std::cout &lt;&lt; &quot;~a = &quot; &lt;&lt; int(~a) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(~a) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 250 (11111010)\n    std::cout &lt;&lt; &quot;a &lt;&lt; 2 = &quot; &lt;&lt; (a &lt;&lt; 2) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(a &lt;&lt; 2) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 20 (00010100)\n    std::cout &lt;&lt; &quot;b &gt;&gt; 1 = &quot; &lt;&lt; (b &gt;&gt; 1) &lt;&lt; &quot; (&quot; &lt;&lt; std::bitset&lt;8&gt;(b &gt;&gt; 1) &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; // 6 (00000110)\n}\ne) 赋值运算符 (Assignment Operators)\n用于给变量赋值。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符示例等价于=a = ba = b+=a += ba = a + b-=a -= ba = a - b*=a *= ba = a * b/=a /= ba = a / b%=a %= ba = a % b&amp;=a &amp;= ba = a &amp; b｜=a ｜= ba = a ｜ b^=a ^= ba = a ^ b&lt;&lt;=a &lt;&lt;= ba = a &lt;&lt; b&gt;&gt;=a &gt;&gt;= ba = a &gt;&gt; b\n代码示例：\nint x = 10;\nx += 5; // x 现在是 15\nx *= 2; // x 现在是 30\n复合赋值运算符 op= 不仅是简写，有时也更高效。\nf) 成员/指针运算符 (Member/Pointer Operators)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述.成员访问obj.member访问对象或结构体的成员-&gt;指针成员访问ptr-&gt;member通过指向对象的指针访问其成员。等价于 (*ptr).member&amp;取地址&amp;var获取变量的内存地址，返回一个指针*解引用*ptr获取指针所指向地址处的值\ng) 其他运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例描述sizeof尺寸sizeof(type) 或 sizeof(expr)在编译时计算类型或表达式结果所占的字节数?:条件 (三元)cond ? expr1 : expr2如果 cond 为 true，表达式的值为 expr1；否则为 expr2,逗号expr1, expr2先计算 expr1，然后丢弃其结果，再计算 expr2，整个表达式的值是 expr2 的值。不常用，主要用在 for 循环中。(type)类型转换 (C-style)(int)3.14将一个表达式强制转换为另一种类型。C++ 推荐使用 static_cast, dynamic_cast 等::范围解析std::cout用于指定命名空间或类的范围&lt;=&gt;三路比较 (C++20)a &lt;=&gt; b”宇宙飞船运算符”，同时进行 a&lt;b, a==b, a&gt;b 的比较，返回一个对象表示小于、等于或大于零。\n\n3. 运算符的优先级和结合性\n当一个表达式中有多个运算符时，由优先级 (Precedence) 和 结合性 (Associativity) 决定计算顺序。\n\n\n优先级：哪个运算符先执行。例如，* 和 / 的优先级高于 + 和 -。所以 a + b * c 等价于 a + (b * c)。\n\n\n结合性：当多个优先级相同的运算符在一起时，决定计算方向。\n\n\n左结合 (Left-to-Right)：大多数运算符是左结合。例如 a - b - c 等价于 (a - b) - c。\n\n\n右结合 (Right-to-Left)：赋值运算符、一元运算符和三元运算符是右结合。例如 a = b = c 等价于 a = (b = c)。\n\n\n简化的优先级表 (从高到低):\n\n() [] . -&gt; ::\n++ -- ! ~ * &amp; sizeof (一元运算符)\n* / % (乘除模)\n+ - (加减)\n&lt;&lt; &gt;&gt; (位移)\n&lt; &lt;= &gt; &gt;= (关系)\n== != (相等)\n&amp; (按位与)\n^ (按位异或)\n| (按位或)\n&amp;&amp; (逻辑与)\n|| (逻辑或)\n?: (条件)\n= += -= 等赋值运算符 (右结合)\n, (逗号)\n\n最佳实践： 不要去死记硬背完整的优先级表！如果一个表达式的求值顺序不明显，请使用括号 () 来明确指定顺序。这能极大地提高代码的可读性并避免错误。\n\n4. 运算符重载 (Operator Overloading)\nC++ 允许我们为自定义的类型（类或结构体）重新定义大多数运算符的行为。这使得我们可以写出更直观、更像数学表达的代码。\n例如，你可以定义一个 Vector2D 类，并重载 + 运算符来实现两个向量的相加。\n#include &lt;iostream&gt;\n \nstruct Vector2D {\n    double x, y;\n \n    // 重载 + 运算符\n    Vector2D operator+(const Vector2D&amp; other) const {\n        return {x + other.x, y + other.y};\n    }\n};\n \n// 重载 &lt;&lt; 运算符，使其可以打印 Vector2D 对象\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector2D&amp; vec) {\n    os &lt;&lt; &quot;(&quot; &lt;&lt; vec.x &lt;&lt; &quot;, &quot; &lt;&lt; vec.y &lt;&lt; &quot;)&quot;;\n    return os;\n}\n \nint main() {\n    Vector2D v1 = {1.0, 2.0};\n    Vector2D v2 = {3.0, 4.0};\n    Vector2D sum = v1 + v2; // 直观地调用了重载的 operator+\n \n    std::cout &lt;&lt; &quot;v1: &quot; &lt;&lt; v1 &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;v2: &quot; &lt;&lt; v2 &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // 输出: Sum: (4, 6)\n}\n\n5. 总结与最佳实践\n\n明确意图：使用括号 () 避免任何关于优先级和结合性的混淆。\n注意副作用：++ 和 -- 会修改变量的值，在同一个表达式中对一个变量多次使用它们可能会导致未定义行为（例如 i = i++）。\n区分运算符：清楚地区分 &amp; (按位与) 和 &amp;&amp; (逻辑与)，| 和 ||，= 和 ==。\n短路求值：善用 &amp;&amp; 和 || 的短路特性来编写更安全、高效的代码。\n运算符重载：谨慎使用，只在行为符合直觉时重载运算符（例如用 + 做加法，而不是减法），以保持代码的可读性。\n"},"c++/基础知识/运算符与表达式":{"slug":"c++/基础知识/运算符与表达式","filePath":"c++/基础知识/运算符与表达式.md","title":"运算符与表达式","links":[],"tags":[],"content":"本文将分为以下几个部分：\n\n基础概念：什么是运算符、操作数和表达式。\n运算符分类详解：按功能对 C++ 所有主要运算符进行分类讲解。\n运算符的关键属性：优先级（Precedence）和结合性（Associativity）。\n表达式：表达式的求值、类型和值类别（左值/右值）。\n综合示例与最佳实践。\n\n\n1. 基础概念\n\n运算符 (Operator)\n是一个符号，它告诉编译器执行特定的数学或逻辑操作。例如，+ 是一个加法运算符。\n**操作数 (Operand)**是运算符操作的数据。在表达式 5 + 3 中，5 和 3 就是操作数。\n表达式 (Expression)是由运算符、操作数、字面量（如 5、&#039;a&#039;）和变量组成的序列，它可以被求值（calculate）从而产生一个结果。这个结果具有值（value）和类型（type）。例如 x = a + b * 2; 整行是一个语句，而 a + b * 2 就是一个表达式。\n\n\n2. 运算符分类详解\n我们可以根据运算符需要几个操作数来分为：\n\n一元运算符 (Unary)：只有一个操作数 (例如: -a, ++i)\n二元运算符 (Binary)：有两个操作数 (例如: a + b)\n三元运算符 (Ternary)：有三个操作数 (C++ 只有一个: ? :)\n\n更常见的分类方式是按其功能划分：\nA. 算术运算符 (Arithmetic Operators)\n用于执行基本的数学运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例说明+加法a + b-减法a - b*乘法a * b/除法a / b注意： 整数除法会舍弃小数部分，例如 7 / 2 的结果是 3。%取模a % b计算整数除法的余数，例如 7 % 2 的结果是 1。操作数必须是整数类型。\nint a = 10, b = 3;\ncout &lt;&lt; a / b; // 输出 3\ncout &lt;&lt; a % b; // 输出 1\n\ndouble x = 10.0, y = 3.0;\ncout &lt;&lt; x / y; // 输出 3.33333\n\nB. 关系运算符 (Relational Operators)\n用于比较两个值，其结果是一个布尔值 (true 或 false)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例==等于a == b!=不等于a != b&gt;大于a &gt; b&lt;小于a &lt; b&gt;=大于等于a &gt;= b&lt;=小于等于a &lt;= b\nint a = 5, b = 5, c = 10;\ncout &lt;&lt; (a == b); // 输出 1 (true)\ncout &lt;&lt; (a != c); // 输出 1 (true)\ncout &lt;&lt; (a &gt; c);  // 输出 0 (false)\n\nC. 逻辑运算符 (Logical Operators)\n用于组合多个关系表达式，其结果也是布尔值 (true 或 false)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例说明&amp;&amp;逻辑与 (AND)expr1 &amp;&amp; expr2两个表达式都为 true 时，结果才为 true。``逻辑或 (OR)!逻辑非 (NOT)!expr如果表达式为 true，结果为 false，反之亦然。\n短路求值 (Short-circuit Evaluation) 是逻辑运算符的一个重要特性：\n\n对于 &amp;&amp;，如果左边的表达式为 false，则右边的表达式不会被执行，因为整个结果已确定为 false。\n对于 ||，如果左边的表达式为 true，则右边的表达式不会被执行，因为整个结果已确定为 true。\n\nint age = 25;\nint score = 95;\nif (age &gt; 18 &amp;&amp; score &gt; 90) { /* ... */ } // 两个条件都满足\n\nint x = 0;\nbool result = (x != 0 &amp;&amp; 10 / x &gt; 1); // 安全！因为 x!=0 为 false，后面的 10/x 不会执行，避免了除零错误。\n\nD. 位运算符 (Bitwise Operators)\n直接对整数的二进制位进行操作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例&amp;按位与a &amp; b``按位或^按位异或a ^ b~按位取反~a&lt;&lt;左移a &lt;&lt; n&gt;&gt;右移a &gt;&gt; n\nunsigned char a = 5;  // 二进制: 00000101\nunsigned char b = 9;  // 二进制: 00001001\n\ncout &lt;&lt; (a &amp; b); // 结果 1 (00000001)\ncout &lt;&lt; (a | b); // 结果 13 (00001101)\ncout &lt;&lt; (a &lt;&lt; 1); // 结果 10 (00001010)，相当于 a * 2\ncout &lt;&lt; (b &gt;&gt; 1); // 结果 4 (00000100)，相当于 b / 2\n\nE. 赋值运算符 (Assignment Operators)\n用于给变量赋值。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符示例等价于=a = b+=a += ba = a + b-=a -= ba = a - b*=a *= ba = a * b/=a /= ba = a / b%=a %= ba = a % b&amp;=, `=, ^=`a &amp;= b&lt;&lt;=, &gt;&gt;=a &lt;&lt;= na = a &lt;&lt; n\n赋值表达式本身也有值，其值就是被赋的值。这允许链式赋值：\nint x, y; x = y = 10; 等价于 y = 10; x = y;\nF. 递增/递减运算符 (Increment/Decrement Operators)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例说明++递增++i (前置) i++ (后置)将变量的值加 1--递减--i (前置) i-- (后置)将变量的值减 1\n前置 (Pre-increment) vs 后置 (Post-increment) 是一个关键区别：\n\n前置 ++i：先将 i 的值加 1，然后返回加 1 后的 i 的值。\n后置 i++：先返回 i 的原始值，然后再将 i 的值加 1。\n\nint a = 5;\nint b = ++a; // a 先变成 6, 然后 b 被赋值为 6。此时 a=6, b=6\ncout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; endl;\n\nint c = 5;\nint d = c++; // d 先被赋值为 5, 然后 c 再变成 6。此时 c=6, d=5\ncout &lt;&lt; &quot;c=&quot; &lt;&lt; c &lt;&lt; &quot;, d=&quot; &lt;&lt; d &lt;&lt; endl;\n\n性能提示：对于自定义类型（如迭代器），前置版本通常比后置版本效率更高，因为后置版本需要创建一个临时对象来保存原始值。因此，在不影响逻辑的情况下，优先使用前置版本 (++it 而不是 it++)。\nG. 其他运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符名称示例说明sizeof尺寸运算符sizeof(int)在编译时计算类型或变量所占的字节数。?:条件运算符(三元)cond ? expr1 : expr2如果 cond 为 true，则表达式的值为 expr1；否则为 expr2。,逗号运算符a=1, b=2, c=3从左到右依次计算每个表达式，整个逗号表达式的值是最右边表达式的值。. -&gt;成员访问obj.member ptr-&gt;member用于访问类或结构的成员。&amp; *指针相关&amp;var (取地址) *ptr (解引用)&amp; 获取变量的内存地址，* 获取指针指向地址的值。static_cast等类型转换static_cast&lt;int&gt;(3.14)C++ 风格的类型转换。\n\n3. 运算符的关键属性\n当一个表达式中包含多个运算符时，由谁先计算？这就需要优先级和结合性来决定。\nA. 优先级 (Precedence)\n优先级决定了不同运算符的计算顺序。优先级高的运算符先于优先级低的运算符被计算。例如，* 和 / 的优先级高于 + 和 -。\nint result = 5 + 3 * 2;\n这里，3 * 2 会先被计算（结果是 6），然后才执行 5 + 6，所以 result 是 11，而不是 16。\nB. 结合性 (Associativity)\n当多个具有相同优先级的运算符出现在一个表达式中时，结合性决定了它们的计算顺序。\n\n左结合性 (Left-to-right)：从左向右计算。大多数运算符都是左结合的。\nint result = 10 - 5 + 3;\n+ 和 - 优先级相同，且是左结合性，所以等价于 (10 - 5) + 3，结果是 8。\n右结合性 (Right-to-right)：从右向左计算。赋值运算符、一元运算符和三元条件运算符是右结合的。\nint a, b, c; a = b = c = 10;赋值运算符是右结合性，所以等价于 a = (b = (c = 10))。首先 c被赋值为10，然后b被赋值为c=10这个表达式的结果（也就是10），最后a被赋值为b=...表达式的结果（也是10）。\n\nC++ 运算符优先级和结合性简表 (从高到低)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n优先级运算符描述结合性1 (最高):: () [] . -&gt; ++ -- (后置)作用域、函数调用、数组下标、成员访问左到右2++ -- (前置) ! ~ - + (一元) &amp; * sizeof new delete一元运算符右到左3.* -&gt;*成员指针访问左到右4* / %乘法、除法、取模左到右5+ -加法、减法左到右6&lt;&lt; &gt;&gt;位移左到右7&lt; &lt;= &gt; &gt;=关系左到右8== !=等于、不等于左到右9&amp;按位与左到右10^按位异或左到右11``按位或12&amp;&amp;逻辑与左到右13``14?:条件(三元)右到左15= += -= *= /= %= …赋值右到左16 (最低),逗号左到右\n最佳实践：不要去死记硬背这个复杂的表格！当你不确定优先级时，使用括号 () 来明确指定计算顺序。这不仅能保证正确性，还能大大提高代码的可读性。\n例如，写 (a + b) * c 而不是依赖 * 的高优先级。\n\n4. 表达式 (Expressions)\nA. 表达式的求值顺序和副作用\n\n副作用 (Side Effect)：指表达式在求值过程中，除了返回一个值之外，还修改了某些状态（如修改变量的值、进行I/O操作）。例如，i++ 的副作用就是使 i 的值增加。\n求值顺序 (Order of Evaluation)：C++ 标准并未规定大多数二元运算符（如 +, *）的操作数的求值顺序。\ncout &lt;&lt; f1() + f2();我们无法确定是 f1() 先被调用还是 f2() 先被调用。\n\n这会导致一个非常危险的问题：未定义行为 (Undefined Behavior, UB)。\n如果你在一个表达式中多次修改同一个变量，且没有明确的顺序规定，就会产生 UB。\n错误的例子 (UB!)：\nint i = 5;\ni = ++i; // UB! i被读取和修改，顺序不确定\ncout &lt;&lt; i &lt;&lt; i++; // UB! 对 i 的使用和修改顺序不确定\n有顺序保证的运算符：\n逻辑与(&amp;&amp;)、逻辑或(||)、逗号(,)和条件(?:)运算符，它们的操作数求值顺序是确定的（从左到右）。\nB. 表达式的值类别 (Value Categories)\n在现代 C++ 中，表达式的值可以分为几类，最重要的是左值 (lvalue) 和右值 (rvalue)。\n\n\n左值 (lvalue)：指代一个内存位置，可以被取地址（用 &amp;），并且通常可以被赋值。你可以把它想象成一个有名字、有固定地址的“容器”。\n\n\n变量名 (int x; x 是左值)\n\n\n解引用的指针 (*p)\n\n\n数组元素 (arr[0])\n\n\n右值 (rvalue)：通常指一个临时的、即将销毁的值，不能被取地址。你可以把它想象成一个“即用即弃”的临时数据。\n\n\n字面量 (10, true)\n\n\n算术表达式的结果 (a + b)\n\n\n函数返回的非引用临时值\n\n\n简单的判断方法：能对它取地址 (&amp;) 的，基本上就是左值。\nint x = 10;\nint* p = &amp;x;     // 正确, x 是左值\nint* q = &amp;(x+1); // 错误! x+1 的结果是一个临时值(右值)，没有固定地址\n\n这个概念对于理解 C++11 引入的移动语义 (Move Semantics) 和右值引用 (Rvalue Reference, &amp;&amp;) 至关重要。\n\n5. 综合示例与最佳实践\n综合示例\n分析下面这个复杂的表达式：\nint a = 5, b = 10, c = 2;\nbool result = a * b / c &gt; 8 &amp;&amp; b - a == 5;\n\n\n优先级分析: * / &gt; + - &gt; &gt; == &gt; &amp;&amp;\n求值步骤:\na. a * b (5 * 10 = 50)\nb. (结果a) / c (50 / 2 = 25)\nc. (结果b) &gt; 8 (25 &gt; 8 = true)\nd. b - a (10 - 5 = 5)\ne. (结果d) == 5 (5 == 5 = true)\nf. (结果c) &amp;&amp; (结果e) (true &amp;&amp; true = true)\nresult 的最终值为 true。\n\n最佳实践总结\n\n括号是你的好朋友：在不确定优先级或为了代码清晰时，毫不犹豫地使用括号。\n避免未定义行为：不要在单个表达式中对同一个变量进行多次无序的修改。\n理解短路求值：利用 &amp;&amp; 和 || 的短路特性来编写更安全、更高效的代码。\n优先使用前置递增/递减：对于非内置类型，++it 通常优于 it++。\n区分位运算符和逻辑运算符：&amp; vs &amp;&amp;，| vs || 是初学者常犯的错误，它们的功能完全不同。\n了解整数除法：记住 int / int 的结果仍然是 int，小数部分被截断。\n\n希望这份详细的讲解能帮助你彻底掌握 C++ 的运算符与表达式！"},"c++/概览":{"slug":"c++/概览","filePath":"c++/概览.md","title":"概览","links":[],"tags":[],"content":"C++ 系统学习目录\n一、基础入门\n1. C++概述与环境搭建\n\nC++的历史与特点\n编译器安装（GCC、Clang、MSVC）\nIDE选择与配置\n第一个C++程序\n编译与链接过程\n\n2. 基本语法\n\n变量与数据类型\n运算符与表达式\n输入输出流（cin、cout）\n命名空间（namespace）\n类型转换（隐式与显式）\n\n3. 控制结构\n\n条件语句（if、switch）\n循环语句（for、while、do-while）\n跳转语句（break、continue、goto）\n范围for循环（C++11）\n\n4. 函数\n\n函数定义与声明\n参数传递（值传递、引用传递、指针传递）\n函数重载\n内联函数\n默认参数\n函数指针\n\n二、核心特性\n5. 数组与字符串\n\n一维与多维数组\n字符数组与C风格字符串\nstring类的使用\n字符串操作函数\n\n6. 指针与引用\n\n指针的概念与操作\n指针与数组的关系\n动态内存分配（new、delete）\n引用的概念与使用\n指针与引用的区别\n智能指针基础\n\n7. 结构体与联合体\n\n结构体定义与使用\n结构体数组与指针\n联合体（union）\n枚举类型（enum）\n\n三、面向对象编程\n8. 类与对象\n\n类的定义与实现\n成员变量与成员函数\n访问控制（public、private、protected）\n构造函数与析构函数\nthis指针\n静态成员\n\n9. 继承\n\n继承的概念与语法\n继承方式（public、private、protected）\n构造函数与析构函数的调用顺序\n多重继承\n虚继承\n基类与派生类的转换\n\n10. 多态\n\n虚函数与动态绑定\n纯虚函数与抽象类\n虚析构函数\n运行时类型识别（RTTI）\ndynamic_cast\n\n11. 运算符重载\n\n运算符重载的规则\n成员函数与友元函数重载\n特殊运算符重载（=、[]、()、→）\n类型转换运算符\n\n四、高级特性\n12. 模板\n\n函数模板\n类模板\n模板特化\n模板参数推导\n可变参数模板（C++11）\n模板元编程基础\n\n13. 异常处理\n\ntry、catch、throw\n异常类层次\n异常规范\nnoexcept（C++11）\n异常安全性\n\n14. 标准模板库（STL）\n\n容器（vector、list、deque、set、map等）\n迭代器\n算法库\n函数对象与lambda表达式\n适配器\n\n15. 输入输出流\n\n流类层次结构\n文件操作\n格式化输入输出\n字符串流\n自定义流操作符\n\n五、现代C++特性\n16. C++11/14/17/20新特性\n\nauto与decltype\n范围for循环\n初始化列表\n右值引用与移动语义\n完美转发\nconstexpr\nnullptr\n强类型枚举\n结构化绑定（C++17）\nconcepts（C++20）\n\n17. 智能指针与内存管理\n\nunique_ptr\nshared_ptr\nweak_ptr\n自定义删除器\nenable_shared_from_this\n\n18. 并发编程\n\nthread类\nmutex与锁\n条件变量\nfuture与promise\nasync\n原子操作\n\n六、实践与进阶\n19. 设计模式\n\n创建型模式（单例、工厂等）\n结构型模式（适配器、装饰器等）\n行为型模式（观察者、策略等）\n\n20. 性能优化\n\n编译器优化选项\n内存对齐\n缓存友好的代码\n避免不必要的拷贝\n内联优化\n\n21. 调试与测试\n\n调试技巧\n断言的使用\n单元测试框架\n内存泄漏检测\n性能分析工具\n\n22. 项目实践\n\n代码组织与模块化\nMakefile与CMake\n版本控制\n代码规范\n文档编写\n\n七、专题深入\n23. 元编程\n\n模板元编程技术\nSFINAE\ntype traits\nconstexpr if（C++17）\n\n24. 网络编程\n\nsocket编程基础\nTCP/IP编程\n异步IO\n网络库使用\n\n25. 系统编程\n\n进程与线程\n信号处理\n共享内存\n管道与消息队列\n\n这个目录涵盖了从C++基础到高级特性的完整学习路径。建议按照顺序学习，但可以根据个人需求和基础调整学习重点。每个主题都需要大量的练习和实践才能真正掌握。"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"mdbox - 多领域知识库笔记\n介绍\n欢迎来到 mdbox 知识库！本仓库用于整理和归档多个技术方向的学习笔记，涵盖编程语言、网络安全、CTF、数据库等主题。所有内容都以 Markdown 形式编写，并适配 Obsidian 使用。\n当然也可以在线使用： 在线网址\n主要分类\n\n编程语言: Python、Java、C/C++、汇编\n网络安全: Web 安全、KALI、CTF 题解\n脚本语言: PowerShell、VBScript、JavaScript\n数据库: MySQL、SQLite\n\n协作指导\n如何参与\n\n\nFork 仓库:\n\n点击右上角的 Fork 按钮，创建仓库的副本到你自己的 GitHub 账户中。\n在你的 GitHub 账户中，你将拥有该仓库的完整控制权限，可以自由修改。\n\n\n\n克隆仓库到本地:\n\n通过 Git 将仓库克隆到你本地的计算机，以便进行更改：\ngit clone github.com/ZEROLINGG/mdbox.git\n\n\n\n\n创建新分支:\n\n在进行修改之前，你可以选择创建一个新的分支以避免直接修改主分支。分支名称应简洁且有描述性。\ngit checkout -b one\n\none 替换为你要进行的修改或新增功能的名称。\n\n\n\n编辑文档:\n\n使用你熟悉的编辑器（如 Obsidian 或 Visual Studio Code）打开 .md 文件进行修改。可以在各个分类下添加新的内容、更新现有文档或修正拼写错误。\n确保所有新内容都符合现有的文档结构和格式。\n\n\n\n提交更改:\n\n在本地提交你的更改时，确保提交信息简洁明了，并准确描述修改内容。遵循 Commit Message Convention 规范：\ngit add .\ngit commit -m &quot;添加了新的知识&quot;\n\n\n\n\n推送更改:\n\n将修改推送到 GitHub 仓库中：\ngit push -u origin main\n\n推送后，你可以在 GitHub 仓库中看到你的修改已上传。\n\n\n\n提交 Pull Request:\n\n在 GitHub 上打开你的仓库，点击 Pull Requests，然后点击 New Pull Request。\n选择你刚才创建的分支（如果创建了）和主仓库的 main 分支进行对比。\n在提交 Pull Request 时，确保说明清楚你所做的更改和修改的目的。例如：\n添加 Python 基础知识部分，并更新了部分格式。\n修正了 C++ 部分的拼写错误。\n\n\n\n\n\n审查与合并:\n\n项目维护者定期审查 Pull Request。在合并之前，确保所有修改通过了检查并且没有引入任何不一致的格式或错误。\n如果有任何问题或需要改进的地方，会要求修改并重新提交。\n\n\n\n协作规则与最佳实践\n\n\n命名规范:\n\n在创建分支时，请使用简短且有描述性的名称，说明所做的修改内容。例如，add-python-functions，fix-markdown-syntax。\n\n\n\n文档格式与一致性:\n\n请严格遵循 Markdown 格式，保持文档的简洁性和清晰性。你可以参考已有文档的格式。\n对于代码片段，可以使用 ``` 代码块 语法，确保代码可读性：\ndef hello_world():\n    print(&quot;Hello, world!&quot;)\n\n\n\n\n详细的提交信息:\n\n提交信息应简洁且描述明确。避免使用含糊不清的提交信息（如 fix bug，update files），应具体说明修改的内容（如 修复 Python 示例代码中的错误，更新 MySQL 连接配置部分）。\n\n\n\nPull Request 审查:\n\n提交 Pull Request 后，等待项目维护者审查并合并。如果有反馈，及时进行修改并更新 PR。\n记得在提交 PR 后留意评论和审查建议，及时回复和调整。\n\n\n\n避免直接在 main 分支上进行修改:\n\n所有更改都应通过新建分支并提交 Pull Request 的方式进行，这样可以确保仓库的稳定性。\n\n\n\n问题反馈与讨论\n\n\n报告问题:\n\n如果你在使用过程中发现问题，或在修改过程中遇到障碍，可以使用 Issues 功能报告问题。\n在仓库的 Issues 页面，点击 New Issue，并提供详细的问题描述，附带错误日志、截图或复现步骤。\n\n\n\n讨论与提问:\n\n如果你有任何疑问或想要与其他人讨论某个问题，可以在仓库的 Discussions 中发起讨论。\n在 Discussions 页面，选择 New Discussion，并选择讨论类型（如问题、提案等）。\n\n\n\n标签使用:\n\n为 Issues 和 Pull Requests 添加适当的标签，例如 bug、enhancement、question 等，以便分类管理。\n\n\n\n其他资源\n\nObsidian: 本仓库中的笔记适合使用 Obsidian 打开，以便获得最佳的浏览体验和图谱功能。\nMarkdown 语法: 如果你不熟悉 Markdown 格式，可以参考 Markdown 官方文档 和Markdown 菜鸟教程进行学习。\n\n贡献者\n感谢每一位参与者，你的贡献对本项目至关重要！通过大家的共同努力，我们的知识库将不断完善，并帮助更多学习者。\n\n\n注意: 请在进行任何修改之前，先确保自己理解当前文档的内容，并尽量避免对已有内容做不必要的更改。如果有疑问或不确定的地方，请随时在 Issues 或 Discussions 中提问。\n"},"python/1.基本/1.1.基础语法/1.1.1.数据类型":{"slug":"python/1.基本/1.1.基础语法/1.1.1.数据类型","filePath":"python/1.基本/1.1.基础语法/1.1.1.数据类型.md","title":"1.1.1.数据类型","links":[],"tags":[],"content":"Python 是一种强类型、动态类型语言，内置了多种常用数据类型，用于表达不同类别的数据。在开发过程中，合理使用这些数据类型是编写高质量代码的基础。\n\n1. 数值类型（Numeric Types）\nPython 提供三种主要的数值类型：\n(1) 整数（int）\n用于表示没有小数部分的整数值：\na = 10      # 正整数\nb = -5      # 负整数\nc = 0       # 零\n特点：\n\n\nPython 的整数类型没有范围限制（在内存允许的范围内可表示任意大的整数）。\n\n\n支持常用运算符：\n\n\n加：+\n\n\n减：-\n\n\n乘：*\n\n\n除（返回浮点数）：/\n\n\n整除（向下取整）：//\n\n\n取模：%\n\n\n幂运算：**\n\n\n(2) 浮点数（float）\n用于表示带小数部分的数值，符合 IEEE 754 双精度标准。\nx = 3.14\ny = -2.71\nz = 1.0\n特点：\n\n精度有限，可能存在舍入误差：\n\nprint(0.1 + 0.2)  # 输出可能为 0.30000000000000004\n\n可使用 round(x, n) 控制显示精度：\n\nprint(round(0.1 + 0.2, 2))  # 输出 0.3\n(3) 复数（complex）\nPython 原生支持复数类型，用 j 表示虚部。\nc1 = 2 + 3j\nc2 = 1 - 4j\n属性访问：\nprint(c1.real)  # 实部：2.0\nprint(c1.imag)  # 虚部：3.0\n特点：\n\n常用于科学计算、信号处理等领域。\n支持复数加减乘除、共轭等操作。\n\n\n2. 布尔类型（bool）\n布尔类型仅有两个值：True 和 False，用于逻辑判断。\nt = True\nf = False\n特点：\n\nTrue 等价于 1，False 等价于 0，可参与算术运算：\n\nprint(True + 1)   # 输出 2\nprint(False * 10) # 输出 0\n\n常用于条件语句、循环控制等逻辑结构中：\n\nif True:\n    print(&quot;执行该语句块&quot;)\n\n3. 字符串类型（str）\n用于表示文本信息。\ns1 = &#039;hello&#039;\ns2 = &quot;world&quot;\ns3 = &#039;&#039;&#039;多行\n字符串&#039;&#039;&#039;\n特点：\n\n字符串是不可变对象。\n支持索引、切片操作：\n\ns = &quot;Python&quot;\nprint(s[0])    # &#039;P&#039;\nprint(s[-1])   # &#039;n&#039;\nprint(s[1:4])  # &#039;yth&#039;\n\n常用方法：\n\nprint(s + &quot; is fun&quot;)         # 拼接\nprint(s.upper())             # 大写\nprint(s.lower())             # 小写\nprint(s.find(&quot;th&quot;))          # 查找子串\nprint(s.replace(&quot;Py&quot;, &quot;C&quot;))  # 替换子串\n\n格式化方式：\n\nname = &quot;Alice&quot;\nage = 25\nprint(f&quot;My name is {name}, and I am {age} years old.&quot;)\n\n4. 列表类型（list）\n有序、可变的数据容器，使用方括号定义。\nnums = [1, 2, 3, 4, 5]\nwords = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]\nmixed = [1, &quot;hello&quot;, 3.14, True]\n特点：\n\n可包含任意类型元素。\n支持索引、切片：\n\nprint(nums[0])    # 1\nprint(nums[-1])   # 5\nprint(nums[1:4])  # [2, 3, 4]\n\n常用方法：\n\nnums.append(6)          # 末尾添加元素\nnums.insert(1, 99)      # 指定位置插入\nnums.remove(3)          # 删除指定值\nnums.sort()             # 原地排序\nnums.reverse()          # 原地反转\nprint(len(nums))        # 元素个数\n\n5. 元组类型（tuple）\n有序、不可变的数据容器，使用圆括号定义。\nt = (1, 2, 3)\nnames = (&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)\n特点：\n\n与列表类似，但元素不可修改。\n支持索引、切片、嵌套：\n\nprint(t[0])    # 1\nprint(t[:2])   # (1, 2)\n\n因其不可变性，可作为字典的键、集合的元素。\n\n\n6. 集合类型（set）\n无序、不重复的元素集合，使用大括号定义。\ns = {1, 2, 3, 3, 4}\nprint(s)  # {1, 2, 3, 4}\n特点：\n\n自动去重。\n支持以下操作：\n\ns.add(5)        # 添加元素\ns.remove(3)     # 删除元素\nprint(2 in s)   # 判断元素是否存在\n\n支持集合运算：\n\na = {1, 2, 3}\nb = {3, 4, 5}\nprint(a | b)    # 并集 {1, 2, 3, 4, 5}\nprint(a &amp; b)    # 交集 {3}\nprint(a - b)    # 差集 {1, 2}\n\n7. 字典类型（dict）\n无序的键值对集合，使用大括号 {} 定义。\nd = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;city&quot;: &quot;New York&quot;}\n特点：\n\n键必须唯一且不可变（通常为字符串、数字或元组）。\n值可以是任意类型。\n常用操作：\n\nprint(d[&quot;name&quot;])         # 访问值\nd[&quot;age&quot;] = 26            # 修改值\nd[&quot;gender&quot;] = &quot;F&quot;        # 添加键值对\ndel d[&quot;city&quot;]            # 删除键值对\n\n字典方法：\n\nprint(d.keys())          # 所有键\nprint(d.values())        # 所有值\nprint(d.items())         # 所有键值对\n\n安全访问键（避免 KeyError）：\n\nprint(d.get(&quot;name&quot;))             # &#039;Alice&#039;\nprint(d.get(&quot;height&quot;, &quot;未知&quot;))   # 不存在则返回默认值\n\n8. 空值类型（NoneType）\nNone 用于表示“无值”或“空值”。\nx = None\nif x is None:\n    print(&quot;x 为空&quot;)\n特点：\n\nNone 是 NoneType 的唯一实例。\n常用于函数无返回值的场景：\n\ndef test():\n    pass\n \nresult = test()\nprint(result)  # 输出 None\n\n总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型是否可变是否有序典型用途int否无整数运算float否无浮点数计算complex否无复数运算bool否无逻辑判断str否是文本处理list是是可变序列，适合动态数据结构tuple否是不可变序列，用作键或常量集合set是否去重、集合运算dict是否键值对存储，查找高效NoneType否无占位符、无返回值\n在编程实践中，合理选择数据类型不仅有助于提升程序的可读性和性能，也有利于数据结构的正确建模和逻辑组织。"},"python/1.基本/1.1.基础语法/1.1.10.模块与包":{"slug":"python/1.基本/1.1.基础语法/1.1.10.模块与包","filePath":"python/1.基本/1.1.基础语法/1.1.10.模块与包.md","title":"1.1.10.模块与包","links":[],"tags":[],"content":"Python 中的模块（Module）与包（Package）\n在 Python 中，**模块（module）与包（package）**是实现代码组织、重用、封装和分发的核心机制。掌握二者对于构建结构清晰、可维护、可拓展的项目具有重要意义。\n\n一、模块（Module）\n1. 定义\n模块是一个以 .py 为扩展名的 Python 文件，每个模块对应一个独立的命名空间，可包含变量、函数、类、异常定义、可执行代码等。\n示例：\n# math_utils.py\ndef add(a, b):\n    return a + b\n \nPI = 3.14159\n2. 模块导入方式\nimport math_utils\nprint(math_utils.add(2, 3))\n \nfrom math_utils import add\nprint(add(5, 6))\n \nimport math_utils as mu\nprint(mu.add(1, 2))\n3. 模块搜索路径（sys.path）\n导入模块时，Python 按以下顺序搜索模块路径：\n\n当前执行脚本所在目录；\n环境变量 PYTHONPATH 指定的目录；\n标准库路径（如 /usr/lib/pythonX.Y）；\n第三方库目录（如 site-packages）。\n\n查看路径：\nimport sys\nprint(sys.path)\n动态添加搜索路径（仅临时）：\nsys.path.append(&#039;/custom/path&#039;)\n4. __name__ 属性的作用\n每个模块都有内置变量 __name__：\n\n若模块作为主程序执行，__name__ == &#039;__main__&#039;；\n若模块被导入，__name__ == 模块名。\n\n常用于防止模块中的测试代码被导入时执行：\n# example.py\ndef main():\n    print(&quot;模块主逻辑&quot;)\n \nif __name__ == &#039;__main__&#039;:\n    main()\n\n二、包（Package）\n1. 定义\n包是一个包含 __init__.py 文件的目录，用于组织多个模块。该文件可为空，Python 3.3+ 起可省略，但为兼容性建议保留。\n示例结构：\nmy_package/\n│\n├── __init__.py\n├── module1.py\n└── module2.py\n2. 包内模块导入\nimport my_package.module1\nmy_package.module1.func()\n \nfrom my_package import module2\nmodule2.func()\n支持嵌套包结构：\nfrom my_package.subpackage.module import func\n3. __init__.py 的作用\n\n明确标识该目录为包；\n初始化操作（如配置、注册日志等）；\n控制 from package import * 的导出项；\n简化包的使用方式（如重导出模块）：\n\n# my_package/__init__.py\nprint(&quot;初始化 my_package&quot;)\nfrom .module1 import useful_func\n__all__ = [&#039;useful_func&#039;]\n\n三、模块与包的区别总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n比较项模块（Module）包（Package）本质一个 .py文件一个含 __init__.py的目录标识方式文件名后缀为 .py目录中含 __init__.py文件层级结构通常为扁平结构支持嵌套结构，便于分层组织用途封装单一功能模块管理多个模块，构建功能集合或库导入方式import moduleimport package.module\n\n四、常见实践建议\n1. 编写工具模块（如工具函数/通用类）\n# utils/file_io.py\ndef read_file(path):\n    with open(path, &#039;r&#039;, encoding=&#039;utf-8&#039;) as f:\n        return f.read()\n2. 规范的项目结构\nmy_project/\n├── main.py\n├── utils/\n│   ├── __init__.py\n│   └── file_io.py\n├── models/\n│   ├── __init__.py\n│   └── user.py\n└── config/\n    └── settings.py\n使用示例：\nfrom utils.file_io import read_file\nfrom models.user import User\n3. 发布模块或包为第三方库\n\n创建 setup.py 配置文件；\n使用 setuptools 构建打包；\n发布至 PyPI 或企业内部源。\n\n示例命令：\npython setup.py sdist bdist_wheel\ntwine upload dist/*\n\n五、进阶特性与补充说明\n1. 相对导入与绝对导入\n\n绝对导入（推荐）：从项目根路径开始导入\nfrom my_package.module1 import func\n相对导入：用于包内部模块间引用\n\nfrom .module1 import func\nfrom ..utils import helper\n注意：相对导入仅适用于模块被作为包的一部分执行，不适用于顶层脚本执行（即 __name__ == &#039;__main__&#039; 时可能失败）。\n2. 动态模块导入（importlib）\n用于插件机制或运行时动态加载：\nimport importlib\n \nmodule_name = &#039;my_package.module1&#039;\nmod = importlib.import_module(module_name)\nmod.some_function()\n还可结合 getattr() 获取函数或类对象，提升灵活性。\n3. 模块缓存与重载（高级调试场景）\nPython 缓存已加载模块（在 sys.modules 中），可使用 importlib.reload() 重载模块（如 Jupyter 中调试）：\nimport importlib\nimport my_module\n \nimportlib.reload(my_module)\n4. 多模块共享配置（典型用法）\n可在顶层 config/settings.py 中集中配置，其他模块导入使用：\n# config/settings.py\nDATABASE_URI = &quot;sqlite:///test.db&quot;\n# models/user.py\nfrom config.settings import DATABASE_URI\n\n六、总结\n\n模块与包是 Python 中组织代码的两大基石；\n模块适合封装小功能，包则构建可拓展的功能集合；\n掌握相对导入、动态加载与模块搜索路径是编写大型项目的关键；\n规范项目结构、配置 __init__.py、理解模块生命周期有助于高质量 Python 编程实践。\n\n如需进一步深入，请参考官方文档：\n\nPython 模块与包官方文档\n"},"python/1.基本/1.1.基础语法/1.1.11.Lambda-表达式与高阶函数":{"slug":"python/1.基本/1.1.基础语法/1.1.11.Lambda-表达式与高阶函数","filePath":"python/1.基本/1.1.基础语法/1.1.11.Lambda 表达式与高阶函数.md","title":"1.1.11.Lambda 表达式与高阶函数","links":[],"tags":[],"content":"Lambda 表达式与高阶函数\n在 Python 编程中，Lambda 表达式与高阶函数是函数式编程（Functional Programming）的核心组成部分。它们可以使代码更加简洁、灵活，尤其适用于将函数作为参数或返回值的场景，如数据处理、回调函数、事件驱动等。\n\n一、Lambda 表达式\n1. 概念\nLambda 是 Python 提供的一种匿名函数的语法形式，也称为 Lambda 表达式。用于创建临时的、简洁的函数对象，通常在不需要重复使用函数名的情况下使用。\n2. 基本语法\nlambda 参数1, 参数2, ... : 表达式\n等价于：\ndef 函数名(参数1, 参数2, ...):\n    return 表达式\n3. 示例\n# 普通函数\ndef add(x, y):\n    return x + y\n \n# Lambda 表达式\nadd_lambda = lambda x, y: x + y\n \nprint(add(3, 4))         # 输出 7\nprint(add_lambda(3, 4))  # 输出 7\n4. 使用场景\nLambda 表达式通常用于临时使用函数且不需要命名的场合，包括但不限于：\n\n与高阶函数（如 map()、filter()、sorted() 等）结合使用；\nGUI 编程中的事件回调；\n某些简洁的函数计算逻辑，嵌入表达式内部。\n\n\n二、高阶函数（Higher-Order Function）\n1. 概念\n高阶函数是指接收函数作为参数，或返回函数作为结果的函数。它使函数在程序中成为“一级公民”，提高代码的抽象能力和复用性。\nPython 中常用的高阶函数包括：\n\nmap()\nfilter()\nreduce()（需导入 functools 模块）\nsorted()（通过 key 参数指定排序依据）\n\n\n2. 常见高阶函数详解\n2.1 map(func, iterable)\n对可迭代对象的每个元素执行 func 操作，并返回一个新的迭代器。\nnums = [1, 2, 3, 4]\nsquared = list(map(lambda x: x**2, nums))\nprint(squared)  # 输出 [1, 4, 9, 16]\n2.2 filter(func, iterable)\n对可迭代对象进行过滤，仅保留 func 返回 True 的元素。\nnums = [1, 2, 3, 4, 5]\neven = list(filter(lambda x: x % 2 == 0, nums))\nprint(even)  # 输出 [2, 4]\n2.3 reduce(func, iterable)\n对 iterable 中的元素进行累积操作。使用前需导入 functools 模块。\nfrom functools import reduce\n \nnums = [1, 2, 3, 4]\nproduct = reduce(lambda x, y: x * y, nums)\nprint(product)  # 输出 24（即 1*2*3*4）\n2.4 sorted(iterable, key=func, reverse=False)\n对序列进行排序。可通过 key 指定排序依据，通过 reverse 指定是否反转排序结果。\ndata = [&#039;abc&#039;, &#039;a&#039;, &#039;abcd&#039;]\nsorted_data = sorted(data, key=lambda x: len(x))\nprint(sorted_data)  # 输出 [&#039;a&#039;, &#039;abc&#039;, &#039;abcd&#039;]\n\n三、Lambda 与高阶函数结合示例\n以下示例展示了如何结合使用 Lambda 表达式与高阶函数来进行数据排序：\nstudents = [\n    {&#039;name&#039;: &#039;Alice&#039;, &#039;score&#039;: 88},\n    {&#039;name&#039;: &#039;Bob&#039;, &#039;score&#039;: 95},\n    {&#039;name&#039;: &#039;Charlie&#039;, &#039;score&#039;: 70}\n]\n \n# 按成绩从高到低排序\nsorted_students = sorted(students, key=lambda s: s[&#039;score&#039;], reverse=True)\n \nfor s in sorted_students:\n    print(s[&#039;name&#039;], s[&#039;score&#039;])\n输出：\nBob 95  \nAlice 88  \nCharlie 70\n\n四、小结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n术语含义典型用途Lambda 表达式一种用于定义匿名函数的简洁语法方式临时函数、函数式编程高阶函数接收函数作为参数或返回值的函数map/filter/reduce/sorted 等操作\nLambda 表达式与高阶函数在数据处理、快速原型开发、事件驱动编程中均有广泛应用，是 Python 编程人员应掌握的重要技能。"},"python/1.基本/1.1.基础语法/1.1.2.函数":{"slug":"python/1.基本/1.1.基础语法/1.1.2.函数","filePath":"python/1.基本/1.1.基础语法/1.1.2.函数.md","title":"1.1.2.函数","links":[],"tags":[],"content":"在 Python 中，**函数（Function）**是组织代码逻辑、提高代码复用性、实现模块化编程的重要工具。Python 支持多种类型的函数：内置函数、自定义函数、匿名函数，并且支持多种参数传递方式、闭包、递归、函数式编程等特性。\n\n一、函数的定义与调用\n1.1 基本语法\ndef 函数名(参数1, 参数2, ...):\n    &quot;&quot;&quot;文档字符串（可选）&quot;&quot;&quot;\n    函数体\n    return 返回值（可选）\n示例：\ndef greet(name):\n    &quot;&quot;&quot;输出问候语&quot;&quot;&quot;\n    print(f&quot;Hello, {name}!&quot;)\n \ngreet(&quot;Alice&quot;)  # 调用函数\n\n二、函数的参数\n2.1 位置参数（Positional Arguments）\n按顺序传入，与定义顺序一致：\ndef add(a, b):\n    return a + b\n \nprint(add(3, 5))  # 输出 8\n2.2 关键字参数（Keyword Arguments）\n通过指定参数名传入，顺序可不一致：\ndef greet(name, msg):\n    print(f&quot;{msg}, {name}!&quot;)\n \ngreet(msg=&quot;Hi&quot;, name=&quot;Bob&quot;)\n2.3 默认参数（Default Arguments）\n为某些参数提供默认值：\ndef greet(name, msg=&quot;Hello&quot;):\n    print(f&quot;{msg}, {name}!&quot;)\n \ngreet(&quot;Tom&quot;)               # 使用默认值\ngreet(&quot;Jerry&quot;, &quot;Welcome&quot;) # 覆盖默认值\n2.4 可变参数\n\n*args：接收多个位置参数，类型为 tuple。\n**kwargs：接收多个关键字参数，类型为 dict。\n\ndef demo_args(*args):\n    print(args)\n \ndef demo_kwargs(**kwargs):\n    print(kwargs)\n \ndemo_args(1, 2, 3)  # 输出 (1, 2, 3)\ndemo_kwargs(a=1, b=2)  # 输出 {&#039;a&#039;: 1, &#039;b&#039;: 2}\n\n三、函数的返回值\n3.1 单个返回值\ndef square(x):\n    return x * x\n \nprint(square(4))  # 输出 16\n3.2 多个返回值（自动封装为元组）\ndef get_name_and_age():\n    return &quot;Alice&quot;, 25\n \nname, age = get_name_and_age()\n3.3 无返回值\n默认返回 None：\ndef say_hi():\n    print(&quot;Hi&quot;)\n \nresult = say_hi()\nprint(result)  # 输出 None\n\n四、变量作用域与闭包\n4.1 LEGB 原则\n\nLocal：函数内部定义的变量。\nEnclosing：外层函数中定义的变量。\nGlobal：模块级变量。\nBuilt-in：Python 内置命名空间（如 len、print 等）。\n\n4.2 global 与 nonlocal\n\nglobal 用于在函数内部修改全局变量。\n\nx = 0\ndef modify_global():\n    global x\n    x = 10\n\nnonlocal 用于修改嵌套函数外层但非全局变量。\n\ndef outer():\n    x = 5\n    def inner():\n        nonlocal x\n        x += 1\n    inner()\n    print(x)  # 输出 6\n\n五、匿名函数（Lambda）\n用于快速定义简单函数：\nsquare = lambda x: x ** 2\nprint(square(5))  # 输出 25\n常与函数式工具配合使用：\nnums = [1, 2, 3]\nsquares = list(map(lambda x: x * x, nums))\nprint(squares)  # 输出 [1, 4, 9]\n\n六、递归函数\n函数自身调用自身，常用于分治型问题：\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n - 1)\n注意：递归深度有限，可通过 sys.setrecursionlimit() 设置上限。\n\n七、高阶函数\nPython 中函数可以作为参数或返回值，即函数是一等公民。\n7.1 函数作为参数\ndef apply(func, value):\n    return func(value)\n \nprint(apply(abs, -5))  # 输出 5\n7.2 函数作为返回值\ndef outer(msg):\n    def inner():\n        print(f&quot;Message: {msg}&quot;)\n    return inner\n \nf = outer(&quot;Hello&quot;)\nf()  # 输出 Message: Hello\n\n八、装饰器（Decorator）简述\n装饰器用于在不修改原函数的前提下，增强函数的功能。其本质是一个高阶函数。\ndef decorator(func):\n    def wrapper():\n        print(&quot;Before call&quot;)\n        func()\n        print(&quot;After call&quot;)\n    return wrapper\n \n@decorator\ndef say_hello():\n    print(&quot;Hello&quot;)\n \nsay_hello()\n输出：\nBefore call\nHello\nAfter call\n\n九、函数注解（Function Annotations）\n用于为参数和返回值添加类型说明：\ndef greet(name: str, age: int) -&gt; str:\n    return f&quot;Hello, {name}. You are {age} years old.&quot;\n注解仅用于提示，不具备强制性。\n\n十、内置函数与标准库函数\nPython 提供了大量实用的内置函数，如：\n\n数学相关：abs()、round()、pow()、sum()、max()、min()。\n类型转换：int()、float()、str()、bool()。\n序列操作：len()、sorted()、enumerate()、zip()、reversed()。\n其它：type()、id()、dir()、help() 等。\n\n\n总结\n函数是 Python 编程的核心模块之一。掌握函数的定义、调用、参数传递、作用域规则、匿名函数、递归与高阶函数等内容，有助于开发出结构清晰、易于维护的程序。通过合理运用函数，可以极大提升代码的复用性、可读性和可测试性。"},"python/1.基本/1.1.基础语法/1.1.3.运算符":{"slug":"python/1.基本/1.1.基础语法/1.1.3.运算符","filePath":"python/1.基本/1.1.基础语法/1.1.3.运算符.md","title":"1.1.3.运算符","links":[],"tags":[],"content":"Python 的运算符用于对变量和数值进行操作。它们根据功能可以分为以下几类，每一类中都有多个具体运算符。以下是对每类运算符的详尽讲解，包括其作用、使用示例及注意事项：\n\n一、算术运算符（Arithmetic Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果+加法3 + 25-减法5 - 23*乘法3 * 26/除法7 / 23.5//整除7 // 23%取余7 % 21**幂（乘方）2 ** 38\n💡 注意：\n\n/ 总是返回浮点数。\n// 是地板除，结果向下取整。\n** 支持浮点指数，例如 4 ** 0.5 = 2.0。\n\n\n二、比较运算符（Comparison Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果==等于3 == 3True!=不等于3 != 4True&gt;大于5 &gt; 2True&lt;小于2 &lt; 3True&gt;=大于等于3 &gt;= 3True&lt;=小于等于2 &lt;= 3True\n💡 通常用于条件判断语句中，如 if 语句。\n\n三、赋值运算符（Assignment Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例等价于=赋值a = 5+=加后赋值a += 2a = a + 2-=减后赋值a -= 1a = a - 1*=乘后赋值a *= 3a = a * 3/=除后赋值a /= 2a = a / 2//=整除后赋值a //= 2a = a // 2%=取余后赋值a %= 3a = a % 3**=幂后赋值a **= 2a = a ** 2\n\n四、逻辑运算符（Logical Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果and与True and FalseFalseor或False or TrueTruenot非not TrueFalse\n💡 常用于布尔表达式中，支持短路运算（如 and 前为 False 则不会再判断后者）。\n\n五、位运算符（Bitwise Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果（二进制）&amp;按位与5 &amp; 31（0b0001）``按位或`5^按位异或5 ^ 36（0b0110）~按位取反~5-6（补码）&lt;&lt;左移5 &lt;&lt; 110（0b1010）&gt;&gt;右移5 &gt;&gt; 12（0b0010）\n💡 通常用于底层运算、加密算法等。\n\n六、成员运算符（Membership Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果in元素是否存在&#039;a&#039; in &#039;apple&#039;Truenot in元素是否不存在&#039;x&#039; not in &#039;abc&#039;True\n\n七、身份运算符（Identity Operators）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符含义示例结果is是否为同一对象（地址）a is bTrue或Falseis not是否不是同一对象a is not bTrue或False\n💡 is 检查的是对象的“身份”而非“值”。例如 a = [1,2]; b = [1,2]; a == b 为 True，但 a is b 为 False。\n\n八、运算符优先级（从高到低）\n\n**\n+x, -x, ~x（一元运算符）\n*, /, //, %\n+, -\n&lt;&lt;, &gt;&gt;\n&amp;\n^\n|\n==, !=, &gt;, &lt;, &gt;=, &lt;=, is, is not, in, not in\nnot\nand\nor\n=, +=, -=, 等赋值运算符（最低）\n"},"python/1.基本/1.1.基础语法/1.1.4.控制结构":{"slug":"python/1.基本/1.1.基础语法/1.1.4.控制结构","filePath":"python/1.基本/1.1.基础语法/1.1.4.控制结构.md","title":"1.1.4.控制结构","links":[],"tags":[],"content":"一、顺序结构（Sequential）\n顺序结构是程序最基本的执行方式，语句按照从上到下的顺序依次执行。\nprint(&quot;第一步&quot;)\nprint(&quot;第二步&quot;)\nprint(&quot;第三步&quot;)\n\n二、选择结构（Selection）\n用于根据条件判断选择不同的执行路径，主要有三种形式：\n1. if 语句\nx = 10\nif x &gt; 0:\n    print(&quot;x 是正数&quot;)\n2. if-else 语句\nx = -5\nif x &gt; 0:\n    print(&quot;x 是正数&quot;)\nelse:\n    print(&quot;x 是非正数&quot;)\n3. if-elif-else 语句\nx = 0\nif x &gt; 0:\n    print(&quot;正数&quot;)\nelif x == 0:\n    print(&quot;零&quot;)\nelse:\n    print(&quot;负数&quot;)\n\n三、循环结构（Looping）\n用于重复执行某些语句。Python 中主要有两种循环：\n1. while 循环\n在满足条件的情况下重复执行。\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1\n注意：while 循环可能造成死循环，请确保条件可终止。\n2. for 循环\n通常用于遍历序列（如列表、元组、字符串、字典等）。\nfor i in range(5):\n    print(i)\n结合序列类型使用：\n# 遍历字符串\nfor ch in &quot;Hello&quot;:\n    print(ch)\n \n# 遍历列表\nfor item in [1, 2, 3]:\n    print(item)\n \n# 遍历字典\nd = {&quot;a&quot;: 1, &quot;b&quot;: 2}\nfor key, value in d.items():\n    print(f&quot;{key}: {value}&quot;)\n\n四、循环控制语句\n1. break：立即终止循环\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)\n2. continue：跳过当前这次循环，继续下一轮\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)\n3. else 结构（for/while）\n当 for 或 while 正常结束（非 break 终止）时会执行 else 子句。\nfor i in range(3):\n    print(i)\nelse:\n    print(&quot;循环正常结束&quot;)\n\n五、嵌套结构\nPython 允许在控制结构中嵌套其他控制结构：\nfor i in range(3):\n    for j in range(2):\n        print(f&quot;i={i}, j={j}&quot;)\n\n六、条件表达式（三元表达式）\nx = 5\nresult = &quot;正数&quot; if x &gt; 0 else &quot;非正数&quot;\nprint(result)\n\n七、match-case（Python 3.10+ 引入）\n用于结构化模式匹配，类似于其他语言中的 switch-case。\ndef http_status(code):\n    match code:\n        case 200:\n            return &quot;OK&quot;\n        case 404:\n            return &quot;Not Found&quot;\n        case 500:\n            return &quot;Server Error&quot;\n        case _:\n            return &quot;Unknown&quot;\n \nprint(http_status(404))"},"python/1.基本/1.1.基础语法/1.1.5.生成器":{"slug":"python/1.基本/1.1.基础语法/1.1.5.生成器","filePath":"python/1.基本/1.1.基础语法/1.1.5.生成器.md","title":"1.1.5.生成器","links":[],"tags":[],"content":"Python 生成器（Generator）详解\n1. 什么是生成器？\n生成器（Generator）是一种特殊的迭代器（Iterator），它不会一次性生成所有数据，而是按需计算，能有效节省内存并提高程序效率。\n在 Python 中，生成器的本质是 一个返回值可迭代的对象，每次调用都会动态计算下一个值，而不是一次性把所有元素存入内存。\n\n2. 生成器的特点\n✅ 惰性求值（Lazy Evaluation）：不会一次性生成所有元素，而是按需返回，适用于大数据处理。\n✅ 占用内存少：只存储当前状态，而不是整个列表。\n✅ 可迭代：可以用 for 循环遍历，也可以用 next() 获取下一个值。✅ 只能遍历一次：生成器不会存储历史数据，遍历一次后就用完了。\n\n3. 创建生成器的方式\nPython 提供了两种方式创建生成器：\n\n使用 **yield** 关键字（推荐方式）\n使用生成器表达式\n\n\n4. 使用 **yield** 创建生成器\nyield 让函数变成一个 生成器函数，每次调用 next() 或 for 循环时，都会返回一个新的值，并暂停执行。\n示例 1：简单生成器\ndef my_generator():\n    print(&quot;生成第一个值&quot;)\n    yield 1\n    print(&quot;生成第二个值&quot;)\n    yield 2\n    print(&quot;生成第三个值&quot;)\n    yield 3\n \ngen = my_generator()  # 创建生成器\nprint(next(gen))  # 生成第一个值\nprint(next(gen))  # 生成第二个值\nprint(next(gen))  # 生成第三个值\n输出：\n生成第一个值\n1\n生成第二个值\n2\n生成第三个值\n3\n解释\n\nyield 让函数暂停，返回一个值，但不会结束函数。\n下一次调用 **next()** 时，函数会从上次暂停的地方继续执行。\n\n\n示例 2：**for** 遍历生成器\n可以用 for 循环遍历生成器，它会自动调用 next()：\nfor num in my_generator():\n    print(num)\n输出\n生成第一个值\n1\n生成第二个值\n2\n生成第三个值\n3\nfor 循环会自动捕获 StopIteration 异常，因此比 next() 更安全。\n\n5. 生成器 vs 普通函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n普通函数生成器（yield）返回方式return一次返回所有数据yield按需返回执行模式一次性计算全部按需计算（惰性求值）内存占用高，占用全部数据低，只存储当前状态是否可迭代❌ 不能迭代✅ 可迭代\n\n6. 生成器的应用\n6.1 生成无限序列\ndef infinite_counter():\n    num = 1\n    while True:\n        yield num\n        num += 1\n \ncounter = infinite_counter()\nprint(next(counter))  # 1\nprint(next(counter))  # 2\nprint(next(counter))  # 3\n注意：生成器不会占用大量内存，而是按需生成值，因此可以处理无限序列。\n\n6.2 生成斐波那契数列\ndef fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n \nfib = fibonacci(10)\nprint(list(fib))  # 输出: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n普通方法 需要创建一个列表存储所有值，而生成器节省内存。\n\n6.3 读取大文件\n如果文件很大（如 10GB 日志文件），可以用 生成器逐行读取，避免一次性加载到内存：\ndef read_large_file(file_path):\n    with open(file_path, &quot;r&quot;) as f:\n        for line in f:\n            yield line.strip()\n \nfor line in read_large_file(&quot;big_log.txt&quot;):\n    print(line)  # 逐行处理\n普通方法f.readlines() 会一次性读取整个文件，导致内存占用过大。\n\n7. 使用 **yield from** 简化生成器\n如果生成器中 需要调用另一个生成器，可以使用 yield from 语法简化代码。\n示例\ndef generator1():\n    yield from range(5)  # 直接产出 0, 1, 2, 3, 4\n \nfor num in generator1():\n    print(num)\n等价于\ndef generator2():\n    for i in range(5):\n        yield i\nyield from直接委托 另一个生成器，代码更简洁。\n\n8. 生成器表达式（Generator Expression）\n生成器表达式和列表解析类似，但使用 小括号 **()**，不会一次性创建整个列表，而是按需计算。\n示例\nnums = (x ** 2 for x in range(5))  # 生成器表达式\nprint(next(nums))  # 0\nprint(next(nums))  # 1\nprint(list(nums))  # 剩余部分: [4, 9, 16]\n列表解析 **[]** 一次性计算所有值，而生成器表达式 **()** 按需计算。\n等价于\ndef square_generator():\n    for x in range(5):\n        yield x ** 2\n\n9. 生成器与 **itertools**\nPython 的 itertools 模块提供了更强大的生成器工具：\nimport itertools\n \n# 无限计数\ncounter = itertools.count(1, step=2)\nprint(next(counter))  # 1\nprint(next(counter))  # 3\n \n# 无限循环一个序列\ncycle_colors = itertools.cycle([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])\nprint(next(cycle_colors))  # red\nprint(next(cycle_colors))  # green\n\n10. 总结\n✅ 生成器的优点\n\n节省内存：只存储当前状态，不存整个列表。\n惰性求值：按需生成数据，适合处理大数据或无限序列。\n代码简洁：yield 让代码更直观，避免手动管理迭代器状态。\n\n📌 适用场景\n\n生成大量数据（如日志、传感器数据）\n处理无限序列（如斐波那契、素数等）\n逐行读取大文件\n流式数据处理\n"},"python/1.基本/1.1.基础语法/1.1.6.装饰器":{"slug":"python/1.基本/1.1.基础语法/1.1.6.装饰器","filePath":"python/1.基本/1.1.基础语法/1.1.6.装饰器.md","title":"1.1.6.装饰器","links":[],"tags":[],"content":"Python 装饰器（Decorator）详解\n1. 什么是装饰器？\n装饰器（Decorator）是一种用于修改函数或类行为的高阶函数，它不改变原始函数的代码，而是在函数执行前后添加额外的功能。\n核心思想：\n\nPython 函数是一等对象（可以作为参数传递、返回）。\n装饰器本质是一个函数，它接收一个函数作为参数，然后返回修改后的新函数。\n\n\n2. 装饰器的基本结构\n装饰器通常使用 @decorator_name 语法糖，也可以用手动方式调用。\ndef my_decorator(func):\n    def wrapper():\n        print(&quot;执行前&quot;)\n        func()\n        print(&quot;执行后&quot;)\n    return wrapper\n \n@my_decorator  # 等价于 hello = my_decorator(hello)\ndef hello():\n    print(&quot;Hello, world!&quot;)\n \nhello()\n执行结果：\n执行前\nHello, world!\n执行后\n等价于：\ndef hello():\n    print(&quot;Hello, world!&quot;)\n \ndecorated_hello = my_decorator(hello)\ndecorated_hello()\n\n3. 装饰器的作用\n🔹 在不修改原函数代码的情况下，添加功能（如日志、权限验证、计时等）。\n🔹 提高代码复用性（多个函数可以复用同一个装饰器）。\n🔹 符合”开放封闭原则”（OCP，对扩展开放，对修改封闭）。\n\n4. 带参数的装饰器\n如果原始函数带参数，装饰器的 wrapper 也要支持参数：\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):  # 支持任意参数\n        print(&quot;执行前&quot;)\n        result = func(*args, **kwargs)\n        print(&quot;执行后&quot;)\n        return result\n    return wrapper\n \n@my_decorator\ndef add(a, b):\n    return a + b\n \nprint(add(3, 5))  # 先执行装饰器逻辑，再计算 3 + 5\n执行结果：\n执行前\n执行后\n8\n\n5. 多个装饰器\n如果有多个装饰器，它们会从内到外依次执行：\ndef deco1(func):\n    def wrapper():\n        print(&quot;deco1 执行&quot;)\n        func()\n    return wrapper\n \ndef deco2(func):\n    def wrapper():\n        print(&quot;deco2 执行&quot;)\n        func()\n    return wrapper\n \n@deco1\n@deco2\ndef say_hello():\n    print(&quot;Hello!&quot;)\n \nsay_hello()\n执行顺序：\ndeco1 执行\ndeco2 执行\nHello!\n说明：@deco1 包裹 @deco2，所以 deco1 先执行，deco2 后执行。\n\n6. 带参数的装饰器\n如果装饰器本身需要参数，则需要多嵌套一层函数。\ndef repeat(n):  # 装饰器工厂\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(n):\n                func(*args, **kwargs)\n        return wrapper\n    return decorator\n \n@repeat(3)\ndef greet():\n    print(&quot;Hello!&quot;)\n \ngreet()\n执行结果：\nHello!\nHello!\nHello!\n说明：repeat(3) 返回 decorator，然后 decorator(greet) 生成 wrapper。\n\n7. **functools.wraps** 保留原函数信息\n装饰器默认会覆盖原函数的 **__name__** 和 **__doc__**，可以用 functools.wraps() 解决。\nimport functools\n \ndef my_decorator(func):\n    @functools.wraps(func)  # 让 wrapper 继承 func 的元数据\n    def wrapper(*args, **kwargs):\n        print(&quot;执行前&quot;)\n        return func(*args, **kwargs)\n    return wrapper\n \n@my_decorator\ndef hello():\n    &quot;&quot;&quot;这是 hello 函数的文档&quot;&quot;&quot;\n    print(&quot;Hello!&quot;)\n \nprint(hello.__name__)  # 仍然是 hello\nprint(hello.__doc__)   # 仍然是 hello 的文档\n\n8. 典型应用场景\n(1) 记录日志\nimport time\n \ndef log_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(f&quot;调用函数 {func.__name__}，参数: {args} {kwargs}&quot;)\n        return func(*args, **kwargs)\n    return wrapper\n \n@log_decorator\ndef add(a, b):\n    return a + b\n \nprint(add(2, 3))\n输出\n调用函数 add，参数: (2, 3) {}\n5\n\n(2) 计算函数执行时间\nimport time\n \ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f&quot;{func.__name__} 执行时间: {end - start:.5f} 秒&quot;)\n        return result\n    return wrapper\n \n@timing_decorator\ndef slow_function():\n    time.sleep(1)\n \nslow_function()\n输出\nslow_function 执行时间: 1.00023 秒\n\n(3) 权限验证\ndef check_permission(user):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            if user != &quot;admin&quot;:\n                print(&quot;权限不足&quot;)\n                return\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n \n@check_permission(&quot;admin&quot;)\ndef delete_database():\n    print(&quot;数据库已删除！&quot;)\n \ndelete_database()  # admin 有权限\n\n9. 类装饰器\n类也可以作为装饰器，使用 __call__ 方法。\nclass Logger:\n    def __init__(self, func):\n        self.func = func\n \n    def __call__(self, *args, **kwargs):\n        print(f&quot;调用函数 {self.func.__name__}&quot;)\n        return self.func(*args, **kwargs)\n \n@Logger\ndef say_hello():\n    print(&quot;Hello!&quot;)\n \nsay_hello()\n执行结果\n调用函数 say_hello\nHello!\n\n10. 总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性说明基本装饰器@decorator语法糖，包装函数逻辑支持参数用 *args, **kwargs兼容任意参数多个装饰器从内到外依次执行装饰器工厂允许装饰器接受参数（多嵌套一层）**functools.wraps**保持原函数 __name__和 __doc__应用场景计时、日志、权限验证等"},"python/1.基本/1.1.基础语法/1.1.7.上下文管理器":{"slug":"python/1.基本/1.1.基础语法/1.1.7.上下文管理器","filePath":"python/1.基本/1.1.基础语法/1.1.7.上下文管理器.md","title":"1.1.7.上下文管理器","links":[],"tags":[],"content":"Python 上下文管理器（Context Manager）详解\n1. 什么是上下文管理器？\nPython 中的上下文管理器（Context Manager）是一种用于管理资源的机制，它可以自动在代码块执行前后执行特定操作，避免手动释放资源。\n最常见的例子是 with open() 语句，它会自动关闭文件，避免资源泄露。\nwith open(&quot;example.txt&quot;, &quot;w&quot;) as file:\n    file.write(&quot;Hello, world!&quot;)  # 自动管理资源\n**with** 语句的作用：\n\n进入时（__enter__）：打开文件\n退出时（__exit__）：关闭文件\n\n\n2. 为什么需要上下文管理器？\n手动管理资源的弊端\n如果不使用 with，我们需要手动关闭文件：\nfile = open(&quot;example.txt&quot;, &quot;w&quot;)\ntry:\n    file.write(&quot;Hello, world!&quot;)\nfinally:\n    file.close()  # 需要手动关闭文件\n问题：\n\n容易忘记关闭资源（如文件、数据库连接）。\n异常处理中需要 **try-finally**，代码冗长。\n适用于各种资源管理（如文件、数据库连接、多线程锁）。\n\n解决方案： 使用 with 语句和上下文管理器。\n\n3. **with** 语句的工作原理\nwith 语句背后依赖上下文管理器协议，即必须实现两个方法：\n\n__enter__(self)：在进入with 代码块时执行。\n__exit__(self, exc_type, exc_value, traceback)：在退出with 代码块时执行，即使发生异常也会执行。\n\nclass MyContext:\n    def __enter__(self):\n        print(&quot;进入上下文&quot;)\n        return self  # 可以返回任意对象\n \n    def __exit__(self, exc_type, exc_value, traceback):\n        print(&quot;退出上下文&quot;)\n \nwith MyContext():\n    print(&quot;执行 with 代码块&quot;)\n输出：\n进入上下文\n执行 with 代码块\n退出上下文\n\n4. 自定义上下文管理器\n(1) 用类实现上下文管理器\n可以自定义一个文件操作的上下文管理器：\nclass FileManager:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n        self.file = None\n \n    def __enter__(self):\n        self.file = open(self.filename, self.mode)\n        return self.file  # 让 `with` 语句接收这个对象\n \n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.file:\n            self.file.close()\n        print(&quot;文件已关闭&quot;)\n \nwith FileManager(&quot;example.txt&quot;, &quot;w&quot;) as f:\n    f.write(&quot;Hello, Python!&quot;)  # 自动关闭文件\n输出：\n文件已关闭\n即使 with 代码块内出现异常，__exit__ 仍然会执行，确保文件关闭。\n\n(2) 用 **contextlib** 实现更简洁的上下文管理\nPython 内置 contextlib 可以用 **@contextmanager** 装饰器 简化上下文管理器。\nfrom contextlib import contextmanager\n \n@contextmanager\ndef file_manager(filename, mode):\n    f = open(filename, mode)\n    try:\n        yield f  # `yield` 之前的代码相当于 `__enter__`\n    finally:\n        f.close()  # `yield` 之后的代码相当于 `__exit__`\n        print(&quot;文件已关闭&quot;)\n \nwith file_manager(&quot;example.txt&quot;, &quot;w&quot;) as f:\n    f.write(&quot;Hello, world!&quot;)\n好处：\n\n使用 **yield** 代替 **__enter__** 和 **__exit__**，代码更清晰。\n更适合简单的资源管理任务。\n\n\n5. 上下文管理器的应用场景\n(1) 自动管理文件\nwith open(&quot;example.txt&quot;, &quot;r&quot;) as f:\n    content = f.read()\n    print(content)  # 代码块结束后自动关闭文件\n(2) 管理数据库连接\nimport sqlite3\n \nclass Database:\n    def __init__(self, db_name):\n        self.db_name = db_name\n \n    def __enter__(self):\n        self.conn = sqlite3.connect(self.db_name)\n        return self.conn.cursor()\n \n    def __exit__(self, exc_type, exc_value, traceback):\n        self.conn.commit()\n        self.conn.close()\n \nwith Database(&quot;example.db&quot;) as cursor:\n    cursor.execute(&quot;CREATE TABLE IF NOT EXISTS users (id INTEGER, name TEXT)&quot;)\n确保：\n\n数据库自动提交事务。\n自动关闭数据库连接，避免资源泄露。\n\n\n(3) 线程锁\nimport threading\n \nlock = threading.Lock()\n \n# 自动管理锁的获取和释放\nwith lock:\n    print(&quot;线程安全操作&quot;)\n\n(4) 计时器\nimport time\nfrom contextlib import contextmanager\n \n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    end = time.time()\n    print(f&quot;运行时间: {end - start:.2f} 秒&quot;)\n \nwith timer():\n    time.sleep(1)  # 模拟耗时操作\n\n(5) 临时修改 **sys.stdout**\nimport sys\nfrom contextlib import contextmanager\nimport io\n \n@contextmanager\ndef capture_stdout():\n    old_stdout = sys.stdout\n    sys.stdout = new_stdout = io.StringIO()\n    yield new_stdout\n    sys.stdout = old_stdout\n \nwith capture_stdout() as output:\n    print(&quot;Hello, world!&quot;)\n \nprint(&quot;捕获的输出:&quot;, output.getvalue())\n\n6. **contextlib** 的其他工具\n(1) **closing()**\nclosing() 用于管理不支持 **__exit__** 的对象（如 urlopen）。\nfrom contextlib import closing\nfrom urllib.request import urlopen\n \nwith closing(urlopen(&quot;www.example.com&quot;)) as page:\n    print(page.read().decode())\n作用：确保 urlopen 在退出 with 时正确关闭。\n\n(2) **suppress()**\ncontextlib.suppress() 用于忽略指定异常。\nfrom contextlib import suppress\n \nwith suppress(ZeroDivisionError):\n    1 / 0  # 不会抛出异常\n作用：静默处理特定异常，避免 try-except 代码块。\n\n7. 总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法说明with语句自动管理资源，避免手动释放__enter__()进入 with代码块时执行__exit__()退出 with代码块时执行，处理异常@contextmanager用 yield代替 __enter__和 __exit__closing()适用于 __exit__方法缺失的对象suppress()忽略指定异常"},"python/1.基本/1.1.基础语法/1.1.8.列表解析":{"slug":"python/1.基本/1.1.基础语法/1.1.8.列表解析","filePath":"python/1.基本/1.1.基础语法/1.1.8.列表解析.md","title":"1.1.8.列表解析","links":[],"tags":[],"content":"Python 列表解析（List Comprehension）详解\n1. 什么是列表解析？\n列表解析（List Comprehension） 是 Python 提供的一种简洁而高效的创建列表的方法。它可以在 一行代码 内完成列表的构建，通常比 for 循环更 简洁 和 高效。\n\n2. 基本语法\nnew_list = [表达式 for 变量 in 可迭代对象 if 条件]\n\n表达式：对变量进行计算、转换或过滤等操作。\n变量：用于从可迭代对象（如 list、range、tuple）中取出元素。\n可迭代对象：可以是列表、元组、字符串、range() 生成的序列等。\n条件（可选）：用于筛选满足条件的元素。\n\n\n3. 列表解析的基本示例\n3.1 生成一个平方列表\n普通 for 循环：\nsquares = []\nfor i in range(1, 6):\n    squares.append(i ** 2)\nprint(squares)  # 输出: [1, 4, 9, 16, 25]\n使用 列表解析：\nsquares = [i ** 2 for i in range(1, 6)]\nprint(squares)  # 输出: [1, 4, 9, 16, 25]\n列表解析使代码更 简洁，可读性更 强。\n\n4. 带条件的列表解析\n可以在列表解析中 添加条件 来过滤元素。\n4.1 过滤偶数\n普通 for 循环：\neven_numbers = []\nfor i in range(10):\n    if i % 2 == 0:\n        even_numbers.append(i)\nprint(even_numbers)  # 输出: [0, 2, 4, 6, 8]\n使用 列表解析：\neven_numbers = [i for i in range(10) if i % 2 == 0]\nprint(even_numbers)  # 输出: [0, 2, 4, 6, 8]\n\n5. 多重循环的列表解析\n如果有 嵌套循环，可以在列表解析中使用多个 for。\n5.1 笛卡尔积（两个列表的组合）\npairs = [(x, y) for x in range(1, 4) for y in range(3, 6)]\nprint(pairs)  # 输出: [(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)]\n这是 双层循环 的等价代码：\npairs = []\nfor x in range(1, 4):\n    for y in range(3, 6):\n        pairs.append((x, y))\nprint(pairs)\n\n6. 嵌套列表解析\n如果列表本身是一个嵌套结构（如二维数组），也可以使用列表解析来 扁平化 处理。\n6.1 扁平化二维列表\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\nprint(flattened)  # 输出: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n等价于：\nflattened = []\nfor row in matrix:\n    for num in row:\n        flattened.append(num)\nprint(flattened)\n\n7. 列表解析 + 函数\n7.1 使用 **map()** 进行转换\nwords = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]\nupper_words = [word.upper() for word in words]\nprint(upper_words)  # 输出: [&#039;HELLO&#039;, &#039;WORLD&#039;, &#039;PYTHON&#039;]\n等价于：\nupper_words = list(map(str.upper, words))\nprint(upper_words)\n7.2 计算列表中每个数的平方\nnums = [1, 2, 3, 4, 5]\nsquares = [x**2 for x in nums]\nprint(squares)  # 输出: [1, 4, 9, 16, 25]\n\n8. 列表解析 vs **for** 循环：性能比较\n列表解析 比普通 **for** 循环更快，因为 Python 在底层 优化了列表解析。\n8.1 计算 1~1000000 之间所有偶数\nimport time\n \n# 普通 for 循环\nstart = time.time()\neven_nums = []\nfor i in range(1, 1000000):\n    if i % 2 == 0:\n        even_nums.append(i)\nend = time.time()\nprint(f&quot;普通 for 耗时: {end - start:.5f} 秒&quot;)\n \n# 列表解析\nstart = time.time()\neven_nums = [i for i in range(1, 1000000) if i % 2 == 0]\nend = time.time()\nprint(f&quot;列表解析耗时: {end - start:.5f} 秒&quot;)\n结果：列表解析 比 **for** 循环快 2~5 倍！\n\n9. 列表解析的注意事项\n✅ 适用场景\n\n需要快速创建列表\n代码要求简洁清晰\n适用于简单的逻辑处理\n\n❌ 不适用场景\n\n逻辑复杂的情况：如嵌套 if-else 或过多 for，可读性变差\n对列表元素需要额外操作：如 print() 不能直接在列表解析中使用\n内存占用问题：列表解析会一次性生成整个列表，若数据量大，可能会占用大量内存。此时可以用 生成器表达式（() 代替 []）。\n\n\n10. 生成器表达式（更节省内存）\n如果列表 数据量特别大，可以用 生成器表达式（Generator Expression），只在需要时才计算每个元素，避免内存占用过大。\nnums = (x**2 for x in range(10))  # 注意使用的是 ()\nprint(next(nums))  # 0\nprint(next(nums))  # 1\nprint(list(nums))  # 剩余部分: [4, 9, 16, 25, 36, 49, 64, 81]\n\n总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor循环列表解析代码简洁❌ 需要多行代码✅ 一行搞定执行速度⏳ 较慢🚀 更快适用场景适用于复杂逻辑适用于简单逻辑内存占用⚠️ 可能较大⚠️ 适量（可用生成器优化）\n结论：\n\n列表解析适用于大多数情况，让代码更加 简洁 和 高效。\n复杂逻辑时仍推荐 **for** 循环，提高可读性。\n大数据量时考虑生成器表达式，减少内存开销。\n\n🚀 掌握列表解析，让你的 Python 代码更简洁高效！"},"python/1.基本/1.1.基础语法/1.1.9.异常处理":{"slug":"python/1.基本/1.1.基础语法/1.1.9.异常处理","filePath":"python/1.基本/1.1.基础语法/1.1.9.异常处理.md","title":"1.1.9.异常处理","links":[],"tags":[],"content":"Python 异常处理详解\n一、什么是异常？\n异常（Exception） 是指程序在运行过程中出现的错误情况。Python 在遇到异常时会中断程序执行，并输出错误信息（Traceback）。\n示例：\nprint(1 / 0)  # ZeroDivisionError: division by zero\n常见异常类型：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n异常类型说明ZeroDivisionError除数为零TypeError数据类型错误ValueError值错误（如 int(&quot;abc&quot;)）IndexError索引超出范围KeyError字典中键不存在FileNotFoundError文件未找到ImportError模块导入失败\n\n二、try-except 语句\n用于捕获并处理异常，防止程序异常中断。\n(1) 基本语法\ntry:\n    num = int(&quot;abc&quot;)\nexcept ValueError:\n    print(&quot;发生 ValueError 异常&quot;)\n输出：\n发生 ValueError 异常\n(2) 捕获多个异常\ntry:\n    x = 1 / 0\nexcept (ZeroDivisionError, ValueError) as e:\n    print(&quot;异常信息:&quot;, e)\n使用 as e 可获取异常对象。\n(3) 捕获所有异常\ntry:\n    x = 1 / 0\nexcept Exception as e:\n    print(&quot;发生异常:&quot;, e)\n⚠️ 注意： 不推荐滥用 except Exception:，以免屏蔽真实问题。\n\n三、else 与 finally 子句\n(1) else：无异常时执行\ntry:\n    x = 10 / 2\nexcept ZeroDivisionError:\n    print(&quot;除数不能为零&quot;)\nelse:\n    print(&quot;运算成功&quot;)\n(2) finally：无论是否发生异常均执行\ntry:\n    file = open(&quot;test.txt&quot;, &quot;r&quot;)\nexcept FileNotFoundError:\n    print(&quot;文件不存在&quot;)\nfinally:\n    print(&quot;执行 finally 语句&quot;)\n常用于资源清理（如关闭文件、断开数据库连接）。\n\n四、raise 抛出异常\n(1) 主动抛出异常\nage = -1\nif age &lt; 0:\n    raise ValueError(&quot;年龄不能是负数&quot;)\n(2) 重新抛出异常\ntry:\n    x = 1 / 0\nexcept ZeroDivisionError as e:\n    print(&quot;捕获异常:&quot;, e)\n    raise\n\n五、自定义异常\n通过继承 Exception 类定义自定义异常类型。\nclass MyError(Exception):\n    def __init__(self, message):\n        super().__init__(message)\n \ndef check_age(age):\n    if age &lt; 0:\n        raise MyError(&quot;年龄不能为负数&quot;)\n \ntry:\n    check_age(-1)\nexcept MyError as e:\n    print(&quot;自定义异常:&quot;, e)\n\n六、with 语句与异常处理\nwith 可自动管理资源，无需手动关闭，避免冗长的 try-finally。\ntry:\n    with open(&quot;test.txt&quot;, &quot;r&quot;) as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(&quot;文件未找到&quot;)\n\n七、assert 断言\n断言用于调试，条件为 False 时触发 AssertionError。\nx = -1\nassert x &gt;= 0, &quot;x 不能是负数&quot;\n⚠️ 注意：assert 通常用于开发阶段调试，生产环境中不建议使用。\n\n八、异常处理最佳实践\n✅ 建议做法：\n\n捕获具体异常，避免使用空 except\n使用 finally 释放资源\n使用 with 管理资源\n\n🚫 不建议做法：\ntry:\n    # 不推荐，仅做演示\n    1 / 0\nexcept:\n    print(&quot;出错了&quot;)  # 无法获取具体异常信息\n\n九、常见内置异常类型（分类详解）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n异常类型说明BaseException所有异常的基类Exception常规异常的基类ArithmeticError数学运算错误（如除零、溢出）OverflowError数值运算结果溢出ZeroDivisionError除以零错误IndexError序列索引超出范围KeyError字典键不存在TypeError操作或函数使用了错误的数据类型ValueError参数类型正确但值不合法FileNotFoundError打开文件失败，文件不存在IOError输入输出操作失败ImportError模块导入失败NameError使用了未声明的变量名AttributeError对象没有指定的属性MemoryError内存不足NotImplementedError方法未实现StopIteration迭代器无更多元素RecursionError递归层级过深KeyboardInterrupt用户中断程序（Ctrl+C）TimeoutError操作超时\n\n十、异常体系结构简图（部分）\nBaseException\n ├── SystemExit\n ├── KeyboardInterrupt\n ├── GeneratorExit\n └── Exception\n     ├── ArithmeticError\n     │    ├── OverflowError\n     │    └── ZeroDivisionError\n     ├── LookupError\n     │    ├── IndexError\n     │    └── KeyError\n     ├── FileNotFoundError\n     ├── ImportError\n     ├── NameError\n     └── ...\n\n十一、自定义异常继承结构\nclass MyCustomError(Exception):\n    pass\n \nraise MyCustomError(&quot;This is a custom exception!&quot;)\n\n十二、小结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n关键字功能说明try包裹可能引发异常的代码except捕获并处理异常else没有异常时执行finally无论是否异常都会执行（用于资源清理）raise主动抛出异常assert条件断言，用于调试with自动管理资源，简化异常处理"},"python/1.基本/1.2.面向对象/封装，继承，多态":{"slug":"python/1.基本/1.2.面向对象/封装，继承，多态","filePath":"python/1.基本/1.2.面向对象/封装，继承，多态.md","title":"封装，继承，多态","links":[],"tags":[],"content":"面向对象三大特性详解\n\n一、封装（Encapsulation）\n1. 定义\n封装是指将数据（属性）和方法（行为）包装在一个类中，并通过访问控制隐藏内部的实现细节，仅对外提供必要的接口，以实现信息隐藏、提高安全性和可维护性。\n2. 访问控制符\n在 Python 中，虽然不像 C++ 或 Java 有严格的访问控制关键字（如 private、protected、public），但通过命名规范实现访问限制：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方式命名规则说明public无前缀默认公开，外部可直接访问protected单下划线开头 _表示“受保护”，不建议外部访问，但仍可访问private双下划线开头 __表示“私有”，会触发名称重整（Name Mangling），外部不可直接访问\n3. 示例代码\nclass Student:\n    def __init__(self, name, score):\n        self.name = name          # 公开属性\n        self._score = score       # 受保护属性\n        self.__id = 12345         # 私有属性\n \n    def get_id(self):\n        return self.__id          # 提供私有属性的访问接口\n \n    def set_score(self, score):\n        if 0 &lt;= score &lt;= 100:\n            self._score = score\n        else:\n            print(&quot;Invalid score!&quot;)\n \nstu = Student(&quot;Alice&quot;, 90)\nprint(stu.name)        # 可直接访问\nprint(stu._score)      # 虽能访问，但不推荐\n# print(stu.__id)      # 报错，不能直接访问私有属性\nprint(stu.get_id())    # 正确方式：通过方法访问私有属性\n\n二、继承（Inheritance）\n1. 定义\n继承是指子类可以继承父类的属性和方法，从而实现代码复用和功能扩展。继承有助于构建层次结构清晰、结构紧凑的系统。\n2. 语法格式\nclass 子类名(父类名):\n    pass\n3. 示例代码\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n \n    def speak(self):\n        print(f&quot;{self.name} makes a sound.&quot;)\n \nclass Dog(Animal):\n    def speak(self):\n        print(f&quot;{self.name} barks.&quot;)\n \nclass Cat(Animal):\n    def speak(self):\n        print(f&quot;{self.name} meows.&quot;)\n \ndog = Dog(&quot;Buddy&quot;)\ncat = Cat(&quot;Kitty&quot;)\n \ndog.speak()  # 输出：Buddy barks.\ncat.speak()  # 输出：Kitty meows.\n4. 使用 super() 调用父类方法\nsuper() 用于调用父类的构造方法或其他方法，避免重复编写父类逻辑。\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # 调用父类构造函数\n        self.breed = breed\n\n三、多态（Polymorphism）\n1. 定义\n多态指的是相同的方法名在不同类的对象中表现出不同的行为。这体现了“对接口编程，而非对实现编程”的思想，有助于提升程序的灵活性与扩展性。\n2. 示例代码\ndef animal_speak(animal):\n    animal.speak()\n \nanimal_speak(Dog(&quot;Rex&quot;))   # 输出：Rex barks.\nanimal_speak(Cat(&quot;Luna&quot;))  # 输出：Luna meows.\n说明：animal_speak() 不关心具体对象类型，只要其实现了 .speak() 方法即可，符合“鸭子类型”（Duck Typing）原则。\n\n四、三大特性总结对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性说明作用封装隐藏内部实现，仅暴露必要接口提高安全性，降低模块间耦合继承子类复用父类属性和方法代码复用、结构清晰多态同一接口作用于不同对象时表现不同行为灵活性强，利于扩展"},"python/1.基本/1.2.面向对象/类与对象":{"slug":"python/1.基本/1.2.面向对象/类与对象","filePath":"python/1.基本/1.2.面向对象/类与对象.md","title":"类与对象","links":[],"tags":[],"content":"类与对象\n在 Python 中，**类（Class）与对象（Object）**是面向对象编程（OOP, Object-Oriented Programming）的核心概念。通过类与对象，Python 允许程序员以更模块化、更抽象、更可维护的方式组织代码。以下将从基本概念、语法结构、关键特性等方面进行系统性讲解。\n\n一、基本概念\n\n类（Class）：一种自定义的数据类型，是创建对象的模板或蓝图。类中定义了对象的属性（字段）和行为（方法）。\n对象（Object）：类的实例，表示通过类创建的实际存在的实体。每个对象具有类定义的属性和方法，但属性的具体值可能不同。\n\n\n二、类的定义与对象的创建\n1. 定义类\nclass Person:\n    def __init__(self, name, age):\n        self.name = name  # 实例变量\n        self.age = age    # 实例变量\n \n    def greet(self):\n        print(f&quot;你好，我是{self.name}，今年{self.age}岁。&quot;)\n2. 创建对象并调用方法\np1 = Person(&quot;张三&quot;, 18)\np1.greet()  # 输出：你好，我是张三，今年18岁。\n\n三、构造方法 __init__\n\n__init__() 是类的构造方法，用于初始化新创建对象的属性。\n在创建对象时由解释器自动调用。\n第一个参数 self 代表当前对象本身，必须在定义实例方法时显式声明。\n\n示例：\nclass Car:\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n\n四、实例变量与类变量\n1. 实例变量（每个对象独有）\nclass Dog:\n    def __init__(self, name):\n        self.name = name  # 每个对象有独立的 name\n2. 类变量（所有对象共享）\nclass Dog:\n    species = &quot;Canine&quot;  # 类变量\n \n    def __init__(self, name):\n        self.name = name\n \nd1 = Dog(&quot;小黑&quot;)\nd2 = Dog(&quot;小白&quot;)\nprint(d1.species)  # Canine\nprint(d2.species)  # Canine\n类变量适用于不随对象变化的公共属性。\n\n五、方法的类型\n1. 实例方法（最常见，操作实例属性）\nclass Cat:\n    def __init__(self, name):\n        self.name = name\n \n    def speak(self):\n        print(f&quot;{self.name} 喵喵叫。&quot;)\n2. 类方法（使用 @classmethod 装饰，操作类变量）\nclass Example:\n    count = 0\n \n    @classmethod\n    def increment_count(cls):\n        cls.count += 1\n3. 静态方法（使用 @staticmethod 装饰，无需访问类或实例）\nclass Math:\n    @staticmethod\n    def add(a, b):\n        return a + b\n \nprint(Math.add(3, 4))  # 输出：7\n\n六、继承（Inheritance）\n继承使得一个类（子类）可以继承另一个类（父类）的属性和方法，提高了代码的复用性。\nclass Animal:\n    def speak(self):\n        print(&quot;动物发出声音&quot;)\n \nclass Cat(Animal):\n    def speak(self):\n        print(&quot;喵喵叫&quot;)\n \nc = Cat()\nc.speak()  # 输出：喵喵叫（方法重写）\nPython 支持多重继承，若涉及多个父类，需注意方法解析顺序（MRO, Method Resolution Order）。\n\n七、封装（Encapsulation）\n封装是一种将对象的状态信息隐藏起来的机制，通过访问控制防止外部直接访问对象内部的细节。\nclass Student:\n    def __init__(self, name):\n        self.__name = name  # 私有属性（双下划线）\n \n    def get_name(self):\n        return self.__name\nPython 并不支持严格意义上的私有变量，__name 实际上会被转换为 _Student__name，从而达到”弱私有”的目的。\n\n八、多态（Polymorphism）\n多态指不同类的对象可以通过统一接口调用各自实现的方法。\nclass Bird:\n    def fly(self):\n        print(&quot;鸟在飞&quot;)\n \nclass Airplane:\n    def fly(self):\n        print(&quot;飞机在飞&quot;)\n \ndef let_it_fly(thing):\n    thing.fly()\n \nlet_it_fly(Bird())      # 鸟在飞\nlet_it_fly(Airplane())  # 飞机在飞\n多态提升了代码的扩展性与可维护性，尤其在大型系统中表现明显。\n\n九、特殊方法（魔法方法）\nPython 中，类可通过定义特殊方法（以双下划线包裹）来自定义特定行为。这些方法通常由系统自动调用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法名说明__init__构造方法，初始化对象__str__定义对象的字符串表示__len__实现内置函数 len(obj)__getitem__使对象支持索引访问 obj[key]__iter__使对象可迭代\n示例：\nclass Book:\n    def __init__(self, title):\n        self.title = title\n \n    def __str__(self):\n        return f&quot;《{self.title}》&quot;\n \nb = Book(&quot;Python编程&quot;)\nprint(b)  # 输出： 《Python编程》\n\n十、小结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称含义类（Class）模板、蓝图，定义对象的属性与方法对象（Object）类的实例，具有实际的数据与行为属性储存对象状态的信息，可分为类属性与实例属性方法对象可以执行的操作，分为实例方法、类方法、静态方法封装控制数据访问权限，保护对象内部状态继承通过父类共享代码，增强复用性多态接口统一但实现多样，提升灵活性与可扩展性特殊方法通过定义内置函数对应行为，增强类的表现力"},"python/1.基本/1.2.面向对象/魔法方法":{"slug":"python/1.基本/1.2.面向对象/魔法方法","filePath":"python/1.基本/1.2.面向对象/魔法方法.md","title":"魔法方法","links":[],"tags":[],"content":"魔法方法（Magic Methods）详解\n在 Python 中，魔法方法（Magic Methods），也称为 特殊方法（Special Methods）或双下划线方法（Dunder Methods），是具有特殊命名规则（以双下划线 __ 开头和结尾）的一类方法，如 __init__、__str__、__len__ 等。\n这类方法并非由开发者显式调用，而是由 Python 解释器在特定情境下自动触发，用于实现类的特殊行为，包括但不限于对象创建、运算符重载、容器协议、上下文管理等。\n\n一、对象创建与销毁相关\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法描述__new__(cls, ...)类实例创建之前被调用，返回实例对象。用于定制不可变类型（如 str、tuple）的子类行为。__init__(self, ...)实例创建后被自动调用，用于初始化对象的属性。__del__(self)析构方法，当对象被垃圾回收前触发（不推荐依赖其实现资源释放，建议使用 with语句或手动关闭资源）。\n\n二、字符串与对象表示相关\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法描述__str__(self)定义 str(obj)或 print(obj)时的输出内容，应返回可读性强的字符串。__repr__(self)定义 repr(obj)或在交互式环境中显示对象时的内容，应返回合法、准确的表达式字符串。\n建议：若类只实现 __repr__()，也可通过 __str__ = __repr__ 让两者行为一致。\n\n三、运算符重载相关\nPython 支持通过魔法方法自定义类的运算符行为，包括算术运算、比较运算等。\n1. 算术运算符重载\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法对应运算符说明__add__(self, other)+加法__sub__(self, other)-减法__mul__(self, other)*乘法__truediv__(self, other)/真除法__floordiv__(self, other)//地板除法__mod__(self, other)%取模__pow__(self, other)**幂运算\n还可定义右操作符（如 __radd__）和原地操作符（如 __iadd__）以处理不同类型或对象赋值场景。\n2. 比较运算符重载\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法对应操作符说明__eq__(self, other)==相等比较__ne__(self, other)!=不等比较__lt__(self, other)&lt;小于__le__(self, other)&lt;=小于等于__gt__(self, other)&gt;大于__ge__(self, other)&gt;=大于等于\n\n四、容器协议相关（模拟序列、映射等）\n使自定义类支持下标访问、迭代、成员检测等容器行为。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__len__(self)返回对象长度，供 len()使用__getitem__(self, key)获取值 obj[key]__setitem__(self, key, value)设置值 obj[key] = value__delitem__(self, key)删除值 del obj[key]__contains__(self, item)支持 item in obj成员判断__iter__(self)返回迭代器，供 iter(obj)使用__next__(self)支持迭代器的 next()调用\n\n五、上下文管理协议（用于 with 语句）\n支持类以上下文管理器形式使用，实现资源自动管理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__enter__(self)with块开始时调用，返回资源或上下文对象__exit__(self, exc_type, exc_val, exc_tb)with块结束时调用，处理异常与资源清理\n示例：\nclass MyResource:\n    def __enter__(self):\n        print(&quot;资源开启&quot;)\n        return self\n \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(&quot;资源释放&quot;)\n \nwith MyResource():\n    print(&quot;处理中...&quot;)\n\n六、可调用对象\n使实例行为类似函数（可使用括号调用）。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__call__(self, *args, **kwargs)允许实例像函数一样被调用，如 obj(...)\n\n七、属性访问控制\n自定义属性的获取、设置、删除逻辑。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__getattr__(self, name)访问不存在的属性时调用__getattribute__(self, name)所有属性访问时调用（容易导致无限递归，使用需谨慎）__setattr__(self, name, value)设置属性时调用__delattr__(self, name)删除属性时调用\n\n八、类的类型检查行为（用于定制 isinstance 和 issubclass）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__instancecheck__(self, instance)自定义 isinstance()判断逻辑（通常在元类中使用）__subclasscheck__(self, subclass)自定义 issubclass()判断逻辑\n\n九、自定义元类中的魔法方法\n元类是创建类的“类”，常用于框架或高级抽象。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n方法功能__new__(metacls, name, bases, namespace)控制类对象的创建过程__init__(cls, name, bases, namespace)类对象创建完成后初始化\n\n十、实用示例：自定义一个向量类\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def __repr__(self):\n        return f&quot;Vector({self.x}, {self.y})&quot;\n \n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n \n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n \nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\nprint(v1 + v2)             # 输出：Vector(4, 6)\nprint(v1 == Vector(1, 2))  # 输出：True\n\n总结\n魔法方法为 Python 面向对象编程提供了强大的扩展能力。合理使用这些方法可以使自定义类表现得像内建类型一样自然、直观。然而，在重载行为时应避免滥用，确保语义一致性与可维护性，尤其在涉及元类与属性控制时应更加谨慎。\n如需进一步探索完整列表，可参考官方文档：\n🔗 docs.python.org/3/reference/datamodel.html#special-method-names"},"python/1.基本/1.3.数据结构与算法/数据结构":{"slug":"python/1.基本/1.3.数据结构与算法/数据结构","filePath":"python/1.基本/1.3.数据结构与算法/数据结构.md","title":"数据结构","links":[],"tags":[],"content":"Python 数据结构笔记\n\n一、序列类型（Sequence Types）\n1.1 列表（List）\n\n定义：一种有序、可变、允许重复元素的集合类型。\n语法：\n\nmy_list = [1, 2, 3]\n\n常用操作：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作类别方法/语法说明访问my_list[i]访问索引为 i的元素添加append(x)在末尾追加元素extend([a, b])扩展列表insert(i, x)在索引 i处插入元素删除remove(x)删除第一次出现的值pop([i])弹出指定位置元素，默认最后一个del my_list[i]删除指定索引元素排序与反转sort()就地排序sorted(my_list)返回新排序列表reverse()就地反转reversed(my_list)反转迭代器\n\n\n其他特性：\n\n\n切片操作：支持my_list[start:end:step]等灵活切片\n\n\n嵌套列表：允许嵌套存储，如 [[1, 2], [3, 4]]\n\n\n可变性：可修改单个元素，也可整体替换切片\n\n\n\n1.2 元组（Tuple）\n\n定义：一种有序、不可变、允许重复元素的序列类型。\n语法：\n\nmy_tuple = (1, 2, 3)\nsingle_element = (1,)  # 单元素元组必须加逗号\n\n\n用途：\n\n\n多值返回：return a, b\n\n\n字典键/集合元素（因其可哈希）\n\n\n表示结构化数据（如二维坐标）\n\n\n内置方法：\n\n\ncount(x)：返回元素 x 出现次数\n\n\nindex(x)：返回元素 x 首次出现的位置\n\n\n\n1.3 字符串（String）\n\n定义：一种有序、不可变的字符序列。\n语法：\n\ns = &quot;hello&quot;\n\n常用方法：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类别方法/语法说明分割/连接split(sep)分割字符串&#039;sep&#039;.join(seq)用分隔符连接序列查找/替换find(sub)返回首次出现的索引，未找到返回 -1replace(a, b)替换子串格式化输出f&quot;{var}&quot;, format()字符串插值\n\n\n其他特性：\n\n\n支持切片、索引访问\n\n\n支持常用字符方法如 upper(), lower(), strip(), startswith(), endswith()\n\n\n使用 len(s) 获取长度\n\n\n\n二、集合类型（Set Types）\n2.1 集合（Set）\n\n定义：一种无序、元素唯一的集合类型。\n语法：\n\nmy_set = {1, 2, 3}\nmy_set2 = set([1, 2, 3])\n\n常用操作：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作方法说明添加add(x)添加元素删除remove(x)删除元素，若不存在则抛异常discard(x)删除元素，若不存在不报错清空clear()清空集合\n\n集合运算：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算类型运算符方法并集a &amp;#124; ba.union(b)交集a &amp; ba.intersection(b)差集a - ba.difference(b)对称差集a ^ ba.symmetric_difference(b)\n\n可恶呀，为了避免冲突只能用 &amp;#124; 来代替 | 了。\n\n\n\n特点：\n\n\n自动去重\n\n\n不支持索引和切片\n\n\n常用于元素去重与集合关系计算\n\n\n\n2.2 冻结集合（frozenset）\n\n定义：一种不可变集合类型。\n语法：\n\nfs = frozenset([1, 2, 3])\n\n\n特点：\n\n\n不可变：不能添加或删除元素\n\n\n可用作字典键或集合元素\n\n\n支持所有集合间运算（如并、交、差）\n\n\n\n三、映射类型（Mapping Types）\n3.1 字典（Dict）\n\n定义：一种无序的键值对集合，键必须唯一且为不可变类型。\n语法：\n\nmy_dict = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}\n\n常用操作：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作方法/语法说明访问/修改my_dict[&quot;key&quot;]访问或更新值安全访问my_dict.get(&quot;key&quot;, default)避免抛出异常添加键值对my_dict[&quot;new&quot;] = val删除键值对del my_dict[&quot;key&quot;]弹出键值对pop(key)删除并返回该键的值\n\n遍历字典：\n\nfor key, value in my_dict.items():\n    print(key, value)\n\n\n其他方法：\n\n\nkeys(), values(), items(), update()\n\n\n特点：\n\n\n查询效率高（哈希表实现）\n\n\n键不可变，如字符串、元组等\n\n\n\n四、其他常见结构\n4.1 栈（Stack）\n\n实现方式：使用 list 实现\n操作：\n\nstack = []\nstack.append(x)   # 入栈\nx = stack.pop()   # 出栈\n\n\n特点：\n\n\n后进先出（LIFO）\n\n\n可用于函数调用、表达式求值、撤销操作等\n\n\n\n4.2 队列（Queue）\n\n推荐实现：collections.deque\n操作示例：\n\nfrom collections import deque\nq = deque()\nq.append(1)      # 入队\nq.popleft()      # 出队\n\n\n特点：\n\n\n先进先出（FIFO）\n\n\ndeque 支持双端操作，效率优于 list 在两端插入/删除场景\n\n\n\n4.3 优先队列（Priority Queue）\n\n实现方式：使用 heapq 模块（最小堆实现）\n示例：\n\nimport heapq\nheap = []\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 1)\nx = heapq.heappop(heap)  # 弹出最小值\n\n\n特点：\n\n\n自动维护最小（或最大）元素在顶部\n\n\n操作复杂度为 O(log n)\n\n\n适用于调度系统、任务优先级控制等场景\n\n\n\n五、数据结构选择建议\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用场景推荐数据结构有序、可变集合list不可变有序序列tuple快速查找/键值存储dict无序唯一元素集合set不可变集合（可哈希）frozenset字符处理/文本分析str栈结构list高效队列/双端队列collections.deque优先队列heapq"},"python/1.基本/1.3.数据结构与算法/时间复杂度与空间复杂度":{"slug":"python/1.基本/1.3.数据结构与算法/时间复杂度与空间复杂度","filePath":"python/1.基本/1.3.数据结构与算法/时间复杂度与空间复杂度.md","title":"时间复杂度与空间复杂度","links":[],"tags":[],"content":"一、时间复杂度（Time Complexity）\n1.1 定义\n时间复杂度是衡量算法执行时间与输入规模之间增长关系的一种方式。它描述的是输入规模趋近于无穷大时，算法执行步骤的数量级。\n记作：\nT(n) = O(f(n))\n其中，n 表示输入规模，f(n) 表示算法在最坏或平均情况下执行步骤的数量级。\n1.2 常见时间复杂度及说明\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n复杂度名称示例说明O(1)常数时间访问数组某一元素与输入规模无关O(log n)对数时间二分查找每次将问题规模减半O(n)线性时间遍历数组每个元素处理一次O(n log n)线性对数快速排序、归并排序分治 + 合并过程O(n²)二次时间冒泡排序、选择排序双重嵌套循环O(2ⁿ)指数时间递归斐波那契、子集枚举输入稍大即不可接受O(n!)阶乘时间全排列问题（如旅行商问题）随 n 增长极快增长\n1.3 三种时间复杂度分析方式\n\n最坏情况（Worst Case）：算法执行时间的最大值。\n平均情况（Average Case）：所有输入情况下的加权平均执行时间。\n最好情况（Best Case）：执行时间最小的情况（一般用于补充说明）。\n\n例如：\n对于冒泡排序：\n\n最坏时间复杂度：O(n²)（完全逆序）\n最好时间复杂度：O(n)（已经有序）\n平均时间复杂度：O(n²)\n\n1.4 时间复杂度的分析原则\n\n忽略低阶项：如 T(n) = 3n² + 2n + 1 → O(n²)\n忽略常数系数：如 T(n) = 5n → O(n)\n只保留最高阶项\n\n\n二、空间复杂度（Space Complexity）\n2.1 定义\n空间复杂度是衡量算法在运行过程中临时占用的存储空间与输入规模的增长关系。\n记作：\nS(n) = O(f(n))\n表示输入规模为 n 时，算法运行过程中额外占用的内存空间数量级。\n2.2 空间组成\n程序总空间消耗通常由三部分构成：\n\n输入/输出空间：与算法本身无关，通常不计入。\n辅助变量空间：临时变量、栈帧、递归栈等。\n程序常量空间：编译时已确定，不随输入变化。\n\n2.3 常见空间复杂度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n复杂度示例说明O(1)选择排序、冒泡排序原地排序，无额外空间O(n)归并排序、计数排序使用额外数组O(log n)快速排序（递归栈）每次递归一层空间O(n²)二维表格、DP 动态规划需要 n × n 的二维数组\n例如：\n\n快速排序是原地排序，但递归调用栈可能使用 O(log n) 空间；\n归并排序需要一个与原数组等长的临时数组，因此空间复杂度为 O(n)。\n\n\n三、复杂度分析举例：快速排序 vs 冒泡排序\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性快速排序（Quick Sort）冒泡排序（Bubble Sort）时间复杂度（平均）O(n log n)O(n²)时间复杂度（最坏）O(n²)O(n²)空间复杂度O(log n)O(1)是否原地排序是是是否稳定否是\n\n四、总结：分析复杂度的步骤\n\n确认输入规模 n 的定义（数组长度、节点数、字符数等）。\n估算基本操作执行次数（如比较、交换）。\n找出影响执行次数的主要因素（是否有循环、递归、分支）。\n根据增长趋势选择对应的大 O 表达式。\n对于递归算法，可使用递归树法或主定理进行分析。\n"},"python/1.基本/1.3.数据结构与算法/算法基础":{"slug":"python/1.基本/1.3.数据结构与算法/算法基础","filePath":"python/1.基本/1.3.数据结构与算法/算法基础.md","title":"算法基础","links":[],"tags":[],"content":"一、排序算法（Sorting Algorithms）\n排序的目标是将一组无序元素按照某种规则（通常是从小到大）进行重新排列，以便于数据处理与查找操作的效率提升。\n\n1. 冒泡排序（Bubble Sort）\n【基本思想】\n通过多次遍历，比较相邻元素并交换不符合顺序的对，将较大元素逐步“冒泡”至数组末尾。\n【算法步骤】\n\n比较相邻两个元素；\n若前者大于后者，则交换；\n每轮遍历后将当前最大值“沉”到末尾；\n重复上述步骤，共需进行 n−1 轮；\n若某轮未发生交换，说明已排序完成，可提前终止。\n\n【时间复杂度】\n\n最好情况（已排序）：O(n)\n平均情况：O(n²)\n最坏情况：O(n²)\n\n【空间复杂度】 O(1)【稳定性】 稳定排序\n【Python 示例】\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - 1 - i):\n            if arr[j] &gt; arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n\n2. 选择排序（Selection Sort）\n【基本思想】\n每轮从未排序部分选出最小元素，放到已排序序列末尾。\n【算法步骤】\n\n设定当前位置；\n在未排序部分找到最小值的索引；\n与当前位置元素交换；\n重复上述过程，直到数组排序完成。\n\n【时间复杂度】\n\n最好情况：O(n²)\n平均情况：O(n²)\n最坏情况：O(n²)\n\n【空间复杂度】 O(1)【稳定性】 不稳定排序（交换可能打乱相同元素顺序）\n【Python 示例】\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i+1, n):\n            if arr[j] &lt; arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n\n3. 插入排序（Insertion Sort）\n【基本思想】\n每次将一个元素插入到已排好序的部分中，使该部分始终保持有序。\n【算法步骤】\n\n从第二个元素开始，向前比较；\n若比前一元素小，则将前一元素右移；\n重复，直到找到合适位置；\n插入当前元素；\n重复上述过程直至数组尾部。\n\n【时间复杂度】\n\n最好情况（已排序）：O(n)\n平均情况：O(n²)\n最坏情况：O(n²)\n\n【空间复杂度】 O(1)【稳定性】 稳定排序\n【Python 示例】\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j &gt;= 0 and arr[j] &gt; key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\n4. 快速排序（Quick Sort）\n【基本思想】\n采用分治策略，选一个基准元素，将数组分为左右两部分，左边小于基准，右边大于基准，然后递归排序子数组。\n【算法步骤】\n\n选择一个基准值（通常为首个元素）；\n将比基准小的元素放到左侧，大的放到右侧；\n对左右子数组递归执行快速排序；\n合并结果。\n\n【时间复杂度】\n\n最好情况：O(n log n)\n平均情况：O(n log n)\n最坏情况（已排序数组）：O(n²)\n\n【空间复杂度】 O(log n)（递归栈开销）【稳定性】 不稳定排序\n【Python 示例】\ndef quick_sort(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    pivot = arr[0]\n    left = [x for x in arr[1:] if x &lt;= pivot]\n    right = [x for x in arr[1:] if x &gt; pivot]\n    return quick_sort(left) + [pivot] + quick_sort(right)\n\n5. 其他常见排序算法简述\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n排序算法时间复杂度稳定性特点或适用场景归并排序O(n log n)是分治思想，适用于链表、大数据排序希尔排序O(n log n) ~ O(n²)否插入排序的改进版，效率较高堆排序O(n log n)否基于堆结构，适合大规模排序计数排序O(n + k)是适用于整数、小范围数据桶排序O(n + k)是适合数据分布均匀场景基数排序O(nk)是适合定长字符串或整数排序\n\n二、查找算法（Searching Algorithms）\n\n1. 顺序查找（Linear Search）\n【基本思想】\n从数组头部开始，逐个元素比较，直到找到目标或遍历结束。\n【时间复杂度】\n\n最好情况：O(1)\n最坏情况：O(n)\n\n【适用场景】 无序或数据量小的列表\n【Python 示例】\ndef linear_search(arr, target):\n    for i, val in enumerate(arr):\n        if val == target:\n            return i\n    return -1\n\n2. 二分查找（Binary Search）\n【基本思想】\n适用于已排序数组，通过反复折半查找目标元素，降低查找范围。\n【算法步骤】\n\n设置左右指针 left、right；\n取中间索引 mid；\n比较 arr[mid] 与目标值：\n\n\n相等则返回；\n小于则向右侧查找；\n大于则向左侧查找；\n\n\n重复直至找到或范围为空。\n\n【时间复杂度】\n\n最好情况：O(1)\n最坏/平均情况：O(log n)\n\n【适用场景】 升序有序数组\n【Python 示例】\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n三、算法性能总结对比表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n算法名称最好时间复杂度最坏时间复杂度平均时间复杂度空间复杂度稳定性适用场景描述冒泡排序O(n)O(n²)O(n²)O(1)是教学、数据量小选择排序O(n²)O(n²)O(n²)O(1)否简单实现、交换次数少插入排序O(n)O(n²)O(n²)O(1)是部分有序、小数据集快速排序O(n log n)O(n²)O(n log n)O(log n)否高效通用排序归并排序O(n log n)O(n log n)O(n log n)O(n)是链表、大数据排序堆排序O(n log n)O(n log n)O(n log n)O(1)否内部排序、内存敏感场景计数排序O(n + k)O(n + k)O(n + k)O(k)是整数、小范围数据二分查找O(1)O(log n)O(log n)O(1)——有序数组查找"},"python/2.常用库与工具/标准库与内置模块/其他常用模块/uuid":{"slug":"python/2.常用库与工具/标准库与内置模块/其他常用模块/uuid","filePath":"python/2.常用库与工具/标准库与内置模块/其他常用模块/uuid.md","title":"uuid","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/并发与多线程/asyncio":{"slug":"python/2.常用库与工具/标准库与内置模块/并发与多线程/asyncio","filePath":"python/2.常用库与工具/标准库与内置模块/并发与多线程/asyncio.md","title":"asyncio","links":[],"tags":[],"content":"Python asyncio 模块详解\nasyncio 是 Python 中用于编写并发代码的库，它使用 async/await 语法。asyncio 被用作各种 Python 异步框架的基础，提供了高性能的网络和 Web 服务器、数据库连接库、分布式任务队列等等。\nasyncio 非常适合 I/O 密集型任务和高层级的结构化网络代码。\n1. 什么是 asyncio？\nasyncio 是一个通过在单线程内管理多个“任务”（协程）来实现并发的库。它不使用多线程或多进程，而是依赖于一个事件循环 (Event Loop) 来协调这些任务的执行。当一个任务遇到 I/O 操作（例如等待网络响应或文件读写）时，事件循环会暂停该任务，并切换到另一个准备好运行的任务，而不是阻塞整个线程。\n核心组件：\n\n\n事件循环 (Event Loop):asyncio 的核心，负责调度和执行异步任务、处理 I/O 事件和回调。\n\n\n协程 (Coroutines): 使用 async def 定义的特殊函数。协程是可以暂停和恢复执行的函数。它们是 asyncio 中并发的基本单位。\n\n\n**async** 和 **await** 关键字:\n\n\nasync: 用于定义一个协程函数或异步生成器。\n\n\nawait: 用于暂停协程的执行，直到等待的异步操作完成。它只能在 async def 函数内部使用。\n\n\n任务 (Tasks): 用于调度协程在事件循环中并发执行。Task 对象是对协程的封装。\n\n\nFuture 对象: 一个特殊的低层级可等待对象，表示一个异步操作的最终结果。Task 是 Future 的一个子类。\n\n\n2. 为什么使用 asyncio？\n\n高并发性:asyncio 可以在单个线程中处理成千上万的并发连接，这对于需要处理大量并发 I/O 操作的应用程序（如 Web 服务器、聊天应用）非常有用。\nI/O 密集型任务优化: 对于那些大部分时间都在等待外部操作（如网络请求、数据库查询）完成的任务，asyncio 可以显著提高效率，因为它允许程序在等待期间执行其他任务。\n避免线程开销: 与多线程相比，asyncio 的协程切换开销更小，并且避免了线程同步带来的复杂性（如锁竞争、死锁）。\n清晰的异步代码:async/await 语法使得异步代码的编写和阅读更加直观，类似于同步代码的结构。\n\n3. asyncio 的核心概念与用法\n3.1. async 和 await\n这是 asyncio 的基石。\n\n**async def**: 定义一个协程函数。调用协程函数不会立即执行它，而是返回一个协程对象。\n**await**: 只能用在 async def 函数内部。await 后面通常跟一个可等待对象 (awaitable object)，例如另一个协程、一个 Task 或一个 Future。当解释器遇到 await 时，它会暂停当前协程的执行，让事件循环去处理其他任务，直到 await 等待的操作完成。\n\nimport asyncio\nimport time\n \nasync def say_after(delay, what):\n    await asyncio.sleep(delay)  # asyncio.sleep 是一个异步函数，模拟 I/O 操作\n    print(what)\n    return f&quot;{what} done&quot;\n \nasync def main():\n    print(f&quot;开始于 {time.strftime(&#039;%X&#039;)}&quot;)\n \n    # 调用协程函数返回一个协程对象\n    coro1 = say_after(1, &#039;hello&#039;)\n    coro2 = say_after(2, &#039;world&#039;)\n \n    # 使用 await 来执行协程并等待其完成\n    # 注意：直接 await 协程对象是可以的，但通常我们会用 Task 来并发执行\n    result1 = await coro1\n    result2 = await coro2\n    \n    print(result1)\n    print(result2)\n \n    print(f&quot;结束于 {time.strftime(&#039;%X&#039;)}&quot;)\n \n# Python 3.7+ 可以直接使用 asyncio.run()\nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n在上面的例子中，say_after(1, &#039;hello&#039;) 会先执行，await asyncio.sleep(1) 使其暂停1秒。然后 say_after(2, &#039;world&#039;) 会执行，await asyncio.sleep(2) 使其暂停2秒。因为是顺序 await，所以总耗时约3秒。\n3.2. 事件循环 (Event Loop)\n事件循环是 asyncio 应用的核心。它执行以下操作：\n\n运行异步任务和回调。\n执行网络 IO 操作。\n执行子进程。\n\n**asyncio.run()** (推荐方式): 在 Python 3.7 及更高版本中，asyncio.run(coroutine) 是运行顶层入口点协程（通常是 main 函数）的推荐方式。它负责获取事件循环、运行任务直到完成，并关闭事件循环。\n# (如上例所示)\n# if __name__ == &quot;__main__&quot;:\n#     asyncio.run(main())\n手动管理事件循环 (旧版或特定场景):\n# async def main():\n#     # ...\n#     pass\n \n# loop = asyncio.get_event_loop()\n# try:\n#     loop.run_until_complete(main())\n# finally:\n#     loop.close() # 不再需要手动关闭，asyncio.run() 会处理\n通常情况下，你不需要手动与事件循环交互，asyncio.run() 会为你处理大部分事情。\n3.3. 任务 (Tasks)\nTask 用于在事件循环中并发地调度协程。当你将一个协程包装成一个 Task 时，事件循环就可以管理它的执行。\n**asyncio.create_task()** (推荐方式): 在 Python 3.7 及更高版本中，使用 asyncio.create_task(coro) 来创建任务。\nimport asyncio\nimport time\n \nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n    return f&quot;{what} processed&quot;\n \nasync def main():\n    print(f&quot;开始于 {time.strftime(&#039;%X&#039;)}&quot;)\n \n    # 创建任务，任务会立即开始调度（但不是立即执行完毕）\n    task1 = asyncio.create_task(say_after(1, &#039;hello&#039;))\n    task2 = asyncio.create_task(say_after(2, &#039;world&#039;))\n \n    # 等待任务完成并获取结果\n    # await 会暂停 main 协程，直到 task1 完成\n    result1 = await task1 \n    print(f&quot;Task 1 返回: {result1}&quot;)\n    \n    # await 会暂停 main 协程，直到 task2 完成\n    result2 = await task2\n    print(f&quot;Task 2 返回: {result2}&quot;)\n \n    print(f&quot;结束于 {time.strftime(&#039;%X&#039;)}&quot;)\n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n在这个例子中，task1 和 task2 会并发执行。say_after(1, &#039;hello&#039;) 和 say_after(2, &#039;world&#039;) 会几乎同时开始。task1 在1秒后完成，task2 在2秒后完成。总耗时约2秒，而不是顺序执行的3秒。\n3.4. asyncio.gather()\nasyncio.gather(*aws, return_exceptions=False) 用于并发运行多个可等待对象（协程、任务或 Future）。它会等待所有提供的可等待对象完成后返回结果。\nimport asyncio\nimport time\n \nasync def factorial(name, number):\n    f = 1\n    for i in range(2, number + 1):\n        print(f&quot;Task {name}: 计算 factorial({i})...&quot;)\n        await asyncio.sleep(0.1) # 模拟耗时计算\n        f *= i\n    print(f&quot;Task {name}: factorial({number}) = {f}&quot;)\n    return f\n \nasync def main():\n    print(f&quot;开始于 {time.strftime(&#039;%X&#039;)}&quot;)\n    # 使用 gather 并发运行多个协程\n    # gather 会自动将协程包装成 Task\n    results = await asyncio.gather(\n        factorial(&quot;A&quot;, 2),\n        factorial(&quot;B&quot;, 3),\n        factorial(&quot;C&quot;, 4),\n    )\n    print(f&quot;所有任务完成于 {time.strftime(&#039;%X&#039;)}&quot;)\n    print(f&quot;结果: {results}&quot;) # results 是一个包含各协程返回值的列表\n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n```gather` 的结果是一个列表，包含了所有输入协程的返回值，顺序与输入顺序一致。如果 `return_exceptions=True`，则异常会作为结果返回，而不是引发。\n \n### 3.5. `asyncio.wait()`\n \n`asyncio.wait(aws, timeout=None, return_when=ALL_COMPLETED)` 是一个更低层级的函数，用于等待一组可等待对象完成。它返回两个 `Task`/`Future` 集合：已完成的和未完成的。\n \n* `return_when`:\n    * `asyncio.FIRST_COMPLETED`: 当任何一个可等待对象完成时返回。\n    * `asyncio.FIRST_EXCEPTION`: 当任何一个可等待对象引发异常时返回。如果没有异常，则行为类似 `ALL_COMPLETED`。\n    * `asyncio.ALL_COMPLETED`: (默认) 当所有可等待对象都完成时返回。\n \n```python\nimport asyncio\n \nasync def my_coro(delay, name):\n    await asyncio.sleep(delay)\n    print(f&quot;{name} 完成&quot;)\n    return f&quot;{name} result&quot;\n \nasync def main():\n    coros = [my_coro(1, &quot;Task 1&quot;), my_coro(3, &quot;Task 2&quot;), my_coro(0.5, &quot;Task 3&quot;)]\n    tasks = [asyncio.create_task(coro) for coro in coros]\n \n    # 等待所有任务完成\n    done, pending = await asyncio.wait(tasks)\n    \n    print(&quot;所有任务完成:&quot;)\n    for task in done:\n        print(f&quot; - {task.result()}&quot;) # 获取任务结果\n    \n    # 等待第一个任务完成\n    # tasks = [asyncio.create_task(coro) for coro in coros] # 重新创建，因为之前的已完成\n    # done_first, pending_first = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n    # print(&quot;\\n第一个完成的任务:&quot;)\n    # for task in done_first:\n    #     print(f&quot; - {task.result()}&quot;)\n    # for task in pending_first: # 取消未完成的任务\n    #     task.cancel()\n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n```gather` 通常比 `wait` 更易用，因为它直接返回结果列表。`wait` 提供了对已完成和未完成任务更细致的控制。\n \n### 3.6. Futures\n \n`Future` 对象代表一个最终会产生结果的异步操作。它是一个可等待对象。`Task` 是 `Future` 的一个子类，专门用于运行协程。\n \n通常你不需要直接创建 `Future` 对象，除非你在编写基于回调的底层代码并希望将其与 `async/await` 集成。\n \n```python\nimport asyncio\n \nasync def set_after(fut, delay, value):\n    await asyncio.sleep(delay)\n    fut.set_result(value) # 设置 Future 的结果\n \nasync def main():\n    loop = asyncio.get_running_loop() # Python 3.7+\n    fut = loop.create_future() # 创建一个 Future 对象\n \n    # 调度一个协程来设置 Future 的结果\n    asyncio.create_task(set_after(fut, 1, &#039;... Future 结果 ...&#039;))\n \n    print(&#039;等待 Future...&#039;)\n    result = await fut # 等待 Future 完成并获取结果\n    print(result)\n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n4. 高级特性 (简述)\n4.1. 同步原语 (Synchronization Primitives)\n当多个协程需要协调对共享资源的访问时，asyncio 提供了类似于 threading 模块的同步原语：\n\n**asyncio.Lock**: 互斥锁，一次只允许一个协程获取锁。\n**asyncio.Event**: 一个简单的事件标志，协程可以等待事件被设置，或者设置/清除事件。\n**asyncio.Condition**: 条件变量，允许一个或多个协程等待某个条件成立。\n**asyncio.Semaphore**: 信号量，控制对资源的并发访问数量。\n**asyncio.BoundedSemaphore**: 有界信号量，与 Semaphore 类似，但 release() 次数不能超过 acquire() 次数。\n\nimport asyncio\n \nlock = asyncio.Lock()\nshared_resource = 0\n \nasync def worker(worker_id):\n    global shared_resource\n    print(f&quot;Worker {worker_id} 尝试获取锁&quot;)\n    async with lock: # 自动获取和释放锁\n        print(f&quot;Worker {worker_id} 已获取锁&quot;)\n        current_val = shared_resource\n        await asyncio.sleep(0.1) # 模拟一些工作\n        shared_resource = current_val + 1\n        print(f&quot;Worker {worker_id} 释放锁, shared_resource = {shared_resource}&quot;)\n \nasync def main():\n    await asyncio.gather(*(worker(i) for i in range(5)))\n    print(f&quot;最终 shared_resource = {shared_resource}&quot;)\n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n4.2. 队列 (asyncio.Queue)\nasyncio.Queue 用于在协程之间安全地传递数据，实现了生产者-消费者模式。\n\nput(item): 将元素放入队列。如果队列已满，则阻塞直到有空间。\nget(): 从队列中获取元素。如果队列为空，则阻塞直到有元素。\ntask_done(): 表示之前 get() 的任务已完成。\njoin(): 阻塞直到队列中所有元素都被获取并处理（即每个 put() 都有对应的 task_done()）。\n\nimport asyncio\nimport random\n \nasync def producer(queue, n_items):\n    for i in range(n_items):\n        item = f&quot;项目-{i}&quot;\n        await asyncio.sleep(random.uniform(0.1, 0.5)) # 模拟生产耗时\n        await queue.put(item)\n        print(f&quot;生产者: 已生产 {item}&quot;)\n    await queue.put(None) # 发送结束信号\n \nasync def consumer(queue, consumer_id):\n    while True:\n        item = await queue.get()\n        if item is None: # 收到结束信号\n            queue.task_done() # 标记结束信号已处理\n            await queue.put(None) # 将结束信号传递给其他消费者 (如果需要)\n            print(f&quot;消费者 {consumer_id}: 收到结束信号, 退出&quot;)\n            break\n        print(f&quot;消费者 {consumer_id}: 正在处理 {item}&quot;)\n        await asyncio.sleep(random.uniform(0.2, 1.0)) # 模拟消费耗时\n        print(f&quot;消费者 {consumer_id}: 已处理 {item}&quot;)\n        queue.task_done()\n \nasync def main():\n    queue = asyncio.Queue(maxsize=5) # 设置队列最大容量\n    \n    producers = [asyncio.create_task(producer(queue, 10))]\n    consumers = [asyncio.create_task(consumer(queue, i)) for i in range(2)]\n \n    await asyncio.gather(*producers) # 等待生产者完成\n    print(&quot;所有生产者已完成生产。&quot;)\n    \n    await queue.join() # 等待所有队列中的项目被处理\n    print(&quot;所有项目已处理。消费者即将退出。&quot;)\n \n    # gather 消费者以确保它们都正确退出 (可选，因为 join 已经保证了任务完成)\n    await asyncio.gather(*consumers)\n \n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(main())\n4.3. 子进程 (asyncio.create_subprocess_exec, asyncio.create_subprocess_shell)\nasyncio 允许以异步方式运行和管理子进程。\n\ncreate_subprocess_exec(): 执行一个可执行文件。\ncreate_subprocess_shell(): 通过 shell 执行命令 (注意安全风险)。\n\nimport asyncio\n \nasync def run_command():\n    # 执行 &#039;ls -l&#039; 命令\n    # 注意：在 Windows 上，&#039;ls&#039; 不是标准命令，可以使用 &#039;dir&#039;\n    # 为了跨平台，这里用一个简单的 echo 示例\n    try:\n        # process = await asyncio.create_subprocess_exec(\n        #     &#039;ls&#039;, &#039;-l&#039;, &#039;/&#039;, # Unix/Linux/macOS\n        #     stdout=asyncio.subprocess.PIPE,\n        #     stderr=asyncio.subprocess.PIPE\n        # )\n        \n        # 更跨平台的示例\n        process = await asyncio.create_subprocess_exec(\n            &#039;python&#039;, &#039;-c&#039;, &#039;import time; time.sleep(1); print(&quot;来自子进程的输出&quot;)&#039;,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n \n        stdout, stderr = await process.communicate() # 等待子进程完成\n \n        if stdout:\n            print(f&quot;[标准输出]:\\n{stdout.decode()}&quot;)\n        if stderr:\n            print(f&quot;[标准错误]:\\n{stderr.decode()}&quot;)\n        \n        print(f&quot;子进程退出码: {process.returncode}&quot;)\n \n    except FileNotFoundError:\n        print(&quot;错误: 命令未找到。请确保命令在您的 PATH 中，或提供完整路径。&quot;)\n    except Exception as e:\n        print(f&quot;运行命令时发生错误: {e}&quot;)\n \n \nif __name__ == &quot;__main__&quot;:\n    asyncio.run(run_command())\n4.4. 流 (Streams)\nStreams API 用于处理网络连接 (TCP, UDP, SSL/TLS, etc.)。它提供了高层级的 async/await 接口来发送和接收数据。\n\nasyncio.open_connection(host, port): 创建一个 TCP 连接，返回 (reader, writer) 对。\nasyncio.start_server(client_connected_cb, host, port): 启动一个 TCP 服务器。\n\nimport asyncio\n \nasync def handle_echo_client(reader, writer):\n    addr = writer.get_extra_info(&#039;peername&#039;)\n    print(f&quot;收到来自 {addr} 的连接&quot;)\n \n    while True:\n        data = await reader.read(100) # 读取最多100字节\n        if not data: # 连接关闭\n            break\n        \n        message = data.decode()\n        print(f&quot;从 {addr} 收到: {message!r}&quot;)\n        \n        writer.write(data) # 回显数据\n        await writer.drain() # 等待写入缓冲区清空\n \n    print(f&quot;关闭来自 {addr} 的连接&quot;)\n    writer.close()\n    await writer.wait_closed() # Python 3.7+\n \nasync def main_server():\n    server = await asyncio.start_server(\n        handle_echo_client, &#039;127.0.0.1&#039;, 8888)\n \n    addr = server.sockets[0].getsockname()\n    print(f&#039;服务器正在监听 {addr}&#039;)\n \n    async with server: # 确保服务器正确关闭\n        await server.serve_forever()\n \n# 客户端示例 (可以单独运行或集成)\nasync def tcp_echo_client(message):\n    try:\n        reader, writer = await asyncio.open_connection(&#039;127.0.0.1&#039;, 8888)\n        print(f&#039;发送: {message!r}&#039;)\n        writer.write(message.encode())\n        await writer.drain()\n \n        data = await reader.read(100)\n        print(f&#039;收到: {data.decode()!r}&#039;)\n \n        print(&#039;关闭连接&#039;)\n        writer.close()\n        await writer.wait_closed()\n    except ConnectionRefusedError:\n        print(&quot;连接被拒绝。请确保服务器正在运行。&quot;)\n \nif __name__ == &quot;__main__&quot;:\n    # 要运行服务器，取消注释下一行并注释掉客户端部分\n    # asyncio.run(main_server())\n    \n    # 要运行客户端示例 (需要服务器先运行)\n    asyncio.run(tcp_echo_client(&#039;你好, asyncio 服务器!&#039;))\n    asyncio.run(tcp_echo_client(&#039;这是第二条消息。&#039;))\n5. 常见陷阱与最佳实践\n\n\n不要在协程中调用阻塞的 I/O 操作: 标准的阻塞 I/O 函数（如 time.sleep(), requests.get(), 标准文件操作）会阻塞整个事件循环，使 asyncio 失去并发优势。\n\n\n解决方法: 使用 asyncio 提供的异步版本（如 asyncio.sleep()），或使用像 aiohttp (用于 HTTP 请求)、aiofiles (用于文件操作) 这样的异步库。对于无法避免的阻塞代码，可以使用 loop.run_in_executor() 将其放到单独的线程池中执行。\n\n\n正确处理任务异常: 如果一个 Task 抛出未处理的异常，且该异常没有被 await 该任务的代码捕获，它可能会在任务被垃圾回收时打印出来，或者在某些情况下导致程序行为异常。\n\n\n解决方法: 始终 await 你创建的任务，或使用 asyncio.gather(..., return_exceptions=True)，并检查结果。或者为任务添加 done_callback 来处理异常。\n\n\n理解 **asyncio.run()** 与手动循环管理:asyncio.run() 是启动和关闭 asyncio 程序的首选方式。它会自动处理事件循环的创建和销毁。避免在 asyncio.run() 调用的协程内部再次调用 asyncio.run()。\n\n\n取消任务 (Cancellation): 任务可以被取消。被取消的任务会在其 await 点抛出 asyncio.CancelledError。协程应该捕获此异常以执行清理操作。\n\n\nasync def my_task():\n    try:\n        while True:\n            print(&quot;任务运行中...&quot;)\n            await asyncio.sleep(1)\n    except asyncio.CancelledError:\n        print(&quot;任务被取消，正在清理...&quot;)\n        # 执行清理操作\n        raise # 重新抛出 CancelledError 很重要\n \n# task = asyncio.create_task(my_task())\n# await asyncio.sleep(3)\n# task.cancel()\n# try:\n#     await task\n# except asyncio.CancelledError:\n#     print(&quot;主协程捕获到任务取消&quot;)\n\n\n合理使用 **gather** vs **wait**:\n\n\ngather: 当你需要所有任务的结果，并且希望它们并发执行时，gather 通常更方便。\n\n\nwait: 当你需要更细粒度的控制，例如等待第一个任务完成或出现第一个异常时，wait 更合适。\n\n\n6. 何时使用 asyncio (以及何时不使用)\n适合使用 **asyncio** 的场景:\n\nI/O 密集型应用: 网络服务器、Web Scrapers、数据库客户端、消息队列等，这些应用花费大量时间等待网络或磁盘 I/O。\n高并发需求: 需要同时处理大量连接或请求的应用。\n需要与其他异步库集成: 许多现代 Python 库都支持 asyncio。\n\n可能不适合或需要谨慎使用 **asyncio** 的场景:\n\nCPU 密集型任务: 对于主要由计算而非 I/O 限制的任务，asyncio 的单线程模型可能无法提供性能优势。在这种情况下，多进程 (multiprocessing 模块) 通常是更好的选择，因为它能利用多核 CPU。\n项目中已有大量同步阻塞代码: 将现有的大型同步项目转换为异步可能非常耗时且容易出错。可以考虑逐步引入，或使用 run_in_executor 桥接。\n简单的脚本或任务: 对于不需要高并发的简单脚本，引入 asyncio 的复杂性可能没有必要。\n\n总结\nasyncio 是 Python 中一个强大且灵活的库，用于构建高性能的并发应用程序。通过 async/await 语法，它提供了一种编写和维护异步代码的优雅方式。理解其核心概念，如事件循环、协程、任务和同步原语，对于有效地利用 asyncio 至关重要。虽然它主要针对 I/O 密集型任务，但通过与其他技术的结合（如多进程），也可以构建出复杂的混合型应用。"},"python/2.常用库与工具/标准库与内置模块/并发与多线程/concurrent.futures":{"slug":"python/2.常用库与工具/标准库与内置模块/并发与多线程/concurrent.futures","filePath":"python/2.常用库与工具/标准库与内置模块/并发与多线程/concurrent.futures.md","title":"concurrent.futures","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/并发与多线程/multiprocessing":{"slug":"python/2.常用库与工具/标准库与内置模块/并发与多线程/multiprocessing","filePath":"python/2.常用库与工具/标准库与内置模块/并发与多线程/multiprocessing.md","title":"multiprocessing","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/并发与多线程/threading":{"slug":"python/2.常用库与工具/标准库与内置模块/并发与多线程/threading","filePath":"python/2.常用库与工具/标准库与内置模块/并发与多线程/threading.md","title":"threading","links":[],"tags":[],"content":"Python threading 模块详解\nPython 的 threading 模块允许你创建和管理线程，以实现并发执行。并发是指在一段时间内，多个任务看起来像是在同时运行。这对于 I/O 密集型任务（比如网络请求、文件读写）特别有用，因为线程可以在等待 I/O 操作完成时释放处理器给其他线程使用。\n需要注意的是，由于全局解释器锁 (GIL) 的存在，Python 的多线程在 CPU 密集型任务上可能无法实现真正的并行执行（即在多核处理器上同时运行）。但对于 I/O 密集型任务，它仍然能显著提高效率。\nthreading 模块核心概念\n1. 线程 (Thread)\n线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以拥有多个线程，这些线程共享进程的内存空间（例如代码段、数据段），但每个线程有自己独立的栈空间和程序计数器。\n2. 创建线程\n在 Python 中，创建线程主要有两种方式：\n\n通过函数创建：将一个函数传递给 threading.Thread 类的构造函数。\n通过继承 **threading.Thread** 类：创建一个新的类，继承自 threading.Thread，并重写其 run() 方法。\n\n如何使用 threading 模块\n1. 导入模块\n首先，你需要导入 threading 模块，通常还会导入 time 模块用于演示：\nimport threading\nimport time\n2. 通过函数创建线程\n这是创建线程最常见和简单的方式。\ndef my_task(name, delay):\n    &quot;&quot;&quot;一个简单的任务函数&quot;&quot;&quot;\n    print(f&quot;线程 {name}：开始&quot;)\n    for i in range(3):\n        print(f&quot;线程 {name}：正在执行 - {i+1}/3&quot;)\n        time.sleep(delay)\n    print(f&quot;线程 {name}：结束&quot;)\n \n# 创建线程对象\n# target 参数指定线程要执行的函数\n# args 参数是一个元组，包含传递给 target 函数的位置参数\nthread1 = threading.Thread(target=my_task, args=(&quot;任务A&quot;, 1), name=&quot;Thread-A&quot;)\nthread2 = threading.Thread(target=my_task, args=(&quot;任务B&quot;, 1.5), name=&quot;Thread-B&quot;)\n \n# 也可以使用 kwargs 参数传递关键字参数\n# def my_task_kwargs(name, delay=1): ...\n# thread_kwargs = threading.Thread(target=my_task_kwargs, kwargs={&quot;name&quot;: &quot;任务C&quot;, &quot;delay&quot;: 0.5})\n \n \n# 启动线程\n# 调用 start() 方法后，线程会开始执行 target 函数中指定的逻辑\nprint(&quot;主线程：准备启动线程...&quot;)\nthread1.start()\nthread2.start()\n# thread_kwargs.start()\n \nprint(f&quot;主线程：当前活动线程数: {threading.active_count()}&quot;)\n \n# 等待所有线程完成 (可选，但通常是必要的)\n# join() 方法会阻塞主线程，直到被调用的线程执行完毕\n# 如果不调用 join()，主线程可能会在子线程完成前就结束了\nprint(&quot;主线程：等待子线程完成...&quot;)\nthread1.join() # 等待 thread1 完成\nthread2.join() # 等待 thread2 完成\n# thread_kwargs.join()\n \nprint(&quot;主线程：所有子线程执行完毕！&quot;)\n代码解释:\n\n\nthreading.Thread(target=your_function, args=(arg1, arg2,...), kwargs={&#039;key&#039;: &#039;value&#039;,...}, name=&quot;ThreadName&quot;):\n\n\ntarget: 指定线程要执行的函数。\n\n\nargs: 一个元组，包含按顺序传递给 target 函数的位置参数。如果只有一个参数，也要写成 (arg,) 的形式。\n\n\nkwargs: 一个字典，用于传递关键字参数给 target 函数。\n\n\nname: 给线程指定一个名字，方便调试。\n\n\nthread.start(): 启动线程，使其开始执行 target 函数中定义的逻辑。实际执行的是 **Thread** 类内部的机制，最终会调用我们指定的 **target** 函数，或者子类中重写的 **run** 方法。\n\n\nthread.join(timeout=None): 等待线程终止。\n\n\ntimeout: 可选参数，设置等待的最长时间（秒）。如果线程在该时间内未结束，join() 方法将返回。如果未提供 timeout 或为 None，则会一直等待直到线程结束。\n\n\n调用 join() 是很重要的，确保主程序在所有关键子线程完成它们的工作之后再继续或退出。\n\n\n3. 通过继承 threading.Thread 类创建线程\n当你的线程需要更复杂的逻辑或者需要维护自身的状态时，继承 threading.Thread 类会更方便。\nclass MyCustomThread(threading.Thread):\n    def __init__(self, name, delay, iterations=3):\n        super().__init__() # 或者 threading.Thread.__init__(self)\n        self.name = name # 设置线程名称，也可以在 super().__init__(name=name) 中设置\n        self.delay = delay\n        self.iterations = iterations\n        print(f&quot;线程 {self.name}：已创建&quot;)\n \n    def run(self):\n        &quot;&quot;&quot;线程执行的逻辑，必须重写此方法&quot;&quot;&quot;\n        print(f&quot;线程 {self.name} (ID: {self.ident})：开始执行 run 方法&quot;)\n        for i in range(self.iterations):\n            print(f&quot;线程 {self.name}：正在执行 - {i+1}/{self.iterations}&quot;)\n            time.sleep(self.delay)\n        print(f&quot;线程 {self.name}：结束 run 方法&quot;)\n \n# 创建线程对象\nthread3 = MyCustomThread(&quot;任务C&quot;, 0.8)\nthread4 = MyCustomThread(&quot;任务D&quot;, 1.2, iterations=2)\n \n# 启动线程\nprint(&quot;主线程：准备启动继承方式的线程...&quot;)\nthread3.start()\nthread4.start()\n \nprint(f&quot;主线程：当前活动线程数: {threading.active_count()}&quot;)\n \n# 等待所有线程完成\nprint(&quot;主线程：等待继承方式的子线程完成...&quot;)\nthread3.join()\nthread4.join()\n \nprint(&quot;主线程：所有继承方式的线程执行完毕！&quot;)\n代码解释:\n\nclass MyCustomThread(threading.Thread): 定义一个新类 MyCustomThread，继承自 threading.Thread。\nsuper().__init__(name=name): 必须调用父类的构造函数。可以通过 name 参数直接在父类构造函数中设置线程名。\ndef run(self): 重写 run() 方法。当调用线程的 start() 方法时，run() 方法中的代码会被执行。注意：直接调用 run() 方法 (my_thread_object.run()) 并不会启动新线程，而只是在当前线程中按顺序执行该方法。必须调用 my_thread_object.start() 才能在新线程中执行 run()。\n\n常用的 threading 模块函数和属性\n\nthreading.current_thread(): 返回当前的 Thread 对象。\nthreading.get_ident(): 返回当前线程的“线程标识符”。它是一个非零整数，在线程的生命周期内是唯一的。\nthreading.get_native_id(): (Python 3.8+) 返回内核分配给当前线程的原生集成线程 ID。这是一个非负整数。\nthreading.active_count(): 返回当前存活的 Thread 对象数量。这个计数等于 enumerate() 返回的列表长度。\nthreading.enumerate(): 返回当前所有存活的 Thread 对象列表。该列表包括守护线程、dummy 线程（由 threading 内部创建）以及主线程。它不包括已终止的线程和尚未启动的线程。\nthreading.main_thread(): (Python 3.4+) 返回主 Thread 对象。通常这是 Python 解释器启动时创建的线程。\n\n**Thread** 对象的属性和方法：\n\nthread.name 或 thread.getName() / thread.setName(name): 获取或设置线程的名称。直接访问 thread.name 更 Pythonic。\nthread.ident: 线程的标识符。如果线程尚未启动，则为 None；否则是一个非零整数。\nthread.native_id: (Python 3.8+) 线程的原生集成线程 ID。如果线程尚未启动或已终止，则为 None。\nthread.is_alive(): 判断线程是否存活（即已启动且尚未终止）。\nthread.daemon 或 thread.isDaemon() / thread.setDaemon(True): 获取或设置线程是否为守护线程。\n\ndef show_thread_info(message):\n    current = threading.current_thread()\n    print(f&quot;消息: {message}&quot;)\n    print(f&quot;  当前线程对象: {current}&quot;)\n    print(f&quot;  当前线程名称: {current.name}&quot;)\n    print(f&quot;  当前线程ID (ident): {current.ident}&quot;) # 或者 threading.get_ident()\n    if hasattr(current, &#039;native_id&#039;): # 检查属性是否存在以兼容旧版本\n        print(f&quot;  当前线程原生ID (native_id): {current.native_id}&quot;) # 或者 threading.get_native_id()\n    print(f&quot;  线程 {current.name} 是否存活: {current.is_alive()}&quot;)\n    print(f&quot;  线程 {current.name} 是否为守护线程: {current.daemon}&quot;)\n    print(&quot;-&quot; * 30)\n \nprint(&quot;--- 主线程信息 ---&quot;)\nshow_thread_info(&quot;在主线程中调用&quot;)\n \nprint(f&quot;主线程 - 当前活动线程数: {threading.active_count()}&quot;)\nprint(f&quot;主线程 - 当前所有线程: {threading.enumerate()}&quot;)\nprint(f&quot;主线程 - 主线程对象: {threading.main_thread()}&quot;)\nprint(&quot;-&quot; * 30)\n \n \nworker = threading.Thread(target=show_thread_info, args=(&quot;在工作线程中调用&quot;,), name=&quot;工作线程-1&quot;)\nworker.start()\nworker.join() # 等待 worker 完成，以便清晰地看到其输出\n \nprint(&quot;--- 主线程信息 (工作线程结束后) ---&quot;)\nshow_thread_info(&quot;在主线程中再次调用&quot;)\n守护线程 (Daemon Threads)\n守护线程是一种在后台运行的线程，当所有非守护线程结束时，守护线程会自动退出，即使它们的工作还没有完成。 这对于一些不重要的后台任务（如日志记录、心跳检测、垃圾回收等）很有用。\n\n通过 thread.daemon = True 或 thread.setDaemon(True) 将线程设置为守护线程。\n必须在 **thread.start()** 方法调用之前设置。一旦线程启动，就不能再更改其守护状态。\n主线程本身是一个非守护线程。\n\ndef daemon_task():\n    print(f&quot;守护线程 ({threading.current_thread().name})：开始&quot;)\n    count = 0\n    while True: # 守护线程通常执行一个循环任务\n        count += 1\n        print(f&quot;守护线程 ({threading.current_thread().name})：正在运行...计数 {count}&quot;)\n        time.sleep(1)\n        # 注意：如果主线程结束，这个打印可能不会完整执行或根本不执行\n    # print(f&quot;守护线程 ({threading.current_thread().name})：结束 (这句话通常不会被打印，因为主线程退出时它会被强制终止)&quot;)\n \ndaemon_thread = threading.Thread(target=daemon_task, name=&quot;守护者&quot;)\ndaemon_thread.daemon = True # 设置为守护线程\n# 或者 daemon_thread.setDaemon(True)\n \nprint(&quot;主线程：启动守护线程...&quot;)\ndaemon_thread.start()\n \nprint(&quot;主线程：等待3秒后主线程退出...&quot;)\ntime.sleep(3)\nprint(&quot;主线程：退出。守护线程将随之终止。&quot;)\n# 当主线程退出时，由于 daemon_thread 是守护线程，它也会被强制终止。\n# 如果 daemon_thread.daemon 设置为 False (默认值)，主线程会等待 daemon_thread 执行完毕（即无限循环）后才会退出。\n注意：由于守护线程会被突然终止，它们可能无法执行清理操作（如关闭文件、释放资源）。因此，对于需要确保完成的任务，不应使用守护线程。\n线程同步 (Synchronization Primitives)\n当多个线程共享数据时，可能会出现竞态条件 (race conditions)，导致数据不一致或程序崩溃。例如，两个线程同时尝试修改同一个变量，一个线程的修改可能会覆盖另一个线程的修改。threading 模块提供了一些同步原语来帮助管理对共享资源的访问，确保操作的原子性和顺序性。\n1. Lock (互斥锁)\nLock 是最简单和最基础的同步原语，也称为互斥锁。一个 Lock 有两种状态：“锁定 (locked)” 和 “未锁定 (unlocked)”。它保证了在任何时刻只有一个线程可以持有该锁，从而访问被保护的共享资源或代码段（称为临界区）。\n\n\nlock = threading.Lock(): 创建一个锁对象。\n\n\nacquire(blocking=True, timeout=-1): 获取锁。\n\n\n如果锁是未锁定的，则立即将其设置为锁定并返回 True。当前线程现在“拥有”这个锁。\n\n\n如果锁是锁定的（已被其他线程持有）：\n\n\n若 blocking 为 True (默认)，线程将被阻塞，直到锁被释放，然后该线程尝试获取锁。一旦获取成功，返回 True。\n\n\n若 blocking 为 False，线程不会阻塞，如果无法立即获取锁，则返回 False。\n\n\n若 timeout 是一个正数，线程将阻塞最多 timeout 秒。如果在该时间内获取了锁，返回 True；否则返回 False。\n\n\nrelease(): 释放锁。\n\n\n将锁的状态设置回未锁定。\n\n\n只有持有锁的线程才能释放它。 如果尝试释放一个未锁定的锁，或者由其他线程持有的锁，会引发 RuntimeError。\n\n\n通常使用 with 语句来自动管理锁的获取和释放，这更安全，可以避免忘记释放锁（特别是在发生异常时）：\nshared_resource = 0\nlock = threading.Lock() # 创建锁对象\n \ndef increment_resource_with_lock(count, thread_name):\n    global shared_resource\n    print(f&quot;线程 {thread_name}: 尝试获取锁...&quot;)\n    for _ in range(count):\n        # 写法一：手动 acquire 和 release (需要 try...finally 保证释放)\n        # lock.acquire()\n        # try:\n        #     # --- 临界区开始 ---\n        #     temp = shared_resource\n        #     time.sleep(0.001) # 模拟一些耗时操作，增加竞态条件发生的概率\n        #     shared_resource = temp + 1\n        #     # --- 临界区结束 ---\n        # finally:\n        #     lock.release()\n \n        # 写法二：使用 with 语句 (推荐)\n        with lock: # 自动调用 lock.acquire() 进入代码块，退出时自动调用 lock.release()\n            # print(f&quot;线程 {thread_name}: 已获取锁&quot;)\n            # --- 临界区开始 ---\n            temp = shared_resource\n            # 模拟CPU切换，使得其他线程有机会执行\n            # 如果没有锁，这里的 time.sleep 会让问题更明显\n            time.sleep(0.0001) # 减少睡眠时间以加快演示\n            shared_resource = temp + 1\n            # --- 临界区结束 ---\n            # print(f&quot;线程 {thread_name}: 已释放锁&quot;)\n    print(f&quot;线程 {thread_name}: 完成增加操作&quot;)\n \n \ndef increment_resource_without_lock(count, thread_name):\n    global shared_resource_no_lock\n    for _ in range(count):\n        temp = shared_resource_no_lock\n        time.sleep(0.0001)\n        shared_resource_no_lock = temp + 1\n \n# 测试有锁的情况\nthreads_with_lock = []\nnum_increments = 10000\nnum_threads = 5\nfor i in range(num_threads):\n    t = threading.Thread(target=increment_resource_with_lock, args=(num_increments, f&quot;LockThread-{i}&quot;))\n    threads_with_lock.append(t)\n    t.start()\n \nfor t in threads_with_lock:\n    t.join()\nprint(f&quot;最终的共享资源值 (使用Lock): {shared_resource}&quot;) # 应该是 num_threads * num_increments\n \n# 测试无锁的情况\nshared_resource_no_lock = 0\nthreads_without_lock = []\nfor i in range(num_threads):\n    t = threading.Thread(target=increment_resource_without_lock, args=(num_increments, f&quot;NoLockThread-{i}&quot;))\n    threads_without_lock.append(t)\n    t.start()\n \nfor t in threads_without_lock:\n    t.join()\nprint(f&quot;最终的共享资源值 (不使用Lock): {shared_resource_no_lock}&quot;) # 很可能小于 num_threads * num_increments\n如果不使用锁，shared_resource_no_lock 的最终值很可能小于期望值，因为多个线程可能同时读取了相同的 shared_resource_no_lock 值，然后各自加一，导致某些增加操作丢失（这就是典型的竞态条件）。\n2. RLock (可重入锁)\nRLock (Reentrant Lock) 是一种允许同一个线程多次获取的锁。如果一个线程已经拥有了 RLock，它可以再次调用 acquire() 而不会被阻塞。这在递归函数或者一个函数调用了另一个也需要相同锁的函数时非常有用。\n\nRLock 内部维护一个“拥有者线程”和一个“递归级别”计数器。\n当锁未被锁定时，任何线程都可以获取它，递归级别设为1，拥有者设为当前线程。\n当一个线程尝试获取一个已经被其他线程锁定的 RLock 时，它会阻塞。\n当拥有者线程再次调用 acquire() 时，递归级别加1，并立即返回。\n线程必须调用相应次数的 release() 来完全释放锁（即递归级别降为0），此时其他线程才能获取该锁。\n\nrlock = threading.RLock()\n \ndef recursive_function_with_rlock(depth, thread_name):\n    print(f&quot;线程 {thread_name}: 尝试获取 RLock (当前深度: {depth})&quot;)\n    with rlock: # 自动 acquire 和 release\n        print(f&quot;线程 {thread_name}: 已获取 RLock (当前深度: {depth}, 递归级别: {rlock._RLock__count if hasattr(rlock, &#039;_RLock__count&#039;) else &#039;N/A&#039;})&quot;) # _RLock__count 是内部属性，不建议直接访问\n        if depth &gt; 0:\n            time.sleep(0.1)\n            recursive_function_with_rlock(depth - 1, thread_name)\n        print(f&quot;线程 {thread_name}: 准备释放 RLock (当前深度: {depth})&quot;)\n    print(f&quot;线程 {thread_name}: 已释放 RLock (当前深度: {depth})&quot;)\n \n \n# 如果使用普通的 Lock 进行递归获取，第二次 acquire 会导致死锁\n# lock_for_recursion = threading.Lock()\n# def recursive_function_with_lock(depth, thread_name):\n#     print(f&quot;线程 {thread_name}: 尝试获取 Lock (当前深度: {depth})&quot;)\n#     with lock_for_recursion: # 第一次获取成功\n#         print(f&quot;线程 {thread_name}: 已获取 Lock (当前深度: {depth})&quot;)\n#         if depth &gt; 0:\n#             time.sleep(0.1)\n#             recursive_function_with_lock(depth - 1, thread_name) # 第二次获取会阻塞，因为锁已被当前线程持有但不可重入\n#         print(f&quot;线程 {thread_name}: 准备释放 Lock (当前深度: {depth})&quot;)\n#     print(f&quot;线程 {thread_name}: 已释放 Lock (当前深度: {depth})&quot;)\n \n \nthread_r1 = threading.Thread(target=recursive_function_with_rlock, args=(2, &quot;RLockUser-1&quot;))\n# thread_r_lock = threading.Thread(target=recursive_function_with_lock, args=(2,&quot;LockUser-1&quot;)) # 这会死锁\n \nthread_r1.start()\n# thread_r_lock.start()\n \nthread_r1.join()\n# thread_r_lock.join()\nprint(&quot;RLock 示例结束。&quot;)\n3. Semaphore (信号量)\n信号量是一个计数器，用于控制对共享资源的并发访问数量。它不是直接锁定资源，而是限制可以同时访问该资源的线程数量。当计数器大于零时，线程可以获取信号量（计数器减一）；当计数器为零时，线程必须等待，直到其他线程释放信号量（计数器加一）。\n\n\nthreading.Semaphore(value=1): 初始化一个信号量。value 是内部计数器的初始值。\n\n\n当 value 为 1 时，信号量的行为类似于 Lock (也称为二元信号量)。\n\n\n当 value 大于 1 时，允许多个线程并发访问（有界信号量）。\n\n\nacquire(blocking=True, timeout=None):\n\n\n如果内部计数器大于 0，则将其减 1 并立即返回 True。\n\n\n如果计数器为 0：\n\n\n若 blocking 为 True (默认)，线程阻塞，直到其他线程调用 release() 使计数器增加。\n\n\n阻塞和 timeout 行为与 Lock 类似。\n\n\nrelease(n=1):\n\n\n将内部计数器增加 n (默认为1)。这可能会唤醒正在等待信号量的其他线程。\n\n\n注意不要过度释放信号量，使其内部计数器超过初始值（除非这是特意设计的逻辑）。\n\n\nmax_concurrent_connections = 3 # 最多允许3个线程同时访问\nsemaphore = threading.Semaphore(value=max_concurrent_connections)\n \ndef access_limited_resource(thread_id):\n    print(f&quot;线程 {thread_id}: 尝试访问受限资源...&quot;)\n    with semaphore: # 自动 acquire 和 release\n        # 当进入 with 代码块时，如果信号量计数器 &gt; 0，则计数器减1，线程继续执行\n        # 如果计数器 == 0，线程阻塞，直到其他线程 release\n        print(f&quot;线程 {thread_id}: 已获取资源访问权限。当前活动数约: {max_concurrent_connections - semaphore._value if hasattr(semaphore, &#039;_value&#039;) else &#039;N/A&#039;}&quot;) # _value 是内部属性\n        time.sleep(2) # 模拟资源使用\n        print(f&quot;线程 {thread_id}: 完成资源访问，准备释放。&quot;)\n    # 当退出 with 代码块时，信号量计数器加1\n    print(f&quot;线程 {thread_id}: 已释放资源访问权限。&quot;)\n \ndb_access_threads = []\nfor i in range(7): # 创建7个线程，但最多只有3个能同时访问\n    t = threading.Thread(target=access_limited_resource, args=(i,))\n    db_access_threads.append(t)\n    t.start()\n    time.sleep(0.1) # 错开启动，方便观察\n \nfor t in db_access_threads:\n    t.join()\n \nprint(&quot;所有受限资源访问操作完成。&quot;)\n在这个例子中，虽然有7个线程尝试访问资源，但信号量确保了任何时候最多只有3个线程可以“持有”资源访问权限。\n4. Event (事件)\nEvent 对象是最简单的线程间通信机制之一。一个线程发出“事件”信号 (set)，其他一个或多个线程可以等待该事件 (wait)。事件对象内部维护一个标志，初始为 False。\n\n\nevent = threading.Event(): 创建一个事件对象。\n\n\nis_set(): 如果内部标志为 True，则返回 True，否则返回 False。\n\n\nset(): 将内部标志设置为 True，并唤醒所有因调用 wait() 而等待该事件的线程。\n\n\nclear(): 将内部标志重置为 False。之后调用 wait() 的线程将会阻塞。\n\n\nwait(timeout=None): 阻塞当前线程，直到内部标志为 True (即事件被 set())。\n\n\n如果调用 wait() 时内部标志已经是 True，则立即返回 True。\n\n\n如果设置了 timeout，则最多阻塞 timeout 秒。如果事件在该时间内被设置，则返回 True；否则返回 False (表示超时)。\n\n\nevent = threading.Event()\n \ndef waiter_task(name):\n    print(f&quot;等待者线程 ({name}): 等待事件...&quot;)\n    event_is_set = event.wait(timeout=5) # 阻塞直到 event.set() 被调用，或超时\n    if event_is_set:\n        print(f&quot;等待者线程 ({name}): 收到事件！可以继续工作了。内部标志: {event.is_set()}&quot;)\n    else:\n        print(f&quot;等待者线程 ({name}): 等待超时！内部标志: {event.is_set()}&quot;)\n \ndef setter_task():\n    print(&quot;设置者线程: 正在执行某些操作...&quot;)\n    time.sleep(2)\n    print(&quot;设置者线程: 操作完成，设置事件！&quot;)\n    event.set() # 设置事件标志为 True，唤醒所有等待者\n \n# 另一个场景：事件被清除\ndef waiter_then_clear_task():\n    print(&quot;等待并清除者: 等待事件...&quot;)\n    event.wait()\n    print(f&quot;等待并清除者: 收到事件！标志: {event.is_set()}&quot;)\n    time.sleep(0.5)\n    print(&quot;等待并清除者: 清除事件标志。&quot;)\n    event.clear()\n    print(f&quot;等待并清除者: 事件标志已清除。标志: {event.is_set()}&quot;)\n \n \nt_wait1 = threading.Thread(target=waiter_task, args=(&quot;W1&quot;,))\nt_wait2 = threading.Thread(target=waiter_task, args=(&quot;W2&quot;,))\nt_set = threading.Thread(target=setter_task)\n \nt_wait1.start()\nt_wait2.start()\ntime.sleep(0.1) # 确保等待者先开始等待\nt_set.start()\n \nt_wait1.join()\nt_wait2.join()\nt_set.join()\n \nprint(&quot;\\n--- 事件清除示例 ---&quot;)\nevent.clear() # 确保事件初始为 False\nt_wait_clear = threading.Thread(target=waiter_then_clear_task)\nt_set_again = threading.Thread(target=setter_task) # 复用 setter\n \nt_wait_clear.start()\ntime.sleep(0.1)\nt_set_again.start()\n \nt_wait_clear.join()\nt_set_again.join()\n \n# 演示 wait 超时\nevent.clear()\nprint(&quot;\\n--- 事件等待超时示例 ---&quot;)\nt_wait_timeout = threading.Thread(target=waiter_task, args=(&quot;W_Timeout&quot;,))\nt_wait_timeout.start()\nt_wait_timeout.join() # 主线程会等它超时\n \nprint(&quot;Event 示例结束。&quot;)\n5. Condition (条件变量)\nCondition 对象通常与一个锁（默认是 RLock）关联。它允许一个或多个线程等待，直到它们被另一个线程通知满足了某个“条件”。可以看作是更复杂的 Event，因为它总是与一个锁配合使用，允许线程在等待条件时安全地释放锁，并在被唤醒后重新获取锁。\n\n\ncondition = threading.Condition(lock=None):\n\n\n如果 lock 参数未提供或为 None，则会自动创建一个新的 RLock 对象。也可以传入一个已有的 Lock 或 RLock 对象。\n\n\nacquire(*args): 获取关联的锁。\n\n\nrelease(): 释放关联的锁。\n\n\nwait(timeout=None):\n\n\n\n必须在已经获取关联锁之后调用。\n释放关联的锁。\n阻塞当前线程，直到被同一个 Condition 对象的 notify() 或 notify_all() 唤醒，或者超时。\n一旦被唤醒（且没有超时），它会重新获取锁，然后 wait() 方法返回。返回值为 True，除非给定的 timeout 过期，这种情况下返回 False。\n\n\n\nnotify(n=1):\n\n\n必须在已经获取关联锁之后调用。\n\n\n唤醒最多 n 个正在等待此条件变量的线程。被唤醒的线程并不会立即返回它们的 wait() 调用，而是要等到它们能够重新获取锁之后才会返回。\n\n\n调用 notify() 后应尽快释放锁，以便被唤醒的线程可以获取锁。\n\n\nnotify_all():\n\n\n必须在已经获取关联锁之后调用。\n\n\n唤醒所有正在等待此条件变量的线程。行为与 notify() 类似。\n\n\nwait_for(predicate, timeout=None): (Python 3.2+)\n\n\n等待直到一个条件评估为真。predicate 应该是一个可调用对象，其结果被解释为一个布尔值。\n\n\ntimeout 与 wait() 中的一样。\n\n\n此方法会重复调用 wait() 直到 predicate() 为真，或者超时。返回 predicate 的最后一个返回值，如果超时则返回 False。\n\n\n典型的生产者-消费者模型：\ncondition = threading.Condition() # 默认使用 RLock\nitem_buffer = []\nbuffer_capacity = 3\n \ndef producer(items_to_produce):\n    print(&quot;生产者: 启动&quot;)\n    for i in range(items_to_produce):\n        with condition: # 获取锁\n            while len(item_buffer) == buffer_capacity: # 使用 while 循环检查条件（防止伪唤醒）\n                print(f&quot;生产者: 缓冲区已满 ({len(item_buffer)}/{buffer_capacity})，等待消费者...&quot;)\n                condition.wait() # 等待，自动释放锁；被唤醒后重新获取锁\n            \n            item = f&quot;物品-{i}&quot;\n            item_buffer.append(item)\n            print(f&quot;生产者: 生产了 {item} (缓冲区大小: {len(item_buffer)})&quot;)\n            condition.notify() # 通知一个等待的消费者 (如果只有一个消费者，notify() 足够)\n            # 如果有多个消费者，可能需要 condition.notify_all()，或者更精细的控制\n        time.sleep(0.5) # 模拟生产时间，在锁之外进行\n    \n    # 可选：生产完毕后发出特殊信号或多次通知以确保所有消费者退出\n    with condition:\n        print(&quot;生产者: 完成所有生产，发送最终通知&quot;)\n        # item_buffer.append(&quot;PRODUCER_DONE&quot;) # 一种标记方式\n        condition.notify_all()\n \n \ndef consumer(items_to_consume, consumer_id):\n    print(f&quot;消费者 {consumer_id}: 启动&quot;)\n    consumed_count = 0\n    while consumed_count &lt; items_to_consume :\n        with condition: # 获取锁\n            while not item_buffer: # 使用 while 循环检查条件\n                print(f&quot;消费者 {consumer_id}: 缓冲区为空，等待生产者...&quot;)\n                condition.wait(timeout=2) # 等待，如果2秒没等到通知，会超时返回False\n                if not item_buffer and consumed_count &lt; items_to_consume: # 再次检查，因为可能是超时唤醒\n                    print(f&quot;消费者 {consumer_id}: 等待超时或被唤醒但无物品，继续等待...&quot;)\n                    # 如果生产者已经完成，这里可能需要一个退出机制\n                    # if &quot;PRODUCER_DONE&quot; in item_buffer and not any(item != &quot;PRODUCER_DONE&quot; for item in item_buffer):\n                    #    break # 退出循环\n                    continue # 重新进入 while not item_buffer 检查\n                elif not item_buffer: # 如果生产者已完成且缓冲区空\n                    break\n \n            if not item_buffer: # 如果循环退出是因为缓冲区仍为空 (例如生产者已完成)\n                break\n \n            item = item_buffer.pop(0)\n            # if item == &quot;PRODUCER_DONE&quot;: # 处理结束标记\n            #     item_buffer.append(&quot;PRODUCER_DONE&quot;) # 放回去给其他消费者\n            #     break\n            \n            print(f&quot;消费者 {consumer_id}: 消费了 {item} (缓冲区大小: {len(item_buffer)})&quot;)\n            consumed_count += 1\n            condition.notify() # 通知一个等待的生产者（如果缓冲区之前是满的）\n        time.sleep(1) # 模拟消费时间，在锁之外进行\n    print(f&quot;消费者 {consumer_id}: 完成消费 {consumed_count} 个物品。&quot;)\n \n \ntotal_items = 7\nprod_thread = threading.Thread(target=producer, args=(total_items,))\ncons_thread1 = threading.Thread(target=consumer, args=(total_items // 2 + total_items % 2, &quot;C1&quot;)) # 消费多一点\ncons_thread2 = threading.Thread(target=consumer, args=(total_items // 2, &quot;C2&quot;))\n \nprod_thread.start()\ntime.sleep(0.1) # 让生产者先有机会生产一点\ncons_thread1.start()\ncons_thread2.start()\n \nprod_thread.join()\ncons_thread1.join()\ncons_thread2.join()\n \nprint(&quot;生产者消费者模型结束。&quot;)\n关键点：\n\nwait() 必须在 while 循环中调用，以防止“伪唤醒”（spurious wakeups）并确保在线程被唤醒后条件确实成立。\nnotify() 或 notify_all() 在修改了可能使其他线程等待的条件成立的状态后调用。\n\n6. Barrier (栅栏)\nBarrier 对象提供了一种简单的同步原语，用于让固定数量的线程彼此等待，直到所有线程都到达栅栏点（调用了 wait() 方法）。一旦所有线程都到达，它们会同时被释放。\n\n\nbarrier = threading.Barrier(parties, action=None, timeout=None):\n\n\nparties: 需要到达栅栏的线程数量。\n\n\naction: 一个可选的可调用对象。当所有线程都到达栅栏时，其中一个线程（任意选择）会在释放其他线程之前执行 action。如果此操作引发错误，栅栏将进入损坏状态 (broken=True)。\n\n\ntimeout: wait() 方法的默认超时时间。\n\n\nwait(timeout=None):\n\n\n线程调用此方法表示已到达栅栏。它会阻塞，直到 parties 个线程都调用了 wait()。\n\n\n当所有线程都到达时：\n\n\n如果提供了 action，其中一个线程会执行它。\n\n\n然后所有线程会被同时释放。\n\n\n返回值：对于执行 action 的那个线程（或者如果没有 action 就是任意一个被选中的线程），返回从 0 到 parties-1 的整数，代表它是第几个完成 action 并准备释放的线程（实际上是内部计数）。对其他线程则返回一个依赖于实现的值（通常是同一个整数，或者在Python 3.x早期版本可能是 None，但现在通常是该整数）。\n\n\n如果设置了 timeout 并且超时，或者栅栏在等待期间被 reset() 或 abort()，会引发 BrokenBarrierError。\n\n\nreset(): 将栅栏重置回其初始的、空的状态。任何正在等待的线程会收到 BrokenBarrierError。\n\n\nabort(): 使栅栏进入损坏状态。任何正在等待或之后调用 wait() 的线程会收到 BrokenBarrierError。\n\n\nparties: 到达栅栏所需的线程数量。\n\n\nn_waiting: 当前在栅栏处等待的线程数量。\n\n\nbroken: 如果栅栏处于损坏状态，则为 True。\n\n\nnum_participants = 3\nbarrier_action_message = &quot;&quot;\n \ndef barrier_action():\n    global barrier_action_message\n    barrier_action_message = f&quot;所有 {num_participants} 名参与者都已准备好，裁判 ({threading.current_thread().name}) 吹哨！&quot;\n    print(barrier_action_message)\n \nbarrier = threading.Barrier(num_participants, action=barrier_action, timeout=10) # 10秒超时\n \ndef participant_task(participant_id, preparation_time):\n    print(f&quot;参与者 {participant_id} ({threading.current_thread().name}): 正在准备...&quot;)\n    time.sleep(preparation_time)\n    print(f&quot;参与者 {participant_id} ({threading.current_thread().name}): 准备完毕，在起跑线等待。&quot;)\n    try:\n        wait_result_index = barrier.wait(timeout=5) # 等待其他参与者，覆盖默认超时\n        print(f&quot;参与者 {participant_id} ({threading.current_thread().name}): 通过栅栏！(索引: {wait_result_index})&quot;)\n    except threading.BrokenBarrierError:\n        print(f&quot;参与者 {participant_id} ({threading.current_thread().name}): 栅栏损坏，活动取消！&quot;)\n    except threading.TimeoutError: # Barrier.wait() 超时会引发 BrokenBarrierError，而不是 TimeoutError\n                                   # TimeoutError 是用于 Barrier 构造函数中的全局超时，但 wait 的超时也是 BrokenBarrierError\n        # 实际上，Barrier.wait() 超时会引发 BrokenBarrierError\n        print(f&quot;参与者 {participant_id} ({threading.current_thread().name}): 等待超时！(此分支通常不会因 wait 超时进入)&quot;)\n \n \nparticipant_threads = [\n    threading.Thread(target=participant_task, args=(1, 2), name=&quot;P1&quot;),\n    threading.Thread(target=participant_task, args=(2, 4), name=&quot;P2&quot;),\n    threading.Thread(target=participant_task, args=(3, 1), name=&quot;P3&quot;),\n]\n \n# 演示栅栏损坏的情况\n# barrier.abort() # 如果在启动前调用 abort，所有 wait 都会失败\n \nfor t in participant_threads:\n    t.start()\n \n# 演示中途 reset\n# time.sleep(1.5)\n# print(&quot;主线程：重置栅栏！&quot;)\n# barrier.reset() # 这会导致正在等待的线程抛出 BrokenBarrierError\n \nfor t in participant_threads:\n    t.join()\n \nif barrier.broken:\n    print(&quot;最终：栅栏已损坏。&quot;)\nelse:\n    print(f&quot;最终：活动完成。裁判消息: &#039;{barrier_action_message}&#039;&quot;)\nprint(&quot;Barrier 示例结束。&quot;)\n全局解释器锁 (GIL - Global Interpreter Lock)\nGIL 是 CPython 解释器（官方且最常用的 Python 解释器）中的一个互斥锁，它确保任何时候只有一个线程在执行 Python 字节码。\n\n\n影响:\n\n\n对于 CPU 密集型 任务 (例如大量计算、图像处理的纯 Python 实现)，多线程并不能利用多核处理器的优势来实现并行计算，因为 GIL 会阻止多个线程同时执行 Python 字节码。在这种情况下，使用 multiprocessing 模块（它使用多进程，每个进程有自己的 Python 解释器和 GIL）通常是更好的选择。\n\n\n对于 I/O 密集型 任务 (例如网络请求、文件读写、用户输入、数据库操作)，多线程仍然非常有效。当一个线程等待 I/O 操作时（这些操作通常由操作系统或底层 C 库执行，不涉及 Python 字节码），GIL 会被释放，允许其他 Python 线程运行。\n\n\n为什么存在 GIL?:\n\n\n简化 CPython 的实现：特别是内存管理（如引用计数）。CPython 的内存管理不是线程安全的，GIL 保护了对 Python 对象的访问。\n\n\n方便集成非线程安全的 C 库：许多 C 扩展库不是线程安全的，GIL 提供了一个简单的机制来确保它们在 Python 环境中的安全使用。\n\n\n历史原因：早期 Python 设计的选择。\n\n\n释放 GIL:\n\n\nCPython 解释器在执行阻塞型 I/O 操作时会自动释放 GIL。\n\n\n一些执行长时间计算的 C 扩展库（如 NumPy 中的某些操作）也会在内部释放 GIL。\n\n\ntime.sleep() 也会释放 GIL。\n\n\nPython 解释器会定期强制切换线程，释放 GIL 并让其他线程有机会运行（基于 tick 计数或时间片）。\n\n\n尽管有 GIL，threading 模块对于提高 I/O 密集型应用的响应性和吞吐量仍然非常有用。\nTimer 对象\nTimer 是 Thread 的一个子类，它可以在指定的延迟之后执行一个函数。它实际上是启动一个新线程，该线程等待指定时间后执行目标函数。\n\n\ntimer = threading.Timer(interval, function, args=None, kwargs=None):\n\n\ninterval: 延迟时间（秒）。\n\n\nfunction: 延迟后要执行的函数。\n\n\nargs, kwargs: 传递给 function 的参数。\n\n\ntimer.start(): 启动计时器和内部线程。在 interval 秒之后，function 会被执行。\n\n\ntimer.cancel(): 停止计时器并取消其动作的执行。只有在计时器尚未执行其动作时（即内部线程还在等待或尚未启动执行 function）才有效。\n\n\ndef delayed_action(message):\n    print(f&quot;定时器消息: {message} (在 {time.ctime()} 由 {threading.current_thread().name} 执行)&quot;)\n \nprint(f&quot;主线程: 准备启动定时器 (在 {time.ctime()})&quot;)\n# 3秒后执行 delayed_action\ntimer1 = threading.Timer(3.0, delayed_action, args=(&quot;Hello from Timer 1!&quot;,))\ntimer1.name = &quot;TimerThread-1&quot;\ntimer1.start()\n \ntimer2 = threading.Timer(1.0, delayed_action, kwargs={&quot;message&quot;: &quot;Quick message from Timer 2!&quot;})\ntimer2.name = &quot;TimerThread-2&quot;\ntimer2.start()\n \nprint(&quot;主线程: 定时器已启动，主线程可以做其他事情。&quot;)\ntime.sleep(0.5) # 主线程做点事\n \nprint(&quot;主线程: 准备取消 Timer 1 (如果它还没执行的话)&quot;)\ntimer1.cancel() # 尝试取消 timer1，如果它在3秒内还没执行，就会成功\n# 如果 cancel() 在 function 已经开始执行后被调用，则无效。\n \n# 等待定时器线程结束 (可选，但这里为了看到输出或确认取消)\n# 如果 timer1 被成功取消，它的 join() 会很快返回\n# 如果 timer2 正常执行，join() 会等待它完成\nprint(&quot;主线程: 等待 Timer 2 完成...&quot;)\ntimer2.join()\nprint(&quot;主线程: 等待 Timer 1 (可能已被取消)...&quot;)\ntimer1.join() # 如果取消成功，这里会立即返回或很快返回\n \n \nprint(f&quot;主线程: 结束 (在 {time.ctime()})&quot;)\n线程局部数据 (threading.local)\nthreading.local() 提供了一种创建线程局部数据的方式。也就是说，local 对象的属性值对于每个线程来说是独立的。一个线程对 local 对象属性的修改不会影响其他线程中该对象的同名属性。\n这对于需要在线程内维护一些状态信息，但又不希望通过参数在函数调用间显式传递这些状态时非常有用（例如，数据库连接、事务ID等）。\nmy_thread_local_data = threading.local() # 创建一个线程局部数据对象\n \ndef worker_using_local_data():\n    # 为当前线程设置属性\n    my_thread_local_data.x = threading.current_thread().name + &quot;-value&quot;\n    my_thread_local_data.y = threading.get_ident()\n    \n    print(f&quot;线程 {threading.current_thread().name}: 设置 my_thread_local_data.x = &#039;{my_thread_local_data.x}&#039;&quot;)\n    time.sleep(0.1 + int(threading.current_thread().name[-1]) * 0.1) # 不同线程不同延时\n    \n    # 读取属性，确保是本线程设置的值\n    print(f&quot;线程 {threading.current_thread().name}: 读取 my_thread_local_data.x = &#039;{my_thread_local_data.x}&#039;, y = {my_thread_local_data.y}&quot;)\n    \n    # 检查其他线程是否能看到这个值（预期是不能）\n    if hasattr(my_thread_local_data, &#039;z&#039;):\n        print(f&quot;线程 {threading.current_thread().name}: 意外发现 my_thread_local_data.z = {my_thread_local_data.z}&quot;)\n \n \nthreads_for_local_data = []\nfor i in range(3):\n    t = threading.Thread(target=worker_using_local_data, name=f&quot;LocalDataThread-{i}&quot;)\n    threads_for_local_data.append(t)\n    t.start()\n \nfor t in threads_for_local_data:\n    t.join()\n \n# 尝试在主线程访问 my_thread_local_data.x\n# 它会是未定义的，除非主线程也设置过它\ntry:\n    print(f&quot;主线程: my_thread_local_data.x = {my_thread_local_data.x}&quot;)\nexcept AttributeError:\n    print(&quot;主线程: my_thread_local_data.x 未定义 (符合预期)&quot;)\n \nmy_thread_local_data.x = &quot;主线程的数据&quot;\nprint(f&quot;主线程: 设置并读取 my_thread_local_data.x = &#039;{my_thread_local_data.x}&#039;&quot;)\nprint(&quot;threading.local 示例结束。&quot;)\n总结和最佳实践\n\n\n适用场景：threading 非常适合 I/O 密集型任务。对于 CPU 密集型任务，为了真正利用多核性能，应考虑 multiprocessing 模块。\n\n\n共享数据与同步：当多个线程访问和修改共享数据时，务必使用同步原语（如 Lock, RLock, Semaphore, Condition, Event）来避免竞态条件和数据损坏。with 语句是管理锁（以及其他支持上下文管理协议的同步原语）的推荐方式，能确保锁被正确释放。\n\n\n死锁 (Deadlock)：当多个线程相互等待对方释放资源时，会发生死锁。设计时要小心避免，例如：\n\n\n确保所有线程以相同的顺序获取多个锁。\n\n\n使用 RLock 处理同一线程内对锁的递归获取。\n\n\n尽量减少锁的持有时间。\n\n\n使用 lock.acquire(timeout=...) 来避免无限期等待。\n\n\n守护线程 (Daemon Threads)：谨慎使用守护线程。它们可以简化关闭过程（主程序退出时自动终止），但也可能导致数据丢失或资源未正确释放（因为它们可能在任务完成前被粗暴终止）。\n\n\n线程数量：创建过多的线程会消耗大量内存（每个线程都有自己的栈空间）并可能由于操作系统进行线程上下文切换的开销而降低性能，而不是提高性能。应根据任务特性和系统资源合理控制线程数量，可以使用线程池（如 concurrent.futures.ThreadPoolExecutor）来管理。\n\n\n异常处理：线程中的未捕获异常会导致该线程终止，但通常不会影响主线程或其他线程（除非主线程明确通过 join() 检查或有其他机制传递异常）。确保在线程的 run 方法或目标函数中妥善处理可能发生的异常，以避免线程悄无声息地失败。\n\n\n**join()** 的使用：如果你需要等待一个或多个线程完成后再继续主线程的后续逻辑，务必对这些线程调用 join()。否则，主线程可能会在子线程完成工作前退出，导致子线程被意外终止（如果它们不是守护线程，且程序结束）。\n\n\n避免阻塞主线程：在图形用户界面(GUI)应用中，耗时的操作不应在主线程（通常是GUI事件循环线程）中执行，否则会导致界面冻结。应将这些任务放到工作线程中，并通过线程安全的方式（如队列或特定GUI框架提供的机制）将结果传回主线程更新界面。\n\n\n资源释放：确保线程中打开的资源（如文件、网络连接）在线程结束前或发生异常时能被正确关闭和释放。try...finally 结构或 with 语句对此非常有用。\n\n\nthreading 模块是 Python 中实现并发的重要工具，理解其工作原理和各种同步机制对于编写健壮、高效的多线程应用程序至关重要。对于更现代和高级的并发编程模式，也可以考虑 asyncio（用于基于协程的单线程并发）和 concurrent.futures（提供了对线程和进程的更高级别抽象，如线程池和进程池）。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/getpass-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/getpass-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/getpass 模块.md","title":"getpass 模块","links":[],"tags":[],"content":"getpass 模块是 Python 标准库中用于安全地获取用户输入的模块，特别是用于获取密码输入。与 input() 函数不同，getpass() 在用户输入时不会显示输入的内容，这对于密码等敏感信息的处理至关重要。\n一、getpass 模块概述\ngetpass 模块主要提供了一个函数 getpass()，用于从命令行中获取用户的输入，并确保输入过程中不会回显（即输入的内容不会显示在控制台上）。\n二、常用功能与方法\n1. getpass.getpass(prompt=&#039;Password: &#039;, stream=None)\ngetpass() 是获取用户输入的主要函数，它的作用是提示用户输入并确保输入不被显示。\n\n\n参数：\n\n\nprompt：字符串类型，表示提示用户输入的消息。默认值为 &#039;Password: &#039;。\n\n\nstream：指定要写入提示信息的文件对象，默认是 sys.stderr。一般情况下可以忽略。\n\n\n返回值： 用户输入的字符串（但不会回显输入的内容）。\n\n\n示例：\nimport getpass\n \n# 获取用户输入的密码\npassword = getpass.getpass(&quot;请输入密码：&quot;)\n \n# 打印密码（可以用其他方式使用密码，但这里为了演示）\nprint(f&quot;您输入的密码是：{password}&quot;)\n在上面的代码中，getpass.getpass() 会提示用户输入密码，且在输入时不会显示输入内容。\n2. getpass.getuser()\ngetuser() 是一个较为简单的函数，返回当前系统的登录用户名。\n\n返回值： 当前操作系统的登录用户名（字符串类型）。\n\n示例：\nimport getpass\n \n# 获取当前系统的登录用户名\nusername = getpass.getuser()\nprint(f&quot;当前登录用户名是：{username}&quot;)\n三、与其他输入方法的比较\n与 input() 方法不同，getpass() 主要用于获取敏感数据，并且会在输入过程中隐藏用户的输入内容，而 input() 会将用户输入的内容显示在终端上。getpass() 是处理密码输入的首选工具。\ninput() 示例：\n# input() 会显示用户输入的内容\nusername = input(&quot;请输入用户名：&quot;)\npassword = input(&quot;请输入密码：&quot;)\ngetpass() 示例：\nimport getpass\n \n# getpass() 会隐藏用户输入的密码\nusername = input(&quot;请输入用户名：&quot;)\npassword = getpass.getpass(&quot;请输入密码：&quot;)\n四、平台差异\n\nUnix 和 Linux 系统：getpass() 正常工作，用户的输入会被隐藏。\nWindows 系统：getpass() 在 Windows 上的行为可能会有所不同，特别是早期版本的 Python。在某些早期版本的 Python 中，getpass() 在 Windows 上有时可能无法隐藏输入，但在最新的 Python 版本中，getpass() 已经能够在 Windows 上正确隐藏输入。\n\n五、注意事项\n\n安全性：\ngetpass() 确保用户的密码或其他敏感信息不会被回显到屏幕上，从而增加了数据的安全性。但是，getpass() 并没有对用户输入的密码进行加密，它只保证在获取输入时不会回显。开发者需要结合其他加密技术对密码进行存储和处理。\n**错误处理：**在某些平台或特殊情况下，如果 getpass() 无法正常工作（例如无法隐藏输入），可以通过捕获异常来处理错误。\n\nimport getpass\n \ntry:\n    password = getpass.getpass(&quot;请输入密码：&quot;)\nexcept Exception as e:\n    print(f&quot;获取密码时发生错误: {e}&quot;)\n\n**自定义提示：**在使用 getpass.getpass() 时，可以传入自定义的提示信息，帮助用户了解输入的内容是什么。\n\nimport getpass\n \n# 提示用户输入密码\npassword = getpass.getpass(&quot;请输入安全密码：&quot;)\n\n与终端兼容性：\n在一些特殊的终端环境中（如某些 IDE 的终端），getpass() 可能无法正常工作，输入时仍会回显。这时，使用一个标准的命令行终端（如 Windows CMD 或 Unix/Linux 系统的 Terminal）将更为可靠。\n\n六、实际应用场景\ngetpass 模块通常用于以下几种场景：\n\n登录认证： 在需要用户输入密码的应用程序中，使用 getpass 隐藏用户的密码输入。\n\nimport getpass\n \n# 模拟简单的登录验证\nusername = input(&quot;请输入用户名：&quot;)\npassword = getpass.getpass(&quot;请输入密码：&quot;)\n \n# 验证用户名和密码（这里只是一个简单示例）\nif username == &quot;admin&quot; and password == &quot;1234&quot;:\n    print(&quot;登录成功！&quot;)\nelse:\n    print(&quot;用户名或密码错误！&quot;)\n\n命令行工具： 如果你的 Python 脚本需要获取用户密码，可以使用 getpass() 来实现不回显的密码输入。\n安全敏感操作： 在需要执行安全敏感操作时（如解密文件），可以通过 getpass() 获取密码来进行操作。\n\n七、总结\n\ngetpass 模块提供了一个简单且安全的方式来获取用户的密码输入，并确保输入过程中不会被显示。\n它提供的 getpass() 函数用于安全地获取用户输入的密码，而 getuser() 用于获取当前系统的用户名。\ngetpass() 在不同平台上的行为可能有所不同，但在现代 Python 版本中，已经能够较好地支持各大操作系统。\n使用 getpass 获取密码时，开发者仍然需要额外的措施来确保密码的安全存储和传输。\n\n通过合理使用 getpass，可以有效地提高程序中敏感信息输入的安全性。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/os-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/os-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/os 模块.md","title":"os 模块","links":[],"tags":[],"content":"os 模块是 Python 标准库中的一个重要模块，用于与操作系统进行交互。它提供了丰富的方法用于文件和目录的操作、环境变量管理、进程控制、路径处理等，具有跨平台特性。以下将从模块功能分类、常用函数及示例三个方面进行详细讲解。\n\n一、模块导入\nimport os\n\n二、功能分类与常用方法\n1. 文件与目录操作\n1.1 当前工作目录\nos.getcwd()  # 获取当前工作目录\nos.chdir(path)  # 改变当前工作目录\n1.2 创建和删除目录\nos.mkdir(path)  # 创建单层目录\nos.makedirs(path)  # 递归创建多层目录\nos.rmdir(path)  # 删除单层目录（目录必须为空）\nos.removedirs(path)  # 递归删除空目录\n1.3 文件操作\nos.remove(path)  # 删除文件\nos.rename(src, dst)  # 重命名文件或目录\nos.replace(src, dst)  # 同 rename，但目标存在时会替换\n1.4 遍历目录\nos.listdir(path)  # 返回指定路径下的文件和目录列表\nos.walk(top)  # 递归遍历目录树，返回生成器 (dirpath, dirnames, filenames)\n\n2. 路径操作（推荐与 os.path 联用）\nos.path.abspath(path)  # 获取绝对路径\nos.path.basename(path)  # 获取文件名部分\nos.path.dirname(path)  # 获取目录部分\nos.path.join(path, *paths)  # 路径拼接（自动加/）\nos.path.exists(path)  # 判断路径是否存在\nos.path.isfile(path)  # 判断是否为文件\nos.path.isdir(path)  # 判断是否为目录\nos.path.getsize(path)  # 获取文件大小（单位：字节）\nos.path.split(path)  # 拆分为 (目录, 文件)\n\n3. 环境变量\nos.environ  # 获取所有环境变量（字典形式）\nos.environ.get(&#039;PATH&#039;)  # 获取某个环境变量\nos.putenv(&#039;NAME&#039;, &#039;value&#039;)  # 设置环境变量（不推荐）\n\n4. 系统信息\nos.name  # 返回操作系统类型（&#039;posix&#039;、&#039;nt&#039;等）\nos.uname()  # 返回系统信息（仅限 Unix 系统）\nos.getlogin()  # 获取当前登录用户名（某些环境可能失败）\n\n5. 进程管理\nos.system(&#039;command&#039;)  # 执行系统命令（阻塞）\nos.startfile(path)  # 打开文件（仅 Windows）\nos.getpid()  # 获取当前进程 PID\nos.getppid()  # 获取父进程 PID\n\n三、综合示例\nimport os\n \n# 1. 切换到用户主目录\nhome_dir = os.path.expanduser(&quot;~&quot;)\nos.chdir(home_dir)\n \n# 2. 创建一个测试目录\ntest_dir = os.path.join(home_dir, &quot;test_dir&quot;)\nif not os.path.exists(test_dir):\n    os.makedirs(test_dir)\n \n# 3. 创建一个文件\nfile_path = os.path.join(test_dir, &quot;example.txt&quot;)\nwith open(file_path, &quot;w&quot;) as f:\n    f.write(&quot;Hello, os module!&quot;)\n \n# 4. 输出目录内容\nprint(&quot;目录内容：&quot;, os.listdir(test_dir))\n \n# 5. 删除文件和目录\nos.remove(file_path)\nos.rmdir(test_dir)\n\n四、补充说明\n\nos.path 是 os 的子模块，专门用于路径处理。\n在进行跨平台开发时，推荐使用 os.path.join() 而非手动拼接路径，以避免路径分隔符问题。\n若需高级文件操作（如复制文件），推荐配合 shutil 模块使用。\n"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/pathlib-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/pathlib-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/pathlib 模块.md","title":"pathlib 模块","links":[],"tags":[],"content":"pathlib 模块详解（Python 3.4+）\npathlib 是 Python 3.4 引入的标准库模块，提供了面向对象的文件系统路径操作方式，是对传统 os.path 模块的现代替代。其主要优势包括：\n\n更直观的路径拼接方式（使用 / 运算符）；\n更高的可读性与可维护性；\n跨平台兼容性（自动适配 Windows 和 POSIX）；\n丰富的 API 支持常见的文件与目录操作。\n\n\n一、基本概念与核心类\n1. pathlib.Path 类（或 PosixPath / WindowsPath）\n\nPath 是 pathlib 模块的核心类，实际在不同平台上会返回 PosixPath（Unix-like 系统）或 WindowsPath（Windows 系统）的实例；\nPath 对象可表示文件路径或目录路径，无需路径实际存在；\n路径操作通过重载运算符（如 /）或调用对象方法完成。\n\n示例：\nfrom pathlib import Path\n \np1 = Path(&#039;/home/user/file.txt&#039;)            # Unix 系统\np2 = Path(&#039;C:/Users/user/file.txt&#039;)         # Windows 系统\n\n二、路径操作示例\n1. 路径拼接（推荐方式）\np = Path(&#039;/home/user&#039;)\nnew_path = p / &#039;documents&#039; / &#039;file.txt&#039;\nprint(new_path)  # /home/user/documents/file.txt\n相较于 os.path.join()，使用 / 运算符更简洁直观。\n2. 获取路径的组成部分\np = Path(&#039;/home/user/file.txt&#039;)\n \nprint(p.name)     # &#039;file.txt&#039;\nprint(p.stem)     # &#039;file&#039;\nprint(p.suffix)   # &#039;.txt&#039;\nprint(p.parent)   # &#039;/home/user&#039;\nprint(p.parts)    # (&#039;/&#039;, &#039;home&#039;, &#039;user&#039;, &#039;file.txt&#039;)\n\n三、文件与目录操作\n1. 判断路径状态\np = Path(&#039;example.txt&#039;)\n \np.exists()    # 是否存在\np.is_file()   # 是否为文件\np.is_dir()    # 是否为目录\n2. 创建文件 / 目录\nPath(&#039;mydir&#039;).mkdir()                               # 创建单级目录\nPath(&#039;a/b/c&#039;).mkdir(parents=True, exist_ok=True)    # 创建多级目录，若存在不报错\nPath(&#039;empty.txt&#039;).touch()                           # 创建空文件\n3. 删除文件 / 空目录\nPath(&#039;empty.txt&#039;).unlink()   # 删除文件\nPath(&#039;a/b/c&#039;).rmdir()        # 删除空目录（非递归）\n\n四、遍历文件系统\n1. 遍历目录内容（非递归）\nfor child in Path(&#039;.&#039;).iterdir():\n    print(child)\n2. 匹配特定模式\n# 匹配当前目录下所有 .txt 文件\nfor file in Path(&#039;.&#039;).glob(&#039;*.txt&#039;):\n    print(file)\n \n# 递归匹配所有 .py 文件\nfor file in Path(&#039;.&#039;).rglob(&#039;*.py&#039;):\n    print(file)\n\n五、读取与写入文件内容\n虽然 Path 对象不是文件对象，但提供了便捷方法处理文件内容：\n# 写入文本\nPath(&#039;note.txt&#039;).write_text(&#039;Hello, world!&#039;, encoding=&#039;utf-8&#039;)\n \n# 读取文本\ncontent = Path(&#039;note.txt&#039;).read_text(encoding=&#039;utf-8&#039;)\n \n# 写入二进制\nPath(&#039;data.bin&#039;).write_bytes(b&#039;\\x00\\x01&#039;)\n \n# 读取二进制\ndata = Path(&#039;data.bin&#039;).read_bytes()\n\n六、路径解析与转换\n1. 规范化与解析绝对路径\nPath(&#039;a/b/../c&#039;).resolve()  # 返回绝对路径并消除 &quot;..&quot;\n2. 转换为字符串（用于与旧函数兼容）\nstr(Path(&#039;file.txt&#039;))  # 返回 &#039;file.txt&#039; 字符串\n\n七、平台无关性与兼容性\nPath 会自动适配当前系统，统一路径风格：\nfrom pathlib import Path\n \np = Path(&#039;folder&#039;) / &#039;file.txt&#039;\nprint(p)  # Windows: folder\\file.txt；Unix: folder/file.txt\n\n八、常用技巧与辅助功能\n1. 获取当前工作目录\nPath.cwd()  # 相当于 os.getcwd()\n2. 获取当前脚本所在目录\nPath(__file__).parent\n3. 获取系统临时目录（需配合 tempfile 模块）\nimport tempfile\ntemp_dir = Path(tempfile.gettempdir())\n\n九、与 os.path 模块的对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能os.path示例pathlib示例拼接路径os.path.join(a, b)Path(a) / b判断是否为文件os.path.isfile(p)Path(p).is_file()获取扩展名os.path.splitext(p)[1]Path(p).suffix遍历目录os.listdir(p)Path(p).iterdir()读取文件内容open(p).read()Path(p).read_text()获取绝对路径os.path.abspath(p)Path(p).resolve()\n\n十、总结\npathlib 提供了更清晰、更现代化的路径操作方式，推荐在现代 Python 项目中优先使用 pathlib 取代传统的 os.path 模块。它不仅提高了代码的可读性，还增强了平台兼容性与编程体验。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/platform-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/platform-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/platform 模块.md","title":"platform 模块","links":[],"tags":[],"content":"platform 模块详解（Python 标准库）\nplatform 模块是 Python 标准库中用于访问操作系统平台相关信息的模块。它可以用来获取操作系统类型、版本、计算机架构、Python 解释器信息等内容，常用于编写跨平台程序、调试或系统信息收集等场景。\n\n一、导入方式\nimport platform\n\n二、常用函数说明及示例\n1. platform.system()\n\n功能：返回操作系统的名称。\n示例：\n\nplatform.system()  # 返回 &#039;Windows&#039;、&#039;Linux&#039; 或 &#039;Darwin&#039;（macOS）\n\n2. platform.release()\n\n功能：返回操作系统的发行版本（如内核版本或主版本号）。\n示例：\n\nplatform.release()  # 如 &#039;10&#039;（Windows 10）、&#039;5.15.0-105&#039;（Linux）\n\n3. platform.version()\n\n功能：返回操作系统的详细版本信息（包含内核构建等细节）。\n示例：\n\nplatform.version()  # 如 &#039;10.0.19044&#039;（Windows）、&#039;#1 SMP Debian 5.10.0-25&#039;\n\n4. platform.platform(aliased=False, terse=False)\n\n\n功能：返回一个完整的字符串，描述当前平台的详细信息。\n\n\n参数说明：\n\n\naliased=True：使用别名（某些平台适用）\n\n\nterse=True：返回简洁模式字符串\n\n\n示例：\n\n\nplatform.platform()  # &#039;Windows-10-10.0.19044-SP0&#039;\n\n5. platform.machine()\n\n功能：返回计算机的架构类型。\n示例：\n\nplatform.machine()  # 如 &#039;AMD64&#039;、&#039;x86_64&#039;、&#039;armv7l&#039;\n\n6. platform.processor()\n\n功能：返回处理器名称（注意部分系统下可能为空）。\n示例：\n\nplatform.processor()  # 如 &#039;Intel64 Family 6 Model 158&#039;，可能返回 &#039;&#039;\n\n7. platform.architecture(executable=sys.executable, bits=&#039;&#039;, linkage=&#039;&#039;)\n\n功能：返回当前 Python 解释器的架构信息。\n示例：\n\nplatform.architecture()  # 返回 (&#039;64bit&#039;, &#039;WindowsPE&#039;)\n\n8. platform.node()\n\n功能：返回当前计算机的主机名（网络标识）。\n示例：\n\nplatform.node()  # 如 &#039;DESKTOP-ABC1234&#039;\n\n9. platform.uname()\n\n功能：返回包含系统相关信息的命名元组，整合了多个函数的结果。\n示例：\n\nuname_result = platform.uname()\nprint(uname_result)\n# 输出示例：\n# uname_result(system=&#039;Windows&#039;, node=&#039;DESKTOP-ABC1234&#039;, release=&#039;10&#039;, version=&#039;10.0.19044&#039;, machine=&#039;AMD64&#039;, processor=&#039;Intel64 Family 6 Model 158&#039;)\n\n10. platform.python_version()\n\n功能：返回当前 Python 的版本字符串。\n示例：\n\nplatform.python_version()  # 如 &#039;3.12.0&#039;\n\n11. platform.python_implementation()\n\n功能：返回 Python 解释器的实现名称。\n示例：\n\nplatform.python_implementation()  # 如 &#039;CPython&#039;、&#039;PyPy&#039;\n\n12. platform.python_compiler()\n\n功能：返回用于构建当前 Python 的编译器信息。\n示例：\n\nplatform.python_compiler()  # 如 &#039;MSC v.1935 64 bit (AMD64)&#039;\n\n三、典型应用场景\n\n编写跨平台脚本\n\n\n通过 platform.system() 判断当前系统类型，从而执行不同平台下的操作逻辑。\n\n\n系统信息收集\n\n\n自动采集平台环境信息，用于日志记录、问题定位、系统审计等。\n\n\n运行环境识别\n\n\n区分开发、测试与生产环境。例如在某些操作系统或特定版本上禁用或启用某些特性。\n\n\n四、示例代码汇总\nimport platform\n \nprint(&quot;系统：&quot;, platform.system())\nprint(&quot;版本：&quot;, platform.version())\nprint(&quot;发行版本：&quot;, platform.release())\nprint(&quot;平台：&quot;, platform.platform())\nprint(&quot;计算机类型：&quot;, platform.machine())\nprint(&quot;处理器：&quot;, platform.processor())\nprint(&quot;架构：&quot;, platform.architecture())\nprint(&quot;主机名：&quot;, platform.node())\nprint(&quot;Python 版本：&quot;, platform.python_version())\nprint(&quot;Python 实现：&quot;, platform.python_implementation())\nprint(&quot;Python 编译器：&quot;, platform.python_compiler())\n \n# uname 结构体详细输出\nprint(&quot;\\n系统信息（uname）:&quot;)\nuname = platform.uname()\nfor field in uname._fields:\n    print(f&quot;{field}: {getattr(uname, field)}&quot;)\n\n五、注意事项\n\n某些函数（如 platform.processor()）在部分平台下可能返回空值，应加入容错处理机制。\nplatform.linux_distribution() 从 Python 3.8 开始已被移除，不再推荐使用。如需获取 Linux 发行版详细信息，应使用第三方库 distro。\n\n安装方式：\npip install distro\n使用示例：\nimport distro\nprint(distro.name(), distro.version(), distro.codename())\n\n如需编写需兼容多个操作系统的脚本，platform 模块可提供关键辅助信息，为自动化部署、调试排查及系统识别等提供强有力的支持。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/shutil-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/shutil-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/shutil 模块.md","title":"shutil 模块","links":[],"tags":[],"content":"shutil 模块详解笔记\nshutil 模块是 Python 标准库中的一个高级文件操作模块，建立在 os 模块之上，提供了更强大、更方便的文件和目录复制、移动、删除、压缩、解压、磁盘使用情况查询等功能，适合执行文件系统的批处理任务，常用于备份、部署、清理等场景。\n\n一、模块导入\nimport shutil\n\n二、功能分类与常用方法详解\n1. 文件和目录的复制\n1.1 shutil.copy(src, dst)\n\n复制文件内容，但不保留元数据（如权限、修改时间）。\n如果 dst 是目录，则会在该目录下创建一个与 src 同名的文件。\n\nshutil.copy(&quot;a.txt&quot;, &quot;backup/&quot;)\n1.2 shutil.copy2(src, dst)\n\n与 copy 类似，但保留文件的元数据，推荐用于备份。\n\nshutil.copy2(&quot;a.txt&quot;, &quot;backup/&quot;)\n1.3 shutil.copyfile(src, dst)\n\n仅复制文件内容，要求目标路径 **dst** 必须是一个文件名，不能是目录。\n\nshutil.copyfile(&quot;a.txt&quot;, &quot;b.txt&quot;)\n1.4 shutil.copytree(src, dst, dirs_exist_ok=False)\n\n递归复制整个目录树，类似于命令 cp -r。\ndirs_exist_ok=True 表示目标目录存在时仍可继续复制（Python 3.8+）。\n\nshutil.copytree(&quot;project/&quot;, &quot;project_backup/&quot;, dirs_exist_ok=True)\n\n2. 移动和重命名\nshutil.move(src, dst)\n\n移动文件或目录到新位置。\n如果 dst 为文件名，相当于重命名；如果为目录，则移动到该目录下。\n\nshutil.move(&quot;a.txt&quot;, &quot;archive/&quot;)      # 移动到目录\nshutil.move(&quot;a.txt&quot;, &quot;b.txt&quot;)         # 重命名\n\n3. 删除操作\nshutil.rmtree(path)\n\n递归删除整个目录树，即使该目录非空。\n操作不可恢复，建议在实际使用中添加确认或日志机制。\n\nshutil.rmtree(&quot;temp_folder&quot;)\n⚠️ 高风险操作，需慎用。\n\n4. 文件权限和属性操作\n4.1 shutil.chown(path, user=None, group=None)\n\n更改文件或目录的所有者，仅适用于类 Unix 系统。\n\nshutil.chown(&quot;log.txt&quot;, user=&quot;admin&quot;, group=&quot;staff&quot;)\n4.2 shutil.copystat(src, dst)\n\n复制 src 的权限、时间戳等元数据到 dst，不包括内容。\n\nshutil.copystat(&quot;a.txt&quot;, &quot;b.txt&quot;)\n\n5. 压缩与解压\n5.1 shutil.make_archive(base_name, format, root_dir)\n\n创建压缩包。\nformat 可选值包括：zip、tar、gztar、bztar、xztar。\n\nshutil.make_archive(&quot;backup&quot;, &quot;zip&quot;, root_dir=&quot;project/&quot;)\n# 生成 backup.zip\n5.2 shutil.unpack_archive(filename, extract_dir)\n\n解压压缩文件，自动识别格式。\n\nshutil.unpack_archive(&quot;backup.zip&quot;, &quot;extracted/&quot;)\n\n6. 磁盘使用情况\nshutil.disk_usage(path)\n\n返回 (total, used, free) 的命名元组，单位为字节。\n\nusage = shutil.disk_usage(&quot;/&quot;)\nprint(f&quot;总空间: {usage.total // (1024**3)} GB&quot;)\nprint(f&quot;已使用: {usage.used // (1024**3)} GB&quot;)\nprint(f&quot;可用: {usage.free // (1024**3)} GB&quot;)\n\n7. 临时文件操作（结合 tempfile 模块）\n虽然 shutil 本身不支持创建临时文件或目录，但常与 tempfile 搭配使用：\nimport tempfile\n \nwith tempfile.TemporaryDirectory() as tmpdirname:\n    print(&quot;创建的临时目录：&quot;, tmpdirname)\n    shutil.copy(&quot;a.txt&quot;, tmpdirname)\n\n三、综合示例\nimport shutil\nimport os\n \n# 1. 创建备份目录\nos.makedirs(&quot;backup&quot;, exist_ok=True)\n \n# 2. 复制文件并保留元数据\nshutil.copy2(&quot;data.txt&quot;, &quot;backup/data.txt&quot;)\n \n# 3. 复制整个目录树\nshutil.copytree(&quot;logs&quot;, &quot;backup/logs&quot;, dirs_exist_ok=True)\n \n# 4. 创建 ZIP 压缩包\nshutil.make_archive(&quot;project_backup&quot;, &quot;zip&quot;, root_dir=&quot;project&quot;)\n \n# 5. 查看磁盘使用情况\nusage = shutil.disk_usage(&quot;/&quot;)\nprint(f&quot;Disk Free: {usage.free / (1024**3):.2f} GB&quot;)\n\n四、总结对照表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能分类方法名说明文件复制copy, copy2, copyfilecopy2可保留元数据目录复制copytree可递归复制整个目录树移动与重命名move支持跨目录移动或文件重命名删除目录rmtree强制递归删除整个目录压缩与解压make_archive, unpack_archive支持多种压缩格式空间查询disk_usage查询总空间、已用空间与可用空间权限与元数据copystat, chown多用于类 Unix 系统下的权限控制临时目录tempfile（需配合 shutil使用）适用于测试、缓存、中间结果的隔离性操作"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/signal-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/signal-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/signal 模块.md","title":"signal 模块","links":[],"tags":[],"content":"signal 模块是 Python 提供的一个用于处理异步事件的标准模块，主要用于设置信号处理器（signal handler），使程序能在收到系统信号时做出自定义响应。常用于处理诸如 Ctrl+C 中断、子进程退出、定时器等。\n一、信号（Signal）简介\n信号是操作系统用于通知进程发生了异步事件的一种机制。常见的信号包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n信号名数值含义SIGINT2用户中断（通常是 Ctrl+C）SIGTERM15请求终止程序（kill 默认）SIGKILL9强制终止程序（不可捕获）SIGALRM14定时器信号SIGHUP1终端关闭SIGCHLD17子进程退出\n二、signal 模块常用函数\n1. signal.signal(signalnum, handler)\n设置信号处理器：\n\n\nsignalnum：信号编号，例如 signal.SIGINT。\n\n\nhandler：\n\n\nsignal.SIG_IGN：忽略信号。\n\n\nsignal.SIG_DFL：使用默认处理器。\n\n\n自定义函数：接受两个参数 (signum, frame)，分别表示信号编号和当前堆栈帧。\n\n\n📌 只能在主线程中使用。\n示例：\nimport signal\nimport time\n \ndef handler(signum, frame):\n    print(f&quot;接收到信号: {signum}&quot;)\n \n# 设置 SIGINT 信号处理器\nsignal.signal(signal.SIGINT, handler)\n \nwhile True:\n    print(&quot;运行中... 按 Ctrl+C 发送 SIGINT&quot;)\n    time.sleep(2)\n2. signal.alarm(seconds)\n在指定秒数后发送 SIGALRM 信号，仅在 Unix 系统中可用。\n示例：\nimport signal\nimport time\n \ndef timeout_handler(signum, frame):\n    print(&quot;超时！&quot;)\n \nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(5)  # 5 秒后触发\n \nprint(&quot;开始等待...&quot;)\ntime.sleep(10)\nprint(&quot;结束&quot;)\n3. signal.pause()\n挂起进程直到接收到信号。常与定时器、异步控制联合使用。\n示例：\nimport signal\n \ndef handler(signum, frame):\n    print(&quot;收到信号，继续执行&quot;)\n \nsignal.signal(signal.SIGUSR1, handler)\nprint(&quot;等待信号 SIGUSR1...&quot;)\nsignal.pause()\nprint(&quot;继续执行程序&quot;)\n4. signal.getsignal(signalnum)\n获取当前指定信号的处理器。\n三、与子进程相关的信号\n\nSIGCHLD：子进程结束后发送，常用于编写守护进程。\n\n处理 SIGCHLD 后，可以使用 os.wait() 或 os.waitpid() 获取子进程的退出状态。\n四、注意事项\n\n\nWindows 支持的信号较少，仅支持：\n\n\nSIGINT\n\n\nSIGTERM\n\n\nSIGABRT\n\n\nSIGBREAK\n\n\n仅主线程可以设置信号处理器，否则抛出 **ValueError**。\n\n\nSIGKILL 和 SIGSTOP 不可被捕获或忽略。\n\n\n五、实际应用场景\n1. 优雅终止程序\n在接收到终止信号时执行资源清理工作，并正常退出程序。\nimport signal\nimport sys\n \ndef cleanup(signum, frame):\n    print(&quot;清理资源...&quot;)\n    sys.exit(0)\n \nsignal.signal(signal.SIGTERM, cleanup)\nsignal.signal(signal.SIGINT, cleanup)\n2. 超时控制\n在执行某些阻塞操作前设置信号定时器，避免程序永久挂起。\nimport signal\nimport time\n \ndef timeout_handler(signum, frame):\n    print(&quot;操作超时&quot;)\n \nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(5)  # 设置超时为 5 秒\n \ntry:\n    print(&quot;开始执行操作...&quot;)\n    time.sleep(10)  # 模拟长时间阻塞操作\nexcept Exception as e:\n    print(e)\n3. 写守护进程\n使用 SIGCHLD 监控子进程生命周期，常用于守护进程的编写。\nimport signal\nimport os\nimport time\n \ndef child_handler(signum, frame):\n    pid, status = os.wait()  # 等待子进程退出\n    print(f&quot;子进程 {pid} 已退出，状态：{status}&quot;)\n \nsignal.signal(signal.SIGCHLD, child_handler)\n \n# 创建子进程示例\npid = os.fork()\nif pid == 0:\n    print(&quot;子进程开始执行...&quot;)\n    time.sleep(2)\n    os._exit(0)\nelse:\n    print(&quot;父进程等待子进程退出...&quot;)\n    time.sleep(3)\n六、信号编号列表\nimport signal\n \nfor name in dir(signal):\n    if name.startswith(&quot;SIG&quot;) and not name.startswith(&quot;SIG_&quot;):\n        print(f&quot;{name}: {getattr(signal, name)}&quot;)\n此代码将输出所有信号编号和其对应的值。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/subprocess-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/subprocess-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/subprocess 模块.md","title":"subprocess 模块","links":[],"tags":[],"content":"subprocess 模块详解笔记（完整版）\nsubprocess 模块是 Python 标准库中用于创建和管理子进程的核心模块，旨在替代传统的 os.system()、os.spawn*()、os.popen*() 等过时接口，提供了更强大、灵活和安全的方式来执行外部命令、进行进程间通信和捕获输出结果。\n\n一、核心函数与类介绍\n1. subprocess.run()\n用途：\n执行命令，等待命令执行结束，返回结果。适用于大多数简单的命令执行场景。\n示例代码：\nimport subprocess\n \nresult = subprocess.run([&#039;ls&#039;, &#039;-l&#039;], capture_output=True, text=True)\nprint(result.stdout)\n常用参数：\n\nargs: 指定命令及参数，建议使用列表形式，防止命令注入。\nshell: 若为 True，通过 shell 解析执行命令（支持管道、重定向等复杂命令）。\ncapture_output: 若为 True，等价于 stdout=subprocess.PIPE 和 stderr=subprocess.PIPE。\ntext / universal_newlines: 为 True 时将输入输出以字符串处理（默认是字节流）。\ninput: 传入标准输入的字符串或字节流。\ntimeout: 设置超时时间（秒）。\ncheck: 若为 True 且命令返回码非 0，将抛出 CalledProcessError。\n\n返回对象：CompletedProcess\n\nargs: 实际执行的命令参数列表。\nreturncode: 子进程的退出状态码。\nstdout: 标准输出（如启用 capture_output）。\nstderr: 标准错误输出（如启用 capture_output）。\n\n\n2. subprocess.Popen()\n用途：\n提供最灵活的进程控制接口，适用于需要实时交互、流式处理、管道连接等复杂场景。\n示例代码：\np = subprocess.Popen([&#039;grep&#039;, &#039;foo&#039;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)\noutput, _ = p.communicate(input=&#039;foo\\nbar\\nfoo bar\\n&#039;)\nprint(output)\n常用参数：\n\nstdin, stdout, stderr: 可设为 subprocess.PIPE、subprocess.DEVNULL、文件对象等。\nshell: 与 run() 相同。\ntext: 字符串模式；若为 False，则读写为字节。\nbufsize: 缓冲策略（0: 无缓冲，1: 行缓冲，-1: 默认缓冲）。\n\n常用方法：\n\ncommunicate(input=None): 发送输入并接收输出，等待子进程终止。\nwait(timeout=None): 阻塞等待子进程结束。\npoll(): 检查子进程是否终止（不阻塞）。\nkill() / terminate(): 杀死或终止子进程。\n\n\n3. subprocess.call()\n**用途：**执行命令并返回退出码。可看作 run(...).returncode 的快捷方式。\n示例代码：\ncode = subprocess.call([&#039;ls&#039;, &#039;-l&#039;])\n\n4. subprocess.check_call() / subprocess.check_output()\ncheck_call():\n\n功能与 call() 类似，但如果退出码非零，会抛出 CalledProcessError 异常。\n\ncheck_output():\n\n执行命令并返回标准输出结果。\n若命令失败，会抛出 CalledProcessError，异常对象中包含 output。\n\n示例：\noutput = subprocess.check_output([&#039;echo&#039;, &#039;hello&#039;], text=True)\nprint(output)\n\n二、shell 模式与安全性\n1. shell=True 的作用\n使用 shell 解析执行命令字符串（例如：支持 &quot;ls -l | grep txt&quot;、重定向等复杂表达式），等价于将命令传递给 shell 解析（如 Linux 的 /bin/sh，Windows 的 cmd.exe）。\n2. 安全风险\n\n若命令中包含用户输入，切勿直接拼接字符串再传给 shell，极易造成命令注入。\n推荐使用 列表传参 + shell=False 的方式来避免此类风险。\n\n不安全示例：\nsubprocess.run(f&quot;rm -rf {user_input}&quot;, shell=True)\n安全示例：\nsubprocess.run([&quot;rm&quot;, &quot;-rf&quot;, user_input])\n\n三、标准输入输出与错误控制\n捕获标准输出与错误：\nresult = subprocess.run([&#039;ls&#039;, &#039;-l&#039;], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\nprint(&quot;输出：&quot;, result.stdout)\nprint(&quot;错误：&quot;, result.stderr)\n传递标准输入：\nresult = subprocess.run([&#039;python3&#039;], input=&#039;print(&quot;Hello&quot;)&#039;, text=True, stdout=subprocess.PIPE)\nprint(result.stdout)\n忽略输出：\n\n使用 stdout=subprocess.DEVNULL 屏蔽输出\n\nsubprocess.run([&#039;ls&#039;], stdout=subprocess.DEVNULL)\n\n四、典型应用场景示例\n1. 管道命令（如 ls | grep py）\np1 = subprocess.Popen([&#039;ls&#039;], stdout=subprocess.PIPE)\np2 = subprocess.Popen([&#039;grep&#039;, &#039;py&#039;], stdin=p1.stdout, stdout=subprocess.PIPE, text=True)\np1.stdout.close()  # 避免死锁\noutput = p2.communicate()[0]\nprint(output)\n2. 设置命令超时：\ntry:\n    subprocess.run([&#039;sleep&#039;, &#039;10&#039;], timeout=5)\nexcept subprocess.TimeoutExpired:\n    print(&quot;命令超时！&quot;)\n3. 动态构建命令：\ncmd = [&#039;ffmpeg&#039;, &#039;-i&#039;, &#039;input.mp4&#039;, &#039;-vn&#039;, &#039;output.mp3&#039;]\nsubprocess.run(cmd)\n\n五、异常处理机制\n常见异常类型：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n异常类型触发条件subprocess.CalledProcessError当 check=True且命令返回码非 0 时触发subprocess.TimeoutExpired超过 timeout参数指定时间仍未完成执行OSError系统层面错误，如命令不存在或权限不足等\n示例：\ntry:\n    subprocess.run([&#039;false&#039;], check=True)\nexcept subprocess.CalledProcessError as e:\n    print(&quot;命令执行失败，返回码：&quot;, e.returncode)\n\n六、函数用法对比小结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数功能描述推荐使用场景subprocess.run()执行命令并等待完成，支持超时、捕获输出、传入输入等推荐首选subprocess.Popen()最底层接口，支持流式交互与复杂控制子进程交互、管道、长时任务等场景subprocess.call()执行命令，返回状态码仅需退出码，不关心输出时subprocess.check_call()类似 call()，但失败抛异常需要明确检测命令是否成功时subprocess.check_output()执行命令并返回输出，失败抛异常需要获取输出内容时\n\n七、实用建议与注意事项\n\n避免使用 shell=True 处理用户输入\n\n\n安全风险极高，应使用列表方式传参。\n\n\n尽可能捕获输出并设置超时\n\n\n防止子进程阻塞主程序。\n\n\n了解子进程资源管理\n\n\n使用 p1.stdout.close() 等避免管道阻塞。\n\n\n跨平台兼容性\n\n\nWindows 和 Linux 的 shell 行为、命令格式差异需留意。\n\n\n处理非 UTF-8 编码\n\n\n可设置 encoding=&#039;gbk&#039; 等参数以兼容特定系统编码（如 Windows）。\n"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/sys-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/sys-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/sys 模块.md","title":"sys 模块","links":[],"tags":[],"content":"sys 模块详解笔记\nsys 模块是 Python 标准库中的一个核心模块，提供了与 Python 解释器密切相关的一些变量和函数。主要用于访问和操作 Python 运行时环境的底层信息，例如命令行参数、模块搜索路径、解释器版本、标准流重定向等。\n\n一、基本导入方式\nimport sys\n\n二、常用属性与函数详解\n1. sys.argv：命令行参数列表\n\n类型：list\n描述：包含执行 Python 脚本时传入的命令行参数。\nsys.argv[0] 通常是脚本文件名，后续为实际参数。\n\n示例：\n# 运行命令：python script.py arg1 arg2\nimport sys\nprint(sys.argv)  # 输出：[&#039;script.py&#039;, &#039;arg1&#039;, &#039;arg2&#039;]\n\n2. sys.exit([arg])：退出程序\n\n\n用于中止当前程序的执行。\n\n\narg 可为整数（表示状态码）或字符串（会打印到 stderr）。\n\n\n0 表示正常退出；\n\n\n非零表示异常退出。\n\n\n示例：\nimport sys\nsys.exit(0)  # 正常退出\n# sys.exit(&quot;发生错误&quot;)  # 异常退出并输出错误信息\n\n3. sys.path：模块搜索路径列表\n\n类型：list\n描述：Python 导入模块时搜索的路径列表。\n可动态添加自定义模块路径，支持运行时扩展。\n\n示例：\nimport sys\nprint(sys.path)  # 输出当前模块查找路径列表\nsys.path.append(&#039;/my/custom/path&#039;)  # 添加自定义路径\n\n4. sys.platform：当前平台标识符\n\n类型：str\n描述：用于判断操作系统类型，常用于跨平台代码中。\n\n常见值：\n\n&#039;win32&#039;：Windows\n&#039;linux&#039;：Linux\n&#039;darwin&#039;：macOS\n\n示例：\nimport sys\nprint(sys.platform)\n\n5. sys.version / sys.version_info：Python 版本信息\n\nsys.version：返回完整版本字符串（含构建信息）。\nsys.version_info：返回结构化版本元组，可用于条件判断。\n\n示例：\nimport sys\nprint(sys.version)         # 例如：&#039;3.10.12 (tags/v3.10.12:...)&#039;\nprint(sys.version_info)    # 例如：(3, 10, 12, &#039;final&#039;, 0)\n\n6. sys.stdin / sys.stdout / sys.stderr：标准输入输出流\n\n描述：表示标准输入、标准输出和标准错误输出流，支持重定向或替换。\n常用于命令行交互、日志输出捕获等场景。\n\n示例：\nimport sys\nsys.stdout.write(&quot;Hello\\n&quot;)  # 输出到标准输出\ndata = sys.stdin.readline()  # 从标准输入读取一行\n\n7. sys.modules：已加载模块字典\n\n类型：dict\n描述：当前已导入模块的缓存，键为模块名，值为模块对象。\n可用于动态模块管理，如替换、卸载模块。\n\n示例：\nimport sys\nprint(list(sys.modules.keys()))  # 打印当前加载的模块名列表\n\n8. sys.getsizeof(obj)：获取对象内存占用大小\n\n类型：function\n描述：返回对象在内存中的字节大小（包括基本开销）。\n\n示例：\nimport sys\nprint(sys.getsizeof(&quot;hello&quot;))  # 输出字符串占用的内存大小\n\n9. sys.maxsize：整数支持的最大值\n\n描述：表示 Python int 类型支持的最大值，间接反映平台位数。\n在 64 位系统上，通常为 2**63 - 1。\n\n示例：\nimport sys\nprint(sys.maxsize)\n\n10. sys.executable：Python 解释器路径\n\n描述：返回当前正在运行的 Python 解释器的完整路径。\n\n示例：\nimport sys\nprint(sys.executable)\n\n11. sys.getrecursionlimit() / sys.setrecursionlimit(limit)：获取/设置递归深度\n\nPython 默认递归限制约为 1000 层。\n设置过高可能导致栈溢出，应谨慎使用。\n\n示例：\nimport sys\nprint(sys.getrecursionlimit())  # 输出当前最大递归深度\nsys.setrecursionlimit(2000)     # 设置新的递归深度上限\n\n三、典型使用场景汇总\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能需求对应 sys成员命令行参数处理sys.argv程序终止控制sys.exit()动态模块路径管理sys.path操作系统判断sys.platform版本信息获取sys.version, sys.version_info内存使用分析sys.getsizeof()输入输出流控制sys.stdin/ sys.stdout/ sys.stderr模块缓存管理sys.modules获取最大整数值sys.maxsize获取解释器路径sys.executable控制递归深度sys.setrecursionlimit()"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/winreg-模块":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/winreg-模块","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/winreg 模块.md","title":"winreg 模块","links":[],"tags":[],"content":"winreg 模块详解\n一、模块概述\nwinreg 是 Python 标准库中的模块，仅适用于 Windows 操作系统，用于以编程方式访问和操作 Windows 注册表。注册表是一个分层的数据库，用于存储操作系统和应用程序的配置信息。winreg 提供对注册表的读写、创建、删除、备份等功能。\n在 Python 2.x 中，该模块名为 _winreg，Python 3.x 统一为 winreg。\n\n二、注册表结构\n注册表采用树状结构，包含若干根键（Root Keys），由若干子键（Subkeys）和键值（Values）组成。\n常用根键（常量名）包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n根键常量说明HKEY_CLASSES_ROOT文件类型关联信息、COM 对象注册表项等。HKEY_CURRENT_USER当前登录用户的配置信息。HKEY_LOCAL_MACHINE整个系统（所有用户）的硬件和软件配置信息。HKEY_USERS所有用户的配置文件集合。HKEY_CURRENT_CONFIG当前硬件配置文件信息。\n键值的数据类型示例：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型常量含义REG_SZ字符串REG_DWORD32 位整数REG_BINARY原始二进制数据REG_MULTI_SZ多字符串列表（以空字符分隔）REG_EXPAND_SZ含变量引用的字符串\n\n三、核心函数详解\n1. 打开与关闭注册表键\nimport winreg\n \n# 打开注册表键\nkey = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r&quot;SOFTWARE\\Microsoft&quot;)\n \n# 使用后关闭\nwinreg.CloseKey(key)\n\n**OpenKey(key, sub_key, reserved=0, access=KEY_READ)**打开一个现有的注册表键。返回一个 PyHKEY 对象。\n**CloseKey(hkey)**\n显式释放已打开的键资源。\n\n\n2. 创建与删除键\n# 创建键\nkey = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\nwinreg.CloseKey(key)\n \n# 删除键（必须为空键）\nwinreg.DeleteKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\n\n**CreateKey(key, sub_key)** / **CreateKeyEx(...)**\n创建或打开一个子键（若已存在则打开）。\n**DeleteKey(key, sub_key)** / **DeleteKeyEx(...)**\n删除指定的子键（子键必须为空，否则抛出异常）。\n\n\n3. 读取与设置键值\n# 读取默认值\nvalue = winreg.QueryValue(winreg.HKEY_LOCAL_MACHINE, r&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion&quot;)\nprint(value)\n \n# 读取指定键值\nkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\nval, typ = winreg.QueryValueEx(key, &quot;Version&quot;)\nprint(val, typ)\nwinreg.CloseKey(key)\n \n# 设置键值\nkey = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\nwinreg.SetValueEx(key, &quot;Version&quot;, 0, winreg.REG_SZ, &quot;1.0&quot;)\nwinreg.CloseKey(key)\n \n# 删除键值\nkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;, 0, winreg.KEY_SET_VALUE)\nwinreg.DeleteValue(key, &quot;Version&quot;)\nwinreg.CloseKey(key)\n\n4. 枚举子键与键值\n# 枚举子键\nkey = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r&quot;SOFTWARE&quot;)\ni = 0\nwhile True:\n    try:\n        print(winreg.EnumKey(key, i))\n        i += 1\n    except OSError:\n        break\nwinreg.CloseKey(key)\n \n# 枚举键值\nkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\ni = 0\nwhile True:\n    try:\n        name, value, typ = winreg.EnumValue(key, i)\n        print(name, value, typ)\n        i += 1\n    except OSError:\n        break\nwinreg.CloseKey(key)\n\n5. 注册表备份与恢复\n# 保存注册表项（需要管理员权限）\nkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;)\nwinreg.SaveKey(key, r&quot;C:\\backup.reg&quot;)\nwinreg.CloseKey(key)\n \n# 加载注册表文件为子键\nwinreg.LoadKey(winreg.HKEY_LOCAL_MACHINE, r&quot;TempKey&quot;, r&quot;C:\\backup.reg&quot;)\n \n# 强制写入注册表（可选）\nwinreg.FlushKey(key)\n\n四、使用注意事项\n1. 权限管理\n\n某些注册表项（特别是 HKEY_LOCAL_MACHINE）需要管理员权限。\n运行脚本前请右键“以管理员身份运行” Python 解释器。\n使用 KEY_WOW64_32KEY / KEY_WOW64_64KEY 可指定访问注册表的 32/64 位视图。\n\n2. 错误处理建议\n操作注册表易出错，应配合 try-except 块处理：\ntry:\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r&quot;SOFTWARE\\NonExist&quot;)\nexcept FileNotFoundError:\n    print(&quot;键不存在&quot;)\nexcept PermissionError:\n    print(&quot;权限不足&quot;)\n3. 推荐使用上下文管理器（Python 3.2+）\nwith winreg.OpenKey(winreg.HKEY_CURRENT_USER, r&quot;Software\\MyApp&quot;) as key:\n    value, typ = winreg.QueryValueEx(key, &quot;Version&quot;)\n    print(value)\n\n五、参考用途示例\n\n检查软件是否安装；\n设置开机自启项（如写入 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run）；\n读取系统配置，如桌面路径、关机策略等；\n制作注册表清理工具；\n编写自动化脚本调整系统参数。\n\n\n六、结语\nwinreg 模块为开发者提供了强大的工具，可以直接操控 Windows 系统底层配置。但也正因为其能力强大，操作不当可能导致系统不稳定，建议务必做好备份并谨慎使用，尤其在执行删除和修改操作时。\n如需进行更复杂的注册表操作（如遍历递归子键、跨平台处理等），可考虑将其与其他模块（如 ctypes 或 subprocess 调用 reg 命令）配合使用。"},"python/2.常用库与工具/标准库与内置模块/操作系统接口/概览":{"slug":"python/2.常用库与工具/标准库与内置模块/操作系统接口/概览","filePath":"python/2.常用库与工具/标准库与内置模块/操作系统接口/概览.md","title":"概览","links":[],"tags":[],"content":"操作系统交互模块\nPython 提供了多个标准库与内置模块用于与操作系统交互，这些模块封装了底层的系统调用接口，使得在不同平台之间开发自动化脚本、管理文件系统、控制子进程等任务变得高效而一致。本文将对常用的相关模块进行系统性讲解，包括功能、使用场景及常用方法。\n\n一、os 模块（操作系统接口的核心模块）\nos 模块是 Python 与操作系统交互的基础，提供了对文件系统、路径、环境变量、进程等资源的访问接口。\n1. 功能概述\n\n跨平台文件/目录操作\n获取系统相关信息\n启动/终止进程\n环境变量访问与操作\n\n2. 常用函数示例\nimport os\n \n# 当前工作目录\nos.getcwd()                 # 获取当前工作目录\nos.chdir(&#039;/path/to/dir&#039;)   # 修改当前工作目录\n \n# 路径操作（推荐使用 os.path.join 而非字符串拼接）\nos.path.join(&#039;dir&#039;, &#039;file.txt&#039;)  # 拼接路径\nos.path.exists(path)             # 判断路径是否存在\nos.path.isfile(path)             # 是否为文件\nos.path.isdir(path)              # 是否为目录\nos.path.abspath(path)            # 获取绝对路径\n \n# 文件与目录操作\nos.mkdir(&#039;newdir&#039;)               # 创建目录\nos.makedirs(&#039;a/b/c&#039;)             # 递归创建目录\nos.remove(&#039;file.txt&#039;)            # 删除文件\nos.rmdir(&#039;dir&#039;)                  # 删除空目录\nos.rename(&#039;a.txt&#039;, &#039;b.txt&#039;)      # 重命名文件或目录\nos.listdir(&#039;.&#039;)                  # 列出目录内容\n \n# 环境变量\nos.environ.get(&#039;HOME&#039;)          # 获取环境变量\nos.environ[&#039;MY_VAR&#039;] = &#039;123&#039;    # 设置环境变量\n \n# 执行系统命令（不推荐用于复杂场景）\nos.system(&#039;ls -la&#039;)\n\n二、os.path 子模块（路径操作工具）\nos.path 是专用于处理路径的子模块，适用于进行跨平台文件路径拼接与分解。\n常用函数\nos.path.basename(&#039;/a/b/c.txt&#039;)   # 返回 &#039;c.txt&#039;\nos.path.dirname(&#039;/a/b/c.txt&#039;)    # 返回 &#039;/a/b&#039;\nos.path.splitext(&#039;file.py&#039;)      # 返回 (&#039;file&#039;, &#039;.py&#039;)\nos.path.getsize(&#039;file.txt&#039;)      # 获取文件大小（字节）\nos.path.getmtime(&#039;file.txt&#039;)     # 获取最近修改时间（时间戳）\n💡 提示：Python 3.4+ 推荐使用 pathlib 替代 os.path，提高代码可读性与维护性。\n\n三、shutil 模块（文件与目录的高级操作）\nshutil 提供比 os 更高层级的文件和目录管理功能，适用于复制、移动、压缩等任务。\n常用函数\nimport shutil\n \nshutil.copy(&#039;a.txt&#039;, &#039;b.txt&#039;)         # 复制文件（保留权限）\nshutil.copytree(&#039;src&#039;, &#039;dst&#039;)         # 递归复制目录\nshutil.rmtree(&#039;dir&#039;)                  # 递归删除目录\nshutil.move(&#039;a.txt&#039;, &#039;dir/&#039;)          # 移动文件或重命名\nshutil.disk_usage(&#039;/&#039;)                # 查看磁盘使用情况\n\n四、pathlib 模块（面向对象的路径处理）\npathlib 是现代化的路径处理模块，提供类对象接口，功能更清晰且支持链式调用。\n示例代码\nfrom pathlib import Path\n \np = Path(&#039;/usr/bin&#039;)\np.exists()          # 判断路径是否存在\np.is_dir()          # 是否为目录\np.name              # 文件名：&#039;bin&#039;\np.parent            # 父路径：&#039;/usr&#039;\np / &#039;python3&#039;       # 路径拼接（推荐写法）\n\n五、sys 模块（访问 Python 解释器）\n提供对解释器运行时环境的访问，常用于命令行脚本与环境配置。\n常用功能\nimport sys\n \nsys.argv                    # 获取命令行参数列表\nsys.exit(0)                 # 正常退出程序\nsys.platform                # 获取当前平台名（如 &#039;linux&#039;, &#039;win32&#039;）\nsys.path                    # 模块搜索路径\nsys.getfilesystemencoding() # 文件系统编码（如 &#039;utf-8&#039;）\n\n六、subprocess 模块（推荐的子进程控制方式）\n替代 os.system() 的高级接口，适用于执行外部命令并获取输出、处理错误信息等。\n示例\nimport subprocess\n \n# 简单执行命令\nresult = subprocess.run([&#039;ls&#039;, &#039;-l&#039;], capture_output=True, text=True)\nprint(result.stdout)\n \n# 获取命令输出（可能抛出异常）\noutput = subprocess.check_output([&#039;ls&#039;, &#039;-l&#039;], text=True)\n\n七、platform 模块（系统与平台信息）\n用于获取操作系统、处理器、Python 版本等详细信息，便于编写跨平台代码。\n示例\nimport platform\n \nplatform.system()         # 返回操作系统名称，如 &#039;Windows&#039;\nplatform.release()        # 返回系统版本号\nplatform.machine()        # 返回机器类型，如 &#039;x86_64&#039;\nplatform.processor()      # 返回处理器信息\nplatform.python_version() # 返回 Python 版本号\n\n八、getpass 模块（安全密码输入）\n适用于命令行程序中安全地获取用户输入的密码，输入过程不会回显。\nimport getpass\n \npassword = getpass.getpass(&quot;请输入密码: &quot;)\n\n九、tempfile 模块（临时文件与目录管理）\n用于生成临时文件与目录，适合处理中间数据或敏感信息，支持自动清理。\n示例\nimport tempfile\n \nwith tempfile.TemporaryFile() as tmp:\n    tmp.write(b&#039;hello&#039;)\n    tmp.seek(0)\n    print(tmp.read())\n\n十、signal 模块（系统信号处理）\n处理操作系统信号（如 SIGINT），常用于编写响应中断的安全退出逻辑。\nimport signal\nimport sys\n \ndef handler(sig, frame):\n    print(&quot;检测到 Ctrl+C，正在退出...&quot;)\n    sys.exit(0)\n \nsignal.signal(signal.SIGINT, handler)\n\n十一、stat 模块（文件权限与类型检查）\n通常与 os.stat() 搭配使用，用于检测文件权限、类型、inode 信息等。\nimport os, stat\n \nst = os.stat(&#039;file.txt&#039;)\nif stat.S_ISDIR(st.st_mode):\n    print(&quot;是目录&quot;)\n\n十二、其他相关模块（简要说明）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n模块名功能说明平台fcntl文件描述符控制，设置锁等Unixresource设置进程资源限制（如内存、时间）Unixpwd获取用户信息Unixgrp获取用户组信息Unixwinreg操作 Windows 注册表Windows\n\n总结：模块功能与跨平台支持概览\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n模块功能简介跨平台支持os基础操作系统接口✔️os.path字符串路径处理✔️pathlib面向对象路径操作✔️shutil文件与目录高级操作✔️subprocess子进程控制与命令执行✔️sysPython 解释器运行环境信息✔️platform获取平台/系统/CPU 信息✔️tempfile临时文件与目录管理✔️getpass安全密码输入✔️signal信号处理部分stat文件属性与权限检查✔️winregWindows 注册表操作✖️ (仅 Windows)"},"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/decimal":{"slug":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/decimal","filePath":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/decimal.md","title":"decimal","links":[],"tags":[],"content":"1. decimal 模块概述\n\n\ndecimal 模块旨在提供 十进制浮点运算，弥补内置二进制浮点（float）在极端精度或金融场景中的不足。\n\n\n核心类为 Decimal，它可以表示任意精度的十进制数，并可通过上下文（Context）灵活控制精度、四舍五入方式、溢出处理等。\n\n\n适用场景：\n\n\n金融计算（如货币换算、利息计算），需要避免二进制浮点的舍入误差。\n\n\n需要确定精度和可预测舍入行为的科学计算。\n\n\n任意精度运算：当 float 不足以表达非常大或非常小的数时，可使用 Decimal。\n\n\ndecimal 模块遵循 IEEE 854-1987 标准（为 IEEE 754 的先驱），并在此基础上增加了若干 Python 友好的功能。\n\n\n使用时通常写到：\nfrom decimal import Decimal, getcontext, localcontext\n\n2. Decimal 类及其初始化\n2.1 创建 Decimal 对象\nDecimal 可通过以下方式初始化：\n\n字符串 初始化（推荐）\n\nfrom decimal import Decimal\na = Decimal(&#039;3.14159&#039;)\nb = Decimal(&#039;-0.01&#039;)\n\n直接从字符串创建时，能够精确表示十进制数值，不会出现二进制浮点的舍入误差。\n\n\n整数 初始化\n\nc = Decimal(12345)\n\n从整数构造无需考虑精度问题，结果与 int 精确对应。\n\n\n元组 初始化（不常用）\n\nt = (0, (1, 2, 3, 4), -2)  # 表示 1234 × 10⁻² = 12.34\nd = Decimal(t)\n\n元组格式为 (sign, digits, exponent)，其中 sign 为 0（正）或 1（负），digits 为整型序列（每个元素 0–9），exponent 为十进制指数（整数）。\n这对于从外部解析好的数值构建 Decimal 可能有用，但日常编码多使用字符串或整数。\n\n\n浮点数 初始化（谨慎）\n\nx = Decimal(1.1)\nprint(x)  # 可能显示 1.100000000000000088817841970012523233890533447265625\n\n不推荐 从 float 构造，因为这样会保留二进制浮点的不精确位。若已有 float，应先使用 format 或者 str 使其定点：\n\nx = Decimal(str(1.1))  # 更安全，得到 Decimal(&#039;1.1&#039;)\n2.2 Decimal 的内部表示\nDecimal 内部使用一个“带符号的整数 + 指数”模型：\n\n\nvalue=(±)integer_mantissa×10exponent \\text{value} = (\\pm) \\text{integer_mantissa} \\times 10^{\\text{exponent}}value=(±)integer_mantissa×10exponent\n\n\n每个 Decimal 对象都携带：\n\n\nsign（符号位）：0 表示正，1 表示负；\n\n\ndigits（系数数组）：一个 0–9 的数字元组，保存有效数字；\n\n\nexponent：整数，表示小数点相对于系数的位置。\n\n\n例如，Decimal(&#039;12.345&#039;) 内部等价于 (sign=0, digits=(1,2,3,4,5), exponent=-3)。\n2.3 inspect：查看 Decimal 内部结构\nfrom decimal import Decimal\n \nd = Decimal(&#039;12.345&#039;)\nprint(d.as_tuple())\n# 输出：DecimalTuple(sign=0, digits=(1, 2, 3, 4, 5), exponent=-3)\n\nDecimal.as_tuple() 返回 DecimalTuple(sign, digits, exponent)，方便调试或做自定义运算时查看底层数据。\n\n\n3. 四则运算与精度控制\n3.1 基本运算\nDecimal 支持以下常用运算符，与内置数值类型类似：\n\n加法：+\n减法：-\n乘法：*\n除法：/\n整除：//（向 下 整 除）\n取余：%\n幂运算：**\n\n示例：\nfrom decimal import Decimal\n \na = Decimal(&#039;2.5&#039;)\nb = Decimal(&#039;1.3&#039;)\n \nprint(a + b)   # Decimal(&#039;3.8&#039;)\nprint(a - b)   # Decimal(&#039;1.2&#039;)\nprint(a * b)   # Decimal(&#039;3.25&#039;)\nprint(a / b)   # 结果根据当前上下文精度而定\nprint(a // b)  # 向下取整\nprint(a % b)   # 取余\nprint(a ** 2)  # Decimal(&#039;6.25&#039;)\n3.2 精度（Precision）与上下文（Context）\n\nDecimal 的运算受限于 上下文（Context） 中设置的 精度（precision），即最多保留多少位有效数字。\n默认上下文 (getcontext()) 的 precision 通常为 28 位。如果运算结果超过上下文精度，模块会根据四舍五入模式（rounding）截断或抛出异常。\n\n示例：\nfrom decimal import Decimal, getcontext\n \n# 默认精度通常是 28\nctx = getcontext()\nprint(ctx.prec)  # 28\n \n# 将精度改为 5\nctx.prec = 5\n \nx = Decimal(&#039;1&#039;) / Decimal(&#039;3&#039;)\nprint(x)  # Decimal(&#039;0.33333&#039;)，5 位有效数字\n \n# 再改成 10\nctx.prec = 10\nprint(Decimal(&#039;1&#039;) / Decimal(&#039;3&#039;))  # Decimal(&#039;0.3333333333&#039;)\n\n如果除法无穷循环且超出精度，会根据 rounding 截断余下部分，并且上下文中的 Inexact、Rounded 信号会被置位（参见第 9 节）。\n\n\n4. Context（上下文）与全局配置\n4.1 获取与设置全局上下文\nfrom decimal import getcontext\n \nctx = getcontext()  \n# getcontext() 返回当前线程的全局 Context 对象（Context 实例）\n\n\n一个 Context 对象包含以下核心属性（部分常用列举）：\n\n\nprec：精度（最大有效数字位数）。\n\n\nrounding：四舍五入模式（参考第 5 节）。\n\n\nEmin / Emax：可表示的最小/最大指数范围，超出会触发下溢或上溢。\n\n\ncapitals：当输出科学计数法时，指数部分 E 是否大写（0/1）。\n\n\nclamp：是否对指数做截断，使其在一定规则内；一般不常改。\n\n\nflags：记录上一次运算过程中触发的所有信号（如 Inexact, Overflow 等）。\n\n\ntraps：哪些信号要作为异常抛出。\n\n\n示例：\nfrom decimal import getcontext, InvalidOperation\n \nctx = getcontext()\nctx.prec = 10\nctx.rounding = &#039;ROUND_HALF_UP&#039;\nctx.Emin = -999999\nctx.Emax = 999999\n# 打印当前所有设置\nprint(ctx)\n4.2 设置全局上下文的影响\n\n修改 getcontext() 返回的上下文后，后续所有使用 Decimal 进行的运算都会遵循该配置。\n在多线程环境下，每个线程都有独立的上下文，不会相互干扰。\n\n\n5. 四舍五入（Rounding）模式\ndecimal 模块提供了多种舍入策略，可通过上下文 rounding 属性选择。常见值有：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n模式名称含义ROUND_HALF_UP四舍五入，即：小数部分 ≥ 0.5 向上，否则向下。ROUND_HALF_EVEN（默认）银行家舍入：当尾数正好为 0.5 时，向最近的偶数舍入。ROUND_DOWN（截断）直接截断小数部分（向 0 方向靠拢）。ROUND_UP绝对值方向“进位”，即不管小数大小，都向更大绝对值方向舍入。ROUND_CEILING（向正无穷大舍入）如果值为正，小数部分非零则向上；负值则向下（绝对值减小）。ROUND_FLOOR（向负无穷大舍入）如果值为正，小数部分非零则向下；负值则向上（绝对值增大）。ROUND_05UP如果最后一位数字 ≤ 4，则舍入到较近的整数（相当于 ROUND_DOWN）；如果最后一位数字 ≥ 5，则向远离零方向舍入一个单位。\n示例演示不同舍入策略在除法计算中的表现：\nfrom decimal import Decimal, getcontext\n \nnums = (Decimal(&#039;1&#039;), Decimal(&#039;6&#039;))\ndividend, divisor = nums\n \nfor mode in [&#039;ROUND_HALF_UP&#039;, &#039;ROUND_HALF_EVEN&#039;, &#039;ROUND_DOWN&#039;, &#039;ROUND_UP&#039;, &#039;ROUND_CEILING&#039;, &#039;ROUND_FLOOR&#039;, &#039;ROUND_05UP&#039;]:\n    ctx = getcontext().copy()\n    ctx.prec = 3\n    ctx.rounding = mode\n    result = dividend.__truediv__(divisor, context=ctx)\n    print(f&quot;{mode:15} → {result}&quot;)\n可能输出：\nROUND_HALF_UP   → 0.167\nROUND_HALF_EVEN → 0.167\nROUND_DOWN      → 0.166\nROUND_UP        → 0.167\nROUND_CEILING   → 0.167\nROUND_FLOOR     → 0.166\nROUND_05UP      → 0.167\n\n上例中 1/6 ≈ 0.166666…，在 3 位精度下，尾数第 4 位为 6；多数模式都将 0.1666… 舍入为 0.167，唯有 ROUND_DOWN 和 ROUND_FLOOR 取 0.166。\n\n\n6. 精确控制：Quantize 与 Normalize\n有时需要将一个 Decimal 强制调整为某个固定小数位数。典型用例：货币值保留两位小数。\n6.1 quantize 方法\nd = Decimal(&#039;3.1415926&#039;)\n# 保留两位小数，一般用 ROUND_HALF_UP (四舍五入)\nresult = d.quantize(Decimal(&#039;0.01&#039;), rounding=&#039;ROUND_HALF_UP&#039;)\nprint(result)  # 3.14\n\n\nquantize(self, exp, rounding=None, context=None)：\n\n\nexp：为一个 Decimal，其指数部分表明目标小数位数。例如：\n\n\nDecimal(&#039;0.01&#039;) → 保留到小数点后 2 位；\n\n\nDecimal(&#039;1e-3&#039;) 等价于 Decimal(&#039;0.001&#039;)，保留到小数点后 3 位；\n\n\nDecimal(&#039;1&#039;) → 向整数舍入；\n\n\nDecimal(&#039;10&#039;) → 以 10 为单位舍入（如 Decimal(&#039;27&#039;).quantize(Decimal(&#039;10&#039;)) = 30）。\n\n\nrounding：可选舍入模式，若不指定则使用当前上下文。\n\n\n注意：\n\n如果目标精度（exp）比当前数值本身 “更精细” 但上下文精度不足，可能会触发 Inexact 信号或引发异常（若上下文 traps 设置了 Inexact）。\nquantize 会强行调整指数，因此可能会改变数值长度和格式。\n\n6.2 normalize 方法\nd1 = Decimal(&#039;3.14000&#039;)\nprint(d1.normalize())  # 3.14\n \nd2 = Decimal(&#039;0E+3&#039;)\nprint(d2.normalize())  # Decimal(&#039;0E+3&#039;)，规范化后仍保持指数形式\n\nnormalize() 可去掉尾部无意义的零，使表示更紧凑。\n如果结果为零，则指数会保持为原始幂次，以便区分 “0” 与 “0E-5” 等含义。\n\n\n7. 特殊值（NaN、Infinity）\nDecimal 支持以下特殊值，与 IEEE 754 浮点类似：\n\n正/负无限（Infinity）\n\nfrom decimal import Decimal\ninf = Decimal(&#039;Infinity&#039;)\nneg_inf = Decimal(&#039;-Infinity&#039;)\n\n非数（NaN, Not a Number）\n\nnan = Decimal(&#039;NaN&#039;)\n\n带标识符的 NaN（常用于调试或携带元信息）\n\nnan_q = Decimal(&#039;sNaN123&#039;)    # 带符号的信号 NaN（quiet NaN）\nnan_s = Decimal(&#039;NaNpayload&#039;) # 带 payload 的 NaN\n\n同样存在 ±0 的区分\n\n\nDecimal(&#039;0&#039;) 与 Decimal(&#039;-0&#039;) 是不同的，符号位不同，但在数值上同等。\nDecimal(&#039;-0&#039;) 可通过 is_signed() 方法判断：\n\nz1 = Decimal(&#039;0&#039;)\nz2 = Decimal(&#039;-0&#039;)\nprint(z1 == z2)         # True\nprint(z2.is_signed())   # True\nprint(z1.is_signed())   # False\n7.1 特殊值参与运算的规则\n\n\n任何数与 NaN 运算结果一般为 NaN，但部分函数或上下文信号可能会触发异常。\n\n\n与 Infinity 运算遵循数学规则：\n\n\nx + Infinity = Infinity，x * Infinity 需视 x 符号；\n\n\nInfinity - Infinity = NaN；\n\n\n0 * Infinity = NaN；\n\n\n可以使用 is_nan()、is_infinite()、is_finite() 等方法判断特殊值：\n\n\nd = Decimal(&#039;NaN&#039;)\nprint(d.is_nan())       # True\nprint(d.is_normal())    # False\nprint(d.is_finite())    # False\n\n8. 本地上下文管理（localcontext）\n在某些场景下，希望针对某段代码临时修改精度或舍入模式，而不影响全局上下文。此时可以使用 localcontext()。\nfrom decimal import Decimal, getcontext, localcontext\n \n# 全局上下文\nprint(getcontext().prec)  # 假设 28\n \na = Decimal(&#039;1&#039;) / Decimal(&#039;7&#039;)\nprint(a)  # 按默认 28 位精度显示\n \n# 临时修改上下文\nwith localcontext() as ctx:\n    ctx.prec = 5\n    ctx.rounding = &#039;ROUND_DOWN&#039;\n    b = Decimal(&#039;1&#039;) / Decimal(&#039;7&#039;)\n    print(b)  # 保留 5 位小数且向下截断\n \n# 上下文恢复全局设置\nc = Decimal(&#039;1&#039;) / Decimal(&#039;7&#039;)\nprint(c)  # 仍按 28 位精度\n\nlocalcontext() 返回一个新的上下文拷贝，进入 with 块后对其修改只在块内生效，块结束后自动恢复上一级上下文。\n若需要跨多个函数或模块共享临时上下文，也可以手动将 localcontext() 的返回值赋给变量，并显式 copy()。\n\n\n9. 信号与异常（Signals &amp; Exceptions）\n9.1 Context 中的 flags 与 traps\n\n当 Decimal 运算过程中发生以下情况时，会“发出”相应的信号（Signal），并将上下文中的 flags[signal_name] 置为 True。\n如果上下文中的 traps[signal_name] 设置为 True，则该信号会转变为 DecimalException 并抛出。否则，仅在 flags 中记录。\n\n常见信号（及含义）：\n\n**InvalidOperation**：非法操作，例如 0 / 0、Infinity - Infinity。\n**DivisionByZero**：除以零操作，例如 Decimal(&#039;1&#039;) / Decimal(&#039;0&#039;)。\n**Overflow**：结果指数或数字超出了上下文的 Emax/prec 能力。\n**Underflow**：结果指数低于 Emin 且不等于 0，引起小于最小可表示数。\n**Inexact**：计算结果不是精确的十进制数，需要舍入时置位。\n**Rounded**：执行舍入操作时置位（通常与 Inexact 同时出现）。\n**Subnormal**（又称 Denormal）：结果指数虽然在范围内，但系数不能填满上下文精度，表示次正规数。\n\n示例：观察信号发生与捕获\nfrom decimal import Decimal, getcontext, DivisionByZero, InvalidOperation\n \nctx = getcontext().copy()\nctx.prec = 5\nctx.traps[DivisionByZero] = True   # 把除零作为异常触发\nctx.traps[InvalidOperation] = False\n \n# 捕获除以零\ntry:\n    result = Decimal(&#039;1&#039;) / Decimal(&#039;0&#039;)\nexcept DivisionByZero as e:\n    print(&quot;捕获到除零异常：&quot;, e)\n \n# 如果是无效操作（0/0），因为 trap=False，则不会抛异常，但 flags 会被置位\nres = ctx.divide(Decimal(&#039;0&#039;), Decimal(&#039;0&#039;))  # 0/0\nprint(&quot;InvalidOperation 信号置位：&quot;, ctx.flags[InvalidOperation])\n\nflags 会在发生信号后持久保持，直到手动重置（ctx.clear_flags()）。\ntraps 列表决定了哪些信号会抛出对应异常。\n\n9.2 常见异常类型\n\nDecimalException：decimal 模块所有异常的基类。\nDivisionByZero：除以零时抛出（若 trap=True）。\nInvalidOperation：无效运算时抛出（如 sqrt(-1)、log(0)、0/0 等）。\nOverflow：数值太大溢出上限时抛出（若 trap=True）。\nUnderflow：数值太小引起下溢时抛出（若 trap=True）。\nSubnormal：次正规数警告时抛出（极少使用）。\nRounded、Inexact：仅在 trap=True 时抛出，否则仅置位信号。\n\n示例：\nfrom decimal import getcontext, Decimal, Overflow\n \nctx = getcontext().copy()\nctx.prec = 2\nctx.rounding = &#039;ROUND_HALF_UP&#039;\nctx.traps[Overflow] = True\n \n# 构造一个可能溢出的运算\nlarge = Decimal(&#039;9.9e+99&#039;)\ntry:\n    res = large * large\nexcept Overflow as e:\n    print(&quot;溢出异常：&quot;, e)\n\n将 traps[Overflow] 设置为 False 时，运算结果为 Infinity，不会抛异常，但 ctx.flags[Overflow] 会变为 True。\n\n\n10. 用途与性能注意\n10.1 典型应用场景\n\n金融与货币计算\n\n\n需要 100% 确定小数位且不允许二进制浮点误差。\n例如：银行利息计算、汇率转换、会计报表等。\n常配合 quantize(Decimal(&#039;0.01&#039;)) 保持两位小数。\n\n\n科学计算（对精度严格要求的场合）\n\n\n当需要确定小数点后若干位的高精度运算时，Decimal 可满足较长尾数需求。\n例如：天文计算、物理模拟中某些极端参数。\n\n\n自定义舍入规则\n\n\n不同场景（会计、金融、统计）常有不同舍入规范。Decimal 支持灵活设置 rounding。\n\n\n财务报表输出\n\n\n生成报表前进行汇总、换算等运算时，可以保持精度一致。\n\n10.2 性能对比与注意点\n\n\n与内置 float 相比，Decimal 运算速度显著较慢，原因在于它是基于 Python 对象和高精度算法实现的。\n\n\n在不需要绝对精度且对性能有严格要求时，尽量使用 float 或者 fractions.Fraction（但 Fraction 适合整除与分数运算，非浮点）。\n\n\n建议：只在必要的地方对关键数据使用 Decimal，其他部分可以暂用 float。\n\n\n若需对大量数据做十进制运算，可考虑：\n\n\n缩小上下文精度（prec）到刚好满足需求，不要过度浪费；\n\n\n避免在循环中频繁修改上下文；\n\n\n预先初始化所有 Decimal 实例，减少运行时重复构造。\n\n\n\n11. 综合示例\n下面给出若干常见场景的综合示例，帮助你加深对 decimal 模块的理解。\n11.1 货币计算：累加、汇率换算\nfrom decimal import Decimal, getcontext, ROUND_HALF_UP\n \n# 全局上下文（假设银行对小数位数要求严格）\nctx = getcontext()\nctx.prec = 10\nctx.rounding = ROUND_HALF_UP\n \n# 假设有若干笔交易，需要汇总并转换为人民币（CNY）\ntransactions = [\n    (&#039;USD&#039;, Decimal(&#039;123.45&#039;)),\n    (&#039;EUR&#039;, Decimal(&#039;78.90&#039;)),\n    (&#039;USD&#039;, Decimal(&#039;10.00&#039;)),\n    (&#039;JPY&#039;, Decimal(&#039;5000&#039;)),\n]\n \n# 汇率（示例）：1 USD = 6.5 CNY；1 EUR = 7.8 CNY；1 JPY = 0.06 CNY\nrates = {\n    &#039;USD&#039;: Decimal(&#039;6.5&#039;),\n    &#039;EUR&#039;: Decimal(&#039;7.8&#039;),\n    &#039;JPY&#039;: Decimal(&#039;0.06&#039;),\n}\n \ntotal_cny = Decimal(&#039;0&#039;)\nfor currency, amount in transactions:\n    cny_amount = (amount * rates[currency]).quantize(Decimal(&#039;0.01&#039;))\n    print(f&quot;{currency} {amount} → CNY {cny_amount}&quot;)\n    total_cny += cny_amount\n \nprint(f&quot;总计人民币：CNY {total_cny.quantize(Decimal(&#039;0.01&#039;))}&quot;)\n解析：\n\n首先设置上下文 prec=10、rounding=ROUND_HALF_UP，保证后续四则运算符合财务要求。\n用 quantize(Decimal(&#039;0.01&#039;)) 保持两位小数，每次汇率换算后立即四舍五入到分。\n最后累加所有结果，并再次四舍五入到分。\n\n11.2 科学计算：高精度圆周率与幂运算\nfrom decimal import Decimal, getcontext, ROUND_FLOOR\n \n# 计算高精度的圆周率 π（使用 20 位小数）——使用“莱布尼茨级数”（速度较慢，仅示例）\ndef compute_pi(n_terms):\n    getcontext().prec = 25\n    getcontext().rounding = ROUND_FLOOR\n    pi = Decimal(0)\n    one = Decimal(1)\n    for k in range(n_terms):\n        term = (one / (Decimal(2) * Decimal(k) + one)) * ((-one) ** k)\n        pi += term\n    return pi * Decimal(4)\n \npi_approx = compute_pi(100000)\nprint(&quot;π ≈&quot;, pi_approx)\n\n本例用“莱布尼茨级数”近似计算 π，由于收敛速度极慢，仅供演示高精度 Decimal 用法。\n先设置 prec=25，保持 25 位有效数字，再将每次加法按 ROUND_FLOOR 向下取整。\n\n11.3 本地上下文：不同运算段使用不同精度\nfrom decimal import Decimal, getcontext, localcontext\n \n# 全局上下文：普通精度\ngetcontext().prec = 6\na = Decimal(&#039;1.23456789&#039;) + Decimal(&#039;2.34567891&#039;)\nprint(&quot;全局环境下 a =&quot;, a)  # 按 6 位精度计算，存在舍入\n \n# 某段需要极高精度\nwith localcontext() as ctx:\n    ctx.prec = 20\n    b = Decimal(&#039;1.23456789&#039;) + Decimal(&#039;2.34567891&#039;)\n    print(&quot;局部高精度下 b =&quot;, b)  # 按 20 位精度计算\n \n# 离开 localcontext，恢复全局设置\nc = Decimal(&#039;1.23456789&#039;) + Decimal(&#039;2.34567891&#039;)\nprint(&quot;恢复全局下 c =&quot;, c)\n\n通过 localcontext() 创建临时上下文，各段运算精度互不干扰。\n\n11.4 信号捕获：检测除法是否精确\nfrom decimal import Decimal, getcontext, Inexact, Rounded\n \nctx = getcontext().copy()\nctx.prec = 5\nctx.traps[Inexact] = False\nctx.traps[Rounded] = False\n \n# 每次运算后，检查 flags\ndef safe_div(a, b):\n    ctx.clear_flags()\n    result = ctx.divide(a, b)\n    inexact = ctx.flags[Inexact]\n    rounded = ctx.flags[Rounded]\n    return result, inexact or rounded\n \nnums = [\n    (Decimal(&#039;1&#039;), Decimal(&#039;2&#039;)),   # 1/2 = 0.5，精确\n    (Decimal(&#039;1&#039;), Decimal(&#039;3&#039;)),   # 1/3，结果 0.33333…，舍入\n]\n \nfor a, b in nums:\n    res, is_approx = safe_div(a, b)\n    if is_approx:\n        print(f&quot;{a}/{b} 结果 {res}（非精确，需要舍入）&quot;)\n    else:\n        print(f&quot;{a}/{b} 精确结果 {res}&quot;)\n解析：\n\n将 Inexact、Rounded 信号的 trap 都设置为 False，这样不会抛出异常，但会在 flags 中记录何时发生舍入或不精确。\n通过 ctx.flags[...] 可以获知计算结果是否精确或经过舍入。\n\n\n小结\n\n**Decimal** 的设计目标：实现高精度十进制浮点运算，避免二进制浮点的舍入误差，满足金融计算与精密科学计算需求。\n初始化方式：\n\n\n首选字符串 形式 Decimal(&#039;123.456&#039;)；\n也可用整数、元组；不推荐直接用 float 构造。\n\n\nContext（上下文）：\n\n\n控制 精度（precision）、舍入模式（rounding）、指数范围（Emin/Emax）、信号与 trap 等；\ngetcontext() 返回全局上下文；localcontext() 可创建局部副本。\n\n\n四舍五入模式：\n\n\n常见的 ROUND_HALF_UP、ROUND_HALF_EVEN、ROUND_DOWN、ROUND_UP 等，适配不同场景需求。\n\n\n精确控制：\n\n\nquantize 可强制按指定指数格式舍入；\nnormalize 可去除无用尾零。\n\n\n特殊值：支持 NaN、Infinity、−0，与 IEEE 754 行为保持一致。\n信号与异常：运算过程中可通过 flags 查看信号，若在 traps 中设置则抛出相应异常。\n用例与性能：\n\n\n金融、货币、利率等场景优先使用；\n由于性能较慢，请避免对海量数据全过程使用；可视情况切换到 float 或分段使用 Decimal。\n"},"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/fractions":{"slug":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/fractions","filePath":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/fractions.md","title":"fractions","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/math":{"slug":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/math","filePath":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/math.md","title":"math","links":[],"tags":[],"content":"一、模块概述\n\n简介\n\n\nmath 模块是 Python 标准库中专门提供基础数学运算的模块，使用 C 语言实现，直接调用底层的高效数学函数。它只针对实数（非复数）进行操作，因此不能处理负数开方等复数运算；若需要复数数学，应使用 cmath 模块。\n相较于内置算术运算符和某些内置函数（如 abs()、pow()），math 提供了更多特殊函数、更高精度的浮点累计（fsum()）以及组合数学（factorial()、comb() 等）等功能，适合科学计算、统计学、工程计算等需要。\n\n\n导入方法\n\nimport math\n# 或者只导入特定函数\nfrom math import sin, pi\n\n性能与精度\n\n\n大多数 math 函数在 C 层调用 libc 的数学库（libm），性能接近原生 C。\n可以处理 IEEE-754 浮点数并返回尽可能精确的结果；对于累计求和等场景，提供了 fsum() 用于减小舍入误差。\n由于浮点数本身的局限，某些运算结果可能会出现极小的舍入误差，使用时需酌情判断（如 math.isclose() 辅助比较近似相等）。\n\n\n二、核心常量\nmath 模块定义了一些常用的数学常量，以下是其中最常用的几项：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常量含义math.pi圆周率 π，精确到浮点数能表示的极限；约 3.141592653589793math.e自然常数 e，约 2.718281828459045math.tau圆周率的两倍，即 2π，约 6.283185307179586math.inf正无穷大 (∞)，可用于标识极大值。-math.inf负无穷大 (-∞)。math.nan“非数字”（NaN）值，用于标识未定义或不可表示的浮点结果。\nimport math\n \nprint(math.pi)       # 3.141592653589793\nprint(math.e)        # 2.718281828459045\nprint(math.tau)      # 6.283185307179586\nprint(math.inf)      # inf\nprint(math.nan)      # nan\n要点提示\n\nmath.inf 与 float(&#039;inf&#039;) 等价，常用于初始化最小/最大值，或在取极限时表示“没有上界”。\nmath.nan 代表一种特殊的浮点值：与它自身都不相等（math.nan != math.nan），可用 math.isnan(x) 来检测。\n\n\n三、主要函数分类\n下面从不同功能维度对 math 模块的函数进行分类讲解。\n1. 基本算术与数值测试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.ceil(x)向上取整，返回最小的整数 ≥ x；math.floor(x)向下取整，返回最大的整数 ≤ x；math.trunc(x)截断小数部分，返回整数部分，等价于 int(x)（但对负数表现相同）；math.fabs(x)绝对值，返回浮点形式的math.isfinite(x)判断 x 是否为有限数（不是 inf也不是 nan）。math.isinf(x)判断 x 是否为正/负无穷。math.isnan(x)判断 x 是否为 NaN。\n示例：\nimport math\n \nvalues = [3.7, -2.3, math.inf, -math.inf, math.nan]\nfor v in values:\n    print(f&quot;x={v:6}  ceil={math.ceil(v) if math.isfinite(v) else &#039;NA&#039;}  floor={math.floor(v) if math.isfinite(v) else &#039;NA&#039;}  trunc={math.trunc(v) if math.isfinite(v) else &#039;NA&#039;}  fabs={math.fabs(v)}  isfinite={math.isfinite(v)}  isinf={math.isinf(v)}  isnan={math.isnan(v)}&quot;)\n输出示例：\nx=   3.7  ceil=4  floor=3  trunc=3  fabs=3.7       isfinite=True  isinf=False  isnan=False\nx=  -2.3  ceil=-2 floor=-3 trunc=-2 fabs=2.3       isfinite=True  isinf=False  isnan=False\nx=   inf  ceil=NA floor=NA trunc=NA fabs=inf       isfinite=False isinf=True   isnan=False\nx=  -inf  ceil=NA floor=NA trunc=NA fabs=inf       isfinite=False isinf=True   isnan=False\nx=   nan  ceil=NA floor=NA trunc=NA fabs=nan       isfinite=False isinf=False  isnan=True\n要点提示\n\nceil() 与 floor() 分别向上、向下取整，返回值为 int 类型，输入可以是任意浮点；\ntrunc() 直接截断小数部分（对负数向 0 方向截断）；\nfabs() 返回浮点的绝对值；相比内置 abs()，它对整数和浮点都返回浮点；\nisfinite()、isinf()、isnan() 用于对特殊浮点情况进行检测。\n\n\n2. 幂运算与平方根\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.sqrt(x)平方根，返回 √x；x 必须 ≥ 0，否则抛出 ValueError；math.pow(x, y)幂运算，返回 x**y（浮点形式）；推荐使用内置 x**y或 pow(x, y)；x**y/ pow(x, y)Python 内置运算符/函数，支持整型幂运算（返回 int）、浮点幂运算。math.exp(x)指数函数 eˣ；math.expm1(x)返回 eˣ−1，避免 x 很小（如 0.000001）时直接计算 exp(x)-1造成的浮点精度损失；\n示例：\nimport math\n \n# 平方根\nprint(math.sqrt(16))    # 4.0\n# 当 x 为负数时会抛出异常\n# math.sqrt(-1)  # ValueError: math domain error\n \n# 幂运算\nprint(math.pow(2, 10))      # 1024.0\nprint(2**10, pow(2, 10))    # 1024 1024\n \n# 指数函数\nprint(math.exp(1))          # 2.718281828459045 (~e)\nprint(math.exp(3))          # e^3 ≈ 20.085536923187668\n \n# expm1 在 x 很小时更精确\nx_small = 1e-6\nprint(math.exp(x_small) - 1)  # 1.0000005000000417e-06（误差较大）\nprint(math.expm1(x_small))    # 1.0000000000004998e-06（更精确）\n要点提示\n\n对于幂运算，若要精确处理大整数的幂，优先使用 x**y 或内置 pow(x, y)（对整型返回整型）；math.pow() 总是返回浮点，且对于大整数可能会丢失精度。\nexpm1(x) 在 x 接近 0 时更能减少浮点舍入误差；在编写统计学或微分运算时尤其有用。\n\n\n3. 对数函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.log(x[, base])自然对数 ln(x)；若给定 base，则返回以该底的对数：log₍base₎(x)；math.log2(x)以 2 为底的对数 log₂(x)；math.log10(x)以 10 为底的对数 log₁₀(x)；math.log1p(x)返回 ln(1 + x)，当 x 很小时更精确；\n示例：\nimport math\n \n# 自然对数\nprint(math.log(math.e))    # 1.0\nprint(math.log(10))        # ln(10) ≈ 2.302585092994046\n \n# 指定底\nprint(math.log(8, 2))      # 3.0  （log₂(8)）\nprint(math.log(100, 10))   # 2.0\n \n# 专门函数\nprint(math.log2(16))       # 4.0\nprint(math.log10(100))     # 2.0\n \n# log1p 在 x 很小时更精确\nx_small = 1e-8\nprint(math.log(1 + x_small))  # 9.99999993922529e-09（精度有限）\nprint(math.log1p(x_small))    # 9.999999995e-09（更精确）\n要点提示\n\n在要处理概率、累积乘积、数值极小变化等场景时，log1p(x) 更能避免 x 极小时 1 + x 变成 1 导致损失精度。\n如果需要计算对数密度或信息熵相关公式，优先选用 log1p() 或 expm1() 以获取更高精度。\n\n\n4. 三角函数与角度变换\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.sin(x)正弦函数 sin(x)，x 以弧度（radians）为单位；math.cos(x)余弦函数 cos(x)，x 以弧度为单位；math.tan(x)正切函数 tan(x)，x 以弧度为单位；math.asin(x)反正弦 arcsin(x)，返回值在 [−π/2, π/2]；math.acos(x)反余弦 arccos(x)，返回值在 [0, π]；math.atan(x)反正切 arctan(x)，返回值在 [−π/2, π/2]；math.atan2(y, x)二元反正切 atan2(y, x)，返回坐标 (x, y) 对应的角度，值域 (−π, π]；math.degrees(x)将弧度转换为角度：x * (180/π)；math.radians(x)将角度转换为弧度：x * (π/180)；math.hypot(x, y)计算 √(x² + y²)，常用于二维或多维空间距离；\n示例：\nimport math\n \nangle_deg = 45\nangle_rad = math.radians(angle_deg)  # 0.7853981633974483\n \n# 三角函数\nprint(f&quot;sin({angle_deg}°) = {math.sin(angle_rad)}&quot;)  # ≈ 0.7071067811865475\nprint(f&quot;cos({angle_deg}°) = {math.cos(angle_rad)}&quot;)  # ≈ 0.7071067811865476\nprint(f&quot;tan({angle_deg}°) = {math.tan(angle_rad)}&quot;)  # ≈ 0.9999999999999999\n \n# 反三角函数（输入值在 [-1, 1]）\nx = 0.5\nprint(f&quot;arcsin({x}) = {math.degrees(math.asin(x))}°&quot;)  # ≈ 30°\nprint(f&quot;arccos({x}) = {math.degrees(math.acos(x))}°&quot;)  # ≈ 60°\nprint(f&quot;arctan({x}) = {math.degrees(math.atan(x))}°&quot;)  # ≈ 26.565°\n \n# atan2 用于双参数反正切\ny, x = 1, 1\nprint(math.atan2(y, x), math.degrees(math.atan2(y, x)))  # 0.785398..., 45°\n \n# 计算 2D 或 N 维欧几里得距离\nprint(math.hypot(3, 4))      # 5.0\n# Python 3.8+ 支持多维，例如 hypot(x, y, z)\nprint(math.hypot(1, 2, 2))   # √(1² + 2² + 2²) = 3.0\n要点提示\n\n所有三角函数的参数均以“弧度”输入，若使用“角度”可先调用 radians()；或结果需要“角度”时再调用 degrees()；\natan2(y, x) 用于求( x, y )坐标对应的极角，可正确处理象限；\nhypot() 在底层做了防溢出/防下溢处理，比直接写 math.sqrt(x*x + y*y) 更稳健；\n\n\n5. 双曲函数与反双曲函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.sinh(x)双曲正弦 sinh(x) = (eˣ − e⁻ˣ)/2；math.cosh(x)双曲余弦 cosh(x) = (eˣ + e⁻ˣ)/2；math.tanh(x)双曲正切 tanh(x) = sinh(x)/cosh(x)；math.asinh(x)反双曲正弦 arcsinh(x)；math.acosh(x)反双曲余弦 arccosh(x)，x ≥ 1；math.atanh(x)反双曲正切 arctanh(x)，\n示例：\nimport math\n \nx = 1.0\nprint(f&quot;sinh({x}) = {math.sinh(x)}&quot;)   # ≈ 1.1752011936438014\nprint(f&quot;cosh({x}) = {math.cosh(x)}&quot;)   # ≈ 1.5430806348152437\nprint(f&quot;tanh({x}) = {math.tanh(x)}&quot;)   # ≈ 0.7615941559557649\n \n# 反双曲函数\ny = math.sinh(x)\nprint(f&quot;asinh({y}) = {math.asinh(y)}&quot;)  # ≈ 1.0\n \nz = math.cosh(x)\nprint(f&quot;acosh({z}) = {math.acosh(z)}&quot;)  # ≈ 1.0\n \nt = math.tanh(x)\nprint(f&quot;atanh({t}) = {math.atanh(t)}&quot;)  # ≈ 1.0\n要点提示\n\n双曲函数常用于信号处理、统计学中的高斯函数、工程中的链线曲线等场景；\nacosh(x) 要求 x ≥ 1，atanh(x) 要求 |x| &lt; 1，否则抛出 ValueError；\n\n\n6. 特殊函数\n\n伽马函数与贝塔函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.gamma(x)伽马函数 Γ(x)，对 x&gt;0 等价于 (x−1)! ；math.lgamma(x)返回 ln\n示例：\nimport math\n \n# 伽马函数\nprint(math.gamma(5))    # Γ(5) = 4! = 24.0\nprint(math.gamma(0.5))  # Γ(0.5) = √π ≈ 1.7724538509055159\n \n# 伽马函数对数\nprint(math.lgamma(5))   # ln(24) ≈ 3.1780538303479458\nprint(math.lgamma(0.5)) # ln(√π) ≈ 0.5723649429247001\n\n组合数学（阶乘、组合数、排列数）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.factorial(n)阶乘 n!，n 必须是非负整数，否则抛出 ValueError；math.comb(n, k)组合数 C(n, k) = n! / (k!(n−k)!)，Python 3.8+ 引入；math.perm(n, k=None)排列数 P(n, k) = n! / (n−k)!；若 k 省略则返回 n!；\n示例：\nimport math\n \n# 阶乘\nprint(math.factorial(5))   # 120\n# 如果输入为负数或非整数，则抛出 ValueError\n# math.factorial(-1)      # ValueError\n \n# 组合数\nprint(math.comb(10, 3))    # C(10,3) = 120\nprint(math.comb(5, 0))     # 1\nprint(math.comb(5, 5))     # 1\n \n# 排列数\nprint(math.perm(5, 2))     # P(5,2) = 5 * 4 = 20\nprint(math.perm(5))        # 默认 k=None，等于 factorial(5) = 120\n\n最大公约数与最小公倍数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.gcd(a, b[, *args])返回多个整数的最大公约数（Greatest Common Divisor）；math.lcm(a, b[, *args])返回多个整数的最小公倍数（Least Common Multiple），Python 3.9+ 引入；\n示例：\nimport math\n \nprint(math.gcd(12, 18))       # 6\nprint(math.gcd(12, 18, 24))   # 6\n \nprint(math.lcm(4, 6))         # 12\nprint(math.lcm(4, 6, 10))     # 60\n\n浮点数分解与重构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.frexp(x)将浮点数 x 分解为 (m, e)，满足 x = m * 2**e，且 0.5 ≤math.ldexp(m, e)与 frexp()反向，将 m * 2**e 重构为浮点数；math.modf(x)返回 (frac, intpart)，x 的小数部分与整数部分（均为浮点）；\n示例：\nimport math\n \n# frexp 与 ldexp\nx = 20.5\nm, e = math.frexp(x)\nprint(m, e)            # m ≈ 0.640625, e = 5，因为 0.640625 * 2**5 = 20.5\nprint(math.ldexp(m, e))  # 恢复为 20.5\n \n# modf\nfrac, integer = math.modf(3.14159)\nprint(frac, integer)  # 0.14159000000000012  3.0\n\n符号与舍入\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.copysign(x, y)返回带有 y 符号的 x 的绝对值，如 copysign(3, -2)→ -3.0；math.fmod(x, y)浮点数取模，返回 x − n * y，其中 n 是最靠近 x / y 且与 x / y 同号的整数；math.remainder(x, y)IEEE 754 风格的余数，返回最接近 x / y 的整数 n 后余数：x − n * y；Python 3.7+；\n示例：\nimport math\n \nprint(math.copysign(3, -2))  # -3.0\nprint(math.copysign(-3, 2))  # 3.0\n \n# fmod 与 Python 内置 % 可能有所不同\nprint(math.fmod(8.3, 2.1))   # 8.3 - 3*2.1 = 2.0\nprint(8.3 % 2.1)             # 2.0（对于正数，两者相同）\n \n# remainder\nprint(math.remainder(8.3, 2.1))  # 8.3 - 4*2.1 = 0.0\nprint(math.remainder(7.5, 2))    # 7.5 - 4*2 = -0.5，因为 4 是最接近 3.75 的整数\n要点提示\n\nfrexp() / ldexp() 用于底层浮点操作、二进制拆解与精度控制；\nmodf() 便捷地将浮点拆成整数与小数；\ncopysign() 在处理物理量时经常用来保留符号、改变数值；\nfmod() 与 % 表现相似，但对负数符号处理不同；一般建议用 % 做日常取模，若需要 IEEE 754 精确语义可用 remainder()（Python 3.7+）。\n\n\n7. 累积求和与数值精度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明math.fsum(iterable)精确累积求和，避免普通浮点求和的舍入误差。\n示例：\nimport math\n \n# 普通内置 sum 可能累积误差\nvalues = [0.1] * 10  # 理论和为 1.0\nprint(sum(values))   # 0.9999999999999999\n \n# fsum 可以更精确\nprint(math.fsum(values))  # 1.0\n要点提示\n\n对于包含大量浮点相加的场景，使用 fsum() 可显著减小舍入误差；\nfsum() 内部使用“分块求和”算法（类似 Kahan 求和），比简单累加更稳健；\n\n\n四、使用示例集锦\n下面通过整合上述函数，举几个常见应用场景的示例。\n1. 统计学中的正态分布概率密度函数（PDF）\n正态分布 PDF：\nf(x)=1σ2πexp⁡(−(x−μ)22σ2)f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\Bigl(-,\\frac{(x-\\mu)^2}{2\\sigma^2}\\Bigr)f(x)=σ2π1exp(−2σ2(x−μ)2)\nimport math\n \ndef normal_pdf(x, mu=0.0, sigma=1.0):\n    coeff = 1.0 / (sigma * math.sqrt(2 * math.pi))\n    exponent = -((x - mu) ** 2) / (2 * sigma * sigma)\n    return coeff * math.exp(exponent)\n \n# 测试\nfor x in (-2, -1, 0, 1, 2):\n    print(f&quot;x={x}: PDF={normal_pdf(x, mu=0, sigma=1)}&quot;)\n2. 计算多边形顶点坐标中心至各顶点的最远距离\n假设一个多边形由一系列坐标点 (x_i, y_i) 给定，计算其几何中心（centroid）与所有顶点之间的最远欧氏距离。\nimport math\n \npoints = [(0,0), (4,0), (4,3), (0,3)]  # 矩形 4×3\n# 1. 先计算几何中心\ncx = sum(x for x, _ in points) / len(points)\ncy = sum(y for _, y in points) / len(points)\n \n# 2. 用 hypot 计算到各点的距离\ndistances = [math.hypot(x - cx, y - cy) for x, y in points]\nmax_dist = max(distances)\n \nprint(f&quot;Center = ({cx:.2f}, {cy:.2f}), max distance = {max_dist:.2f}&quot;)\n3. 大整数阶乘与组合数计算\nimport math\n \nn = 50\nk = 5\n \n# 50! 相当大，用 factorial\nfact_50 = math.factorial(n)\nprint(f&quot;50! = {fact_50}&quot;)\n \n# 组合数 C(50, 5)\ncomb_50_5 = math.comb(n, k)\nprint(f&quot;C(50, 5) = {comb_50_5}&quot;)\n4. 二进制浮点拆分与重构\nimport math\n \nx = 123.456\nmantissa, exponent = math.frexp(x)\nprint(&quot;frexp:&quot;, mantissa, exponent)\n# 验证使用 ldexp 恢复\nrestored = math.ldexp(mantissa, exponent)\nprint(&quot;restored:&quot;, restored)\n \n# 再演示 modf\nfractional, integer = math.modf(x)\nprint(&quot;modf:&quot;, fractional, integer)\n\n五、注意事项与最佳实践\n\n浮点精度与舍入误差\n\n\n由于 IEEE-754 规范，某些十进制数无法精确表示为二进制浮点。尽量使用 math.fsum() 累加、math.expm1()、math.log1p() 等“误差更小”的函数。\n对于数值比较，避免直接使用 ==，可用 math.isclose(a, b, rel_tol=..., abs_tol=...) 判断近似相等。\n\n\n整数与浮点混用\n\n\nmath.factorial()、math.comb()、math.perm() 等接受并返回整型。其他大多数函数都返回浮点，输入即使是整数也会先转换为浮点再运算。注意可能的类型变化。\n在需要整数精度时，避免用 math.pow()，因为它返回浮点。直接用 ** 或 pow()。\n\n\n输入范围与异常\n\n\n大多数函数如果输入不在定义域，会抛出 ValueError: math domain error。例如 math.sqrt(-1)、math.log(-5)、math.acos(2) 等。处理前要先用 math.isfinite(x)、比较大小等方法进行校验。\n当输入非常大时，某些函数可能会返回 inf 或 OverflowError。例如 math.exp(1000) 会直接返回 inf（并可能伴随警告）。可提前判断输入范围或使用 math.isfinite() 做保护。\n\n\n三角函数精度\n\n\n使用三角函数时先将度数转换为弧度，避免使用近似转换写死系数。\n对于要求高精度循环三角计算，可使用 math.sin(x)、math.cos(x) 的多次叠加会累积误差；在高精度数值方法中可用“差分”或“Cordic 算法”实现。\n\n\n组合数学的大数计算\n\n\nfactorial(n) 对 n 较大时会产生巨大的整数，占用大量内存与时间；可在需要概率密度或对数概率时使用 math.lgamma() 或 math.log()/math.comb() 的组合搭配来避免超大整数。\n例如要计算概率 C(n, k) * p^k * (1−p)^(n−k)，更稳健的写法是用 math.comb() 与浮点指数，而不是先算 factorial()。\n\n\n尽量使用标准库函数\n\n\n遇到累加、对数、指数、阶乘等常见需求时，优先考虑 math 中对应函数，不要手动实现循环或近似算法。这样既能提高可读性，又能利用底层 C 实现获得更高性能与精度。\n\n\n六、总结\n\n**math** 模块 是 Python 中进行数值计算、科学计算时最基础的工具，涵盖了从基础的算术、幂与对数、三角与双曲函数，到组合数学、浮点数拆分与重构、数值精度累加等内容。\n本文系统地梳理了：\n\n\n核心常量：π、e、τ、inf、nan；\n基本算术与数值测试：ceil()、floor()、trunc()、fabs()、isfinite()、isinf()、isnan()；\n幂运算与平方根：sqrt()、exp()、pow()、expm1()；\n对数系列：log()、log2()、log10()、log1p()；\n三角函数与角度转换：sin()、cos()、tan()、asin()、acos()、atan()、atan2()、hypot()、degrees()、radians()；\n双曲与反双曲：sinh()、cosh()、tanh()、asinh()、acosh()、atanh()；\n特殊函数：gamma()、lgamma()、factorial()、comb()、perm()、gcd()、lcm()；\n浮点数分解与重构：frexp()、ldexp()、modf()；\n符号与取模：copysign()、fmod()、remainder()；\n数值累加：fsum()；\n使用示例：概率密度、欧氏距离、多边形几何中心、大整数阶乘与组合、浮点拆分、数值精度演示。\n\n\n最佳实践要点：\n\n\n对于需要高精度浮点累加，使用 fsum()；\n避免直接用浮点做 exp(x) - 1 或 log(1 + x)，使用 expm1() 与 log1p()；\n幂运算优先用 ** 或 pow() 而非 math.pow()；\n组合数学函数适合大整数情形，但要注意避免溢出；可用 lgamma() 计算对数形式。\n三角函数参数一律以“弧度”为单位；如需“角度”，用 radians()/degrees() 辅助转换；\n取模时若需要 IEEE 754 语义，用 remainder()；否则一般用 %。\n"},"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/random":{"slug":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/random","filePath":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/random.md","title":"random","links":[],"tags":[],"content":"一、模块概述\n\n简介\n\n\nrandom 模块基于梅森旋转算法（Mersenne Twister）实现了伪随机数生成器（PRNG），它在多数应用场景下提供速度快且统计学性质良好的伪随机数，适用于模拟、蒙特卡洛方法、游戏、抽样等。\n该模块生成的随机数不是“真随机”，而是通过确定性的算法依据内部状态输出；若需加密安全的随机，请使用 random.SystemRandom 或 secrets 模块。\n\n\n高层 API 与设计目标\n\n\n提供一系列函数，涵盖从生成基本伪随机浮点、整数，到针对各种统计分布（均匀、正态、指数、几何等）生成样本，以及从序列中抽样、打乱顺序、生成随机排列等操作。\n采用“全局访问”模式：random.random()、random.randint() 等直接调用全局的 Random() 实例，方便快捷；也允许创建独立的 Random 对象，以便维护各自的状态与种子。\n\n\n模块导入\n\nimport random\n \n# 或者只取常用函数\nfrom random import random, randrange, shuffle\n\n版本与兼容性\n\n\nPython 自 2.3 以来即内置 random；算法自 Python 3.2 起统一为 C 语言实现，速度显著提升。\n默认 PRNG 为基于 C 的 Mersenne Twister，周期为 2⁻⁶¹⁹⁹³⁷−1，足够应对绝大多数仿真与模拟场景。\n\n\n二、核心伪随机数生成器与状态管理\n1. Random 类与内部状态\n\n**Random** 类\n\n\nrandom 模块中核心类型是 random.Random，其内部包含一个 624 长度的 32 位整数数组、索引指针等，共计 624×32 ≈ 20 kilobits 状态空间。\n默认全局模块函数（如 random.random()）调用的是单例全局 Random() 实例；如果需要并行或隔离的随机流，可显式创建独立实例：\n\nimport random\nr1 = random.Random()      # 全新实例，使用系统时间作为默认种子\nr2 = random.Random(12345) # 指定种子\n\n种子（Seed）与可重复性\n\n\n调用 random.seed(a=None, version=2) 初始化或重置 PRNG 的内部状态；若 a 为 None（默认），则基于系统时间以及操作系统提供的随机源自动生成种子。\n支持种子类型：任何可哈希的对象（如整数、字符串、字节串、bytearray 等）；这些对象先被哈希或转换成整数形式，再用于初始化状态。\n示例：\n\nimport random\n \nrandom.seed(42)      # 使用固定种子，输出可重复\nprint(random.random())  # 例如：0.6394267984578837\nrandom.seed(&quot;hello&quot;)    # 字符串做种子，也可\nprint(random.random())\n\n内部状态导出与恢复\n\n\n方法 getstate() 返回一个可序列化的内部状态对象；可用于在不同程序或运行点间保存与恢复状态，保证接下来的随机序列一致。\n方法 setstate(state) 将先前保存的状态载回，接下来输出的随机数将从该状态继续生成。\n示例：\n\nimport random, pickle\n \nr = random.Random(123)\nseq1 = [r.random() for _ in range(3)]\nstate = r.getstate()\n \n# 生成更多数后，再恢复\nextra = [r.random() for _ in range(2)]\nr.setstate(state)\nseq2 = [r.random() for _ in range(2)]\n# seq2 == extra\n要点提示\n\n种子控制：在科研实验、测试中，可通过固定种子保证随机性可复现；\n独立实例：若在多线程/多任务中需要不同的随机序列，避免使用同一个全局实例，可为每个任务新建独立的 Random()；\n状态保存：getstate()/setstate() 适用于需要在中途暂停、迁移或分布式多节点中保证随机性一致的场景；\n\n\n三、生成随机数与序列操作\n1. 生成基本随机浮点数与整数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数／方法说明random.random()返回 [0.0, 1.0) 区间的均匀分布浮点数。random.uniform(a, b)返回 [a, b] 区间的均匀分布浮点；如果 a &gt; b，则区间实际上为 [b, a]。random.randint(a, b)返回 [a, b] 间的整数（包括 a 和 b）。random.randrange(start, stop[, step])返回在 range(start, stop, step) 中均匀随机选取的整数，stop 不包含在内。random.choice(seq)从非空序列（列表、元组、字符串）中随机选取一个元素；random.choices(population, weights=None, *, cum_weights=None, k=1)有放回重复抽样，从 population中根据权重选出 k 个元素，返回列表；\n示例：\nimport random\n \n# 随机浮点\nprint(random.random())         # 例如 0.719483...\nprint(random.uniform(1.5, 3.5))  # 例如 2.847302...\n \n# 随机整数\nprint(random.randint(1, 10))    # 1 到 10 之间的整数\nprint(random.randrange(0, 10, 2))  # 0,2,4,6,8 中随机选一个\n \n# 从序列中选取\nseq = [&#039;apple&#039;, &#039;banana&#039;, &#039;cherry&#039;]\nprint(random.choice(seq))  # 可能 &#039;banana&#039;\n \n# 带权重的抽样\nitems = [&#039;red&#039;, &#039;green&#039;, &#039;blue&#039;]\nweights = [10, 1, 1]  # 选择 &#039;red&#039; 的概率较大\nprint(random.choices(items, weights=weights, k=5))  # 可能 [&#039;red&#039;,&#039;red&#039;,&#039;blue&#039;,&#039;red&#039;,&#039;green&#039;]\n要点提示\n\n**random()** 的精度约为 53 位二进制有效数字，对下游算法（如接入 normalvariate()）足够；\n**uniform(a, b)** 包含端点；如果需要 [a, b) 或 (a, b) 区间，可自行处理：如 a + (b - a) * random.random()；\n**randint(a, b)** 等价于 randrange(a, b+1)；\n**choices()** 返回列表，可指定 weights 或 cum_weights；如果想要无放回抽样，请使用 random.sample()。\n\n2. 序列打乱与无放回抽样\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数／方法说明random.shuffle(x[, random])就地打乱可变序列 x（列表），返回 None；random.sample(population, k)从总体 population中无放回选取 k 个独立元素，返回列表；\n示例：\nimport random\n \n# 打乱列表\ndata = [1, 2, 3, 4, 5]\nrandom.shuffle(data)\nprint(data)  # 例如 [3,1,5,2,4]\n \n# 无放回抽样\npopulation = list(range(100))\nsampled = random.sample(population, 10)  # 随机挑 10 个\nprint(sampled)  # 列表中无重复元素\n \n# 对字符串打乱：需要先转为列表再 join\ns = &quot;abcdef&quot;\nlst = list(s)\nrandom.shuffle(lst)\nprint(&quot;&quot;.join(lst))  # 例如 &#039;cadfeb&#039;\n要点提示\n\n**shuffle()** 只能作用于可变序列（如列表），并在原列表上修改顺序，返回 None；\n若想生成一个打乱后的新列表，而不影响原序列，可先复制：shuffled = random.sample(original, len(original))；\n**sample()** 支持任何序列或集合，但若 population 是可迭代对象（如生成器），元素会被先转为列表后再抽样，注意内存消耗；\n\n\n四、生成各种概率分布的随机数\n1. 均匀分布与三角分布\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数／方法说明random.random()[0.0, 1.0) 的均匀实数；random.uniform(a, b)[a, b] 的均匀实数；random.triangular(low, high, mode)三角分布实数：以 low、high、mode（峰值）三点定义；\n示例：\nimport random\n \n# 均匀分布\nu = random.uniform(10, 20)\nprint(u)  # 10 到 20 之间均匀随机\n \n# 三角分布\n# 如果 mode 留空，则默认为 (low + high) / 2\nt = random.triangular(0, 10, mode=3)\nprint(t)  # 大概率靠近 3\n2. 正态（高斯）分布\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数／方法说明random.gauss(mu, sigma)正态分布样本，均值 mu，标准差 sigma；random.normalvariate(mu, sigma)同上；random.betavariate(alpha, beta)Beta 分布样本，α、β &gt; 0；random.lognormvariate(mu, sigma)对数正态分布样本，底层先对数再正态；返回实数 &gt; 0；random.vonmisesvariate(mu, kappa)冯·米塞斯分布（环形正态），mu为平均角度，kappa为“集中参数”；\n示例：\nimport random\n \n# 均值 0，标准差 1 的正态分布\nfor _ in range(5):\n    print(random.gauss(0, 1))\n \n# beta 分布\nb = random.betavariate(2, 5)  # α=2, β=5\nprint(b)  # 值在 (0,1) 之间，更多倾向于 0 端\n \n# 对数正态分布\nln = random.lognormvariate(0, 1)  # ln(x) ~ N(0,1)，x&gt;0\nprint(ln)\n \n# 冯·米塞斯分布\nvm = random.vonmisesvariate(0, 1)  # 平均角 0 弧度，集中度 1\nprint(vm)  # 返回弧度值在 (-π, π]\n要点提示\n\ngauss() 与 normalvariate() 在算法实现上等价，可互换；底层使用 Box–Muller 或 Marsaglia 极坐标法；\nlognormvariate(mu, sigma) 中，mu 和 sigma 分别是对数空间中的参数，若要得到期望为 m、方差为 v 的对数正态分布，可先将 m、v 转换为相应的 mu、sigma；\nvonmisesvariate() 用于生成圆形统计（如风向、角度）数据；\n\n3. 离散分布与计数分布\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数／方法说明random.expovariate(lambd)指数分布样本，λ &gt; 0；均值 = 1/λ；random.paretovariate(alpha)帕累托分布样本，α &gt; 0；random.weibullvariate(alpha, beta)威布尔分布样本，参数 α（形状）、β（尺度）；random.gauss()（近似）对于二项分布或泊松分布等大样本，可将正态分布作近似；random.choice()+ 频率可通过加权选择近似任意离散分布；\n示例：\nimport random\n \n# 指数分布（排队论常用）\nfor _ in range(5):\n    print(random.expovariate(0.5))  # λ=0.5 → 平均间隔 2\n \n# 帕累托分布\nfor _ in range(3):\n    print(random.paretovariate(2.5))  # α=2.5\n \n# 威布尔分布\nfor _ in range(3):\n    print(random.weibullvariate(1.5, 2.0))  # α=1.5, β=2.0\n要点提示\n\nexpovariate() 适合模拟 Poisson 过程间隔；\nparetovariate() 生成幂律分布尾，适用于经济学、地震学、人类活动等领域；\nweibullvariate() 广泛用于寿命分析、可靠性工程等；\n若需离散概率分布（如二项、泊松、几何、超几何等），可使用第三方库 numpy.random 或手工实现；\n\n\n五、密码学安全随机数\n1. SystemRandom 类\n\n用途与实现\n\n\nrandom.SystemRandom 是基于操作系统提供的 CSPRNG（如 Linux /dev/urandom、Windows CryptGenRandom）实现，调用系统底层采集的随机熵，适用于密码学场景。\n其方法与 Random 类相同，但底层不使用 Mersenne Twister，而是直接调用 os.urandom()。\n\n\n示例用法\n\nimport random\n \nsysrand = random.SystemRandom()\n \n# 生成 [0.0, 1.0) 的浮点\nprint(sysrand.random())\n \n# 生成安全随机整数\nprint(sysrand.randint(1, 100))\n \n# 从列表中安全随机选一个\nsecrets = [&#039;alpha&#039;, &#039;bravo&#039;, &#039;charlie&#039;]\nprint(sysrand.choice(secrets))\n \n# 打乱列表顺序\ndata = [1, 2, 3, 4, 5]\nsysrand.shuffle(data)\nprint(data)\n\n与 **secrets** 模块的比较\n\n\nPython 3.6+ 引入了 secrets 模块，专门用于生成密码学安全随机数、令牌或密钥。\nsecrets 的接口更简洁：secrets.choice()、secrets.randbelow(n)、secrets.token_bytes(n)、secrets.token_hex(n) 等。\n若只需“密码级别随机”，优先考虑 secrets，如：\n\nimport secrets\n \n# 随机选一个安全密码字符\nalphabet = &#039;abcdefghijklmnopqrstuvwxyz0123456789&#039;\npwd = &#039;&#039;.join(secrets.choice(alphabet) for _ in range(12))\nprint(pwd)\n \n# 随机生成字节令牌\ntoken = secrets.token_bytes(16)  # 16 字节\nprint(token.hex())\n要点提示\n\n不要将默认的 **random.random()** 用于任何安全或加密场景，因为它是可预测的；\n若在密码学场景下需要分布函数（如正态分布）且要求安全随机，可将系统随机生成的位流转换为浮点后再自行实现分布采样，但通常推荐使用 **secrets** 生成密钥/令牌，用 **cryptography** 等库做更高级安全运算；\n\n\n六、可重复实验与种子控制\n1. 固定种子保证可重复\n\n若要在实验、仿真、单元测试等场景中获取可重复的随机序列，应在每次运行时初始阶段调用 random.seed(some_constant)。\n示例：\n\nimport random\n \ndef simulate(n):\n    random.seed(2025)  # 固定种子\n    data = [random.random() for _ in range(n)]\n    return data\n \nprint(simulate(5))  # 每次运行都会输出相同的 5 个浮点数\n2. 独立子实例与并行随机\n\n对于多线程或多进程场景，可为每个线程/进程创建独立的 Random() 实例，并使用不同的种子，确保并行之间无交叉。\n\nimport random, threading\n \ndef worker(seed):\n    r = random.Random(seed)\n    print(f&quot;Thread {seed}: {r.random()}&quot;)\n \nthreads = []\nfor i in range(3):\n    t = threading.Thread(target=worker, args=(i+1,))\n    threads.append(t)\n    t.start()\nfor t in threads:\n    t.join()\n\n在多进程场景下，一般在 fork 后各进程会继承父进程同一状态，需要重新 seed()。推荐在子进程启动后以独立值（如进程 ID、时间戳）为种子。\n\n要点提示\n\n始终在多线程/多进程环境中避免共享同一个 **Random()** 实例以防止竞态；\n对子实例使用与父实例不同的种子或状态，以确保并行之间没有关联；\n若需要更高级的并行随机生成，可使用第三方库 **numpy.random.Generator** 配合 PCG 或 Philox 算法；\n\n\n七、注意事项与最佳实践\n\n避免对伪随机数期待过高\n\n\nMersenne Twister 的周期极长、统计性质良好，但它并非“真随机”。对安全敏感场景不要使用。\n小规模 Monte Carlo 或模拟可放心使用，但若要对抗攻击者或猜测，请使用 SystemRandom 或 secrets。\n\n\n浮点均匀分布精度\n\n\nrandom.random() 生成的浮点在 [0.0, 1.0) 之间，精度约 53 位二进制。对于 [a, b] 区间，uniform(a, b) 内部实现是 a + (b - a) * random.random()，当 b - a 很小时会受浮点精度限制；对于极端场景，需考虑自定义采样方法。\n\n\n组合分布函数谨慎使用\n\n\n用 gauss() 近似二项分布或泊松分布时，当参数较小时效果差异明显；若需要精确模拟，请使用 numpy.random.binomial()、numpy.random.poisson() 等或自行实现离散采样。\n\n\n调用顺序与 thread-safety\n\n\nRandom() 对象的方法本身在单线程中是安全的；但全局模块函数共享同一个实例，若在多线程中并发调用全局函数可能导致数据竞争。最佳做法是每个线程维护独立实例。\n\n\n状态保存与恢复注意序列化格式\n\n\ngetstate() 返回的数据结构包含大整数数组与指针，直接通过 pickle 序列化保存是可行的；但请谨慎保存跨 Python 版本之间的 state，可能因内部实现变化而无法兼容。\n\n\n性能成本\n\n\n对于大量随机数生成任务，random 模块的 Python 层调用略慢于纯 C 实现，如 numpy.random。如果要批量生成百万级随机数，建议使用 numpy。\n小规模（几千、几万）或对第三方库依赖较敏感的场景中，random 性能足够。\n\n\n八、综合示例\n以下示例将演示一个蒙特卡洛积分估计问题，即估计单位圆面积近似值 π。\nimport random\nimport math\n \ndef estimate_pi(num_samples, seed=None):\n    &quot;&quot;&quot;\n    使用蒙特卡洛方法估计圆面积（进而估计 π）。\n    在单位正方形 [0,1]×[0,1] 中随机撒点，统计落在 x^2 + y^2 &lt;= 1 的比例。\n    &quot;&quot;&quot;\n    r = random.Random(seed)  # 如果 seed 提供可重复\n    count_inside = 0\n    for _ in range(num_samples):\n        x = r.random()\n        y = r.random()\n        if x*x + y*y &lt;= 1.0:\n            count_inside += 1\n    # 落在四分之一圆内的概率 ≈ π/4，故 π ≈ 4 * count_inside / num_samples\n    return 4 * count_inside / num_samples\n \n# 测试\nfor n in [1000, 10000, 100000, 1000000]:\n    pi_est = estimate_pi(n, seed=123)\n    print(f&quot;样本数 {n:8d} → π 估计值 = {pi_est:.6f}, 误差 = {abs(pi_est - math.pi):.6f}&quot;)\n输出示例：\n样本数     1000 → π 估计值 = 3.160000, 误差 = 0.018407\n样本数    10000 → π 估计值 = 3.142800, 误差 = 0.000207\n样本数   100000 → π 估计值 = 3.141680, 误差 = 0.000087\n样本数  1000000 → π 估计值 = 3.141460, 误差 = 0.000133\n要点提示\n\n通过指定固定种子，可保证每次运行得到相同的估计值；\n独立使用 **random.Random(seed)** 创建隔离实例，避免与全局随机状态冲突；\n对于蒙特卡洛类算法，采样量越大，估计越接近真实值，但也要留意计算成本；\n\n\n九、总结\n\n**random** 模块 为 Python 提供了基于 Mersenne Twister 的高效伪随机数生成与分布采样，适合模拟、抽样、游戏、统计、测试等场景。\n核心功能：\n\n\n基本伪随机：均匀浮点 random()、整数 randint()、区间取值 randrange()；\n序列操作：choice()、shuffle()、sample() 与多次有放回抽样 choices()；\n各种分布：均匀 uniform()、三角 triangular()、正态 gauss()/normalvariate()、对数正态、Beta、帕累托、指数、威布尔、冯·米塞斯等；\n离散数学：无放回采样 sample()、打乱顺序 shuffle()；\n可重复性：seed()、getstate()、setstate()；\n密码安全：SystemRandom 类与 secrets 模块；\n\n\n最佳实践要点：\n\n\n在可复现实验中固定种子或使用单独 Random() 实例；\n在多线程/多进程环境中避免共享全局实例，或使用独立实例并手动加锁；\n对于安全需求使用 SystemRandom 或 secrets；\n在统计采样中尽可能使用专门的分布函数而非手写近似；\n对于大规模随机数生成任务，考虑使用 numpy.random 以提高性能。\n"},"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/statistics":{"slug":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/statistics","filePath":"python/2.常用库与工具/标准库与内置模块/数学、统计与随机数/statistics.md","title":"statistics","links":[],"tags":[],"content":"1. statistics 模块概述\n\n\nstatistics 模块自 Python 3.4 起成为标准库，用于执行基本的统计学运算。\n\n\n主要针对一维数据样本（sequence 或 iterable），提供“描述性统计”与“部分推断统计”功能，涵盖：\n\n\n各种均值（算术均值、几何均值、调和均值）\n\n\n中位数与众数\n\n\n方差、标准差（包括总体与样本之分）\n\n\n分位数（quantiles）、四分位数（quartiles）\n\n\n协方差与相关系数\n\n\n线性回归估计（linear_regression）\n\n\n基于正态分布的 NormalDist 类\n\n\n几乎所有函数都接受 可迭代对象（iterable）作为输入，也可以直接传入一系列数值参数。\n\n\n若数据不符合预期，或运算失败，会抛出 StatisticsError 异常，需要用 try…except 捕获。\n\n\n\n2. 均值（Mean）相关函数\n2.1 算术均值：mean(data)\nimport statistics\n \ndata = [10, 20, 30, 40]\nprint(statistics.mean(data))  # 输出 25\n\n定义：把所有数值相加后除以样本数量。\n参数：data 可以是任意可迭代的数值序列（列表、元组、生成器等），或直接传入一系列数：\n\nstatistics.mean(1, 2, 3, 4)  # 允许这种写法，结果为 2.5\n\n如果输入为空序列，会抛出 StatisticsError: mean requires at least one data point。\n\n2.2 几何均值：geometric_mean(data)\nimport statistics\n \ndata = [1, 4, 9, 16]\nprint(statistics.geometric_mean(data))  # 输出 4.0（即 (1*4*9*16)**(1/4) ）\n\n定义：将所有数值连乘后开 n 次方（n 为样本数量）。\n用途：常用于增长率、投资收益率等需要使用“乘积”指标的场景。\n如果序列中出现非正数（如 0 或负数），会抛出 StatisticsError。\n\n2.3 调和均值：harmonic_mean(data)\nimport statistics\n \ndata = [2, 4, 4]\nprint(statistics.harmonic_mean(data))  # 输出 3.2（即 3 / (1/2 + 1/4 + 1/4) ）\n\n定义：调和均值 = 样本数 ÷（各数倒数之和）。\n用途：常用于计算速率（如平均速度、单位成本等）。\n如果序列中包含 0 或负值，会抛出 StatisticsError。\n\n\n3. 中位数（Median）与众数（Mode）\n3.1 中位数：median(data)\nimport statistics\n \ndata1 = [1, 3, 5]\ndata2 = [1, 3, 5, 7]\n \nprint(statistics.median(data1))  # 输出 3\nprint(statistics.median(data2))  # 输出 (3 + 5) / 2 = 4.0\n\n定义：将数据从小到大排序后，取中间位置的值；若元素个数为偶数，则取“中间两个数的平均”。\n输入：可迭代对象；可以直接传入数字序列。\n如果输入为空序列，会抛出 StatisticsError: no median for empty data。\n\n3.2 中位数变体：median_low(data) 与 median_high(data)\n\n\n当数据长度为偶数时：\n\n\nmedian_low 返回排序后靠左那个中位数（较小值）。\n\n\nmedian_high 返回排序后靠右那个中位数（较大值）。\n\n\n例如：\n\n\nimport statistics\n \ndata = [1, 3, 5, 7]\nprint(statistics.median_low(data))   # 输出 3\nprint(statistics.median_high(data))  # 输出 5\n3.3 四分位数：median_grouped(data, interval=1)\n\n\n用途：当数据被分组到等长区间（组距）中时，按“插值法”估算中位数。\n\n\n参数：\n\n\ndata：可迭代对象，最小长度应 ≥ 3；\n\n\ninterval：分组宽度（默认为 1）。\n\n\n注意：真实应用中多用于频数分布表，而非直接对原始数据使用。\n\n\n3.4 众数：mode(data)\nimport statistics\n \ndata = [1, 2, 2, 3, 3, 3, 4]\nprint(statistics.mode(data))  # 输出 3，因为 3 出现次数最多\n\n\n定义：返回出现频率最高的那个元素。\n\n\n限制：\n\n\n如果有多个值并列最高，会抛出 StatisticsError: no unique mode; found 2 equally common values。\n\n\n如果序列为空，也会抛出 StatisticsError。\n\n\n如果希望同时获取所有众数，可以使用 multimode(data)，它会返回一个列表，包含所有并列最高频率的元素。例如：\n\n\nimport statistics\n \ndata = [1, 2, 2, 3, 3]\nprint(statistics.multimode(data))  # 输出 [2, 3]\n\n4. 变异性（Variance）与标准差（Standard Deviation）\n注意：statistics 模块区分“总体（population）”与“样本（sample）”的计算公式。总体和样本在分母上有所不同。\n4.1 总体方差与标准差\n\n总体方差（Population Variance）：\n\nstatistics.pvariance(data)\n定义为：\nσ2=1N∑i=1N(xi−μ)2 \\sigma^2 = \\frac{1}{N} \\sum_{i=1}^N (x_i - \\mu)^2σ2=N1i=1∑N(xi−μ)2\n其中 μ=\\mu =μ= 总体均值，NNN 为总体大小（样本个数）。\n\n总体标准差（Population Standard Deviation）：\n\nstatistics.pstdev(data)\n定义为总体方差的平方根：\nσ=σ2 \\sigma = \\sqrt{\\sigma^2}σ=σ2\n\n示例：\n\nimport statistics\n \ndata = [10, 20, 30, 40]\nprint(statistics.pvariance(data))  # 输出 125.0\nprint(statistics.pstdev(data))     # 输出 11.180339887498949\n4.2 样本方差与标准差\n\n样本方差（Sample Variance）：\n\nstatistics.variance(data)\n定义为：\ns2=1n−1∑i=1n(xi−xˉ)2 s^2 = \\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\bar x)^2s2=n−11i=1∑n(xi−xˉ)2\n其中 xˉ\\bar xxˉ 为样本均值，nnn 为样本大小。注意分母是 n−1n-1n−1。\n\n样本标准差（Sample Standard Deviation）：\n\nstatistics.stdev(data)\n定义为样本方差的平方根：\ns=s2 s = \\sqrt{s^2}s=s2\n\n示例：\n\nimport statistics\n \ndata = [10, 20, 30, 40]\nprint(statistics.variance(data))  # 输出 166.66666666666666\nprint(statistics.stdev(data))     # 输出 12.909944487358056\n\n注意：当样本长度 len(data) &lt; 2 时，variance/stdev 会抛出 StatisticsError: variance requires at least two data points。\n\n\n5. 分位数（Quantiles）与四分位数（Quartiles）\n5.1 分位数：quantiles(data, n=4, method=&#039;exclusive&#039;)\n\n\n功能：将数据按照指定分位（n）切分，返回切分点的列表（不包含最小值和最大值）。\n\n\n参数解释：\n\n\ndata：可迭代数值序列。\n\n\nn：将数据分成 n 等份（默认 n=4，即四分位）。\n\n\nmethod：插值方法，可选：\n\n\n&#039;exclusive&#039;（默认）：适用于较大样本，参考统计学上的 PERCENTILE.EXC 方法。\n\n\n&#039;inclusive&#039;：与 PERCENTILE.INC 方法对应。\n\n\n&#039;nearest&#039;、&#039;high&#039;、&#039;low&#039;、&#039;midpoint&#039;：不同插值策略，详见官方文档。\n\n\n返回值：\n\n\n长度为 n-1 的列表，依次是第 1/ n 分位数、第 2/ n 分位数（中位数）、…、第 (n−1)/ n 分位数。\n\n\n示例：计算四分位（n=4）：\n\n\nimport statistics\n \ndata = [1, 2, 3, 4, 5, 6, 7, 8]\nq = statistics.quantiles(data, n=4, method=&#039;inclusive&#039;)\nprint(q)  # 输出 [2.75, 4.5, 6.25]，分别对应第 25%、50%、75% 分位数。\n5.2 特殊函数：quantiles(data, n=4) 等同于计算四分位数；如果只需要某几个分位，可以用 method=&#039;nearest&#039; 再自行索引。\n\n6. 协方差（Covariance）与相关系数（Correlation Coefficient）\n6.1 协方差：covariance(x, y)\nimport statistics\n \nx = [1, 2, 3, 4]\ny = [2, 4, 6, 8]\nprint(statistics.covariance(x, y))  # 输出 1.6666666666666667\n定义：\n对于两个同样长度为 n 的样本集合 {xi}{x_i}{xi} 与 {yi}{y_i}{yi}，\n\n\ncov(x,y)=1n−1∑i=1n(xi−xˉ)(yi−yˉ) \\mathrm{cov}(x, y) = \\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\bar x)(y_i - \\bar y)cov(x,y)=n−11i=1∑n(xi−xˉ)(yi−yˉ)\n\n\n分母使用 n-1，即样本协方差。\n\n\n限制：当 len(x) &lt; 2 或者 len(x) != len(y) 时，会抛出 StatisticsError。\n\n\n6.2 相关系数：correlation(x, y)\nimport statistics\n \nx = [1, 2, 3, 4]\ny = [2, 4, 6, 8]\nprint(statistics.correlation(x, y))  # 输出 1.0（完全正相关）\n定义：\n\nr=cov(x,y)sx⋅sy r = \\frac{\\mathrm{cov}(x,y)}{s_x \\cdot s_y}r=sx⋅sycov(x,y)\n\n其中 sxs_xsx、sys_ysy 分别为样本 x、y 的标准差。\n\n取值范围：−1≤r≤1-1 \\le r \\le 1−1≤r≤1。\n限制：当某个序列的标准差为 0（即所有元素相等）时，会抛出 StatisticsError。\n\n\n7. 其他实用函数\n7.1 线性回归（简单线性拟合）：linear_regression(x, y)\nimport statistics\n \nx = [1, 2, 3, 4]\ny = [2, 3, 5, 7]\nslope, intercept = statistics.linear_regression(x, y)\nprint(slope, intercept)  # 例如会输出 1.7 -1.5，表示 y ≈ 1.7 x - 1.5\n\n功能：对给定的点集 (x_i, y_i) 进行最小二乘法线性拟合，返回 (slope, intercept)。\n\n内部实现：与 covariance、stdev 等配合，计算方式：\n\nslope=∑(xi−xˉ)(yi−yˉ)∑(xi−xˉ)2 \\text{slope} = \\frac{\\sum (x_i - \\bar x)(y_i - \\bar y)}{\\sum (x_i - \\bar x)^2}slope=∑(xi−xˉ)2∑(xi−xˉ)(yi−yˉ)intercept=yˉ−slope×xˉ \\text{intercept} = \\bar y - \\text{slope} \\times \\bar xintercept=yˉ−slope×xˉ\n限制：x、y 长度需相同且 ≥ 2，否则抛出 StatisticsError 或 ValueError。\n\n7.2 正态分布工具：NormalDist\nfrom statistics import NormalDist\n \n# 构造一个标准正态分布\nnd = NormalDist(mu=0, sigma=1)\n \n# 计算在 x=1.96 时的累积分布函数值（约 0.975）\nprint(nd.cdf(1.96))  \n \n# 计算概率密度函数值\nprint(nd.pdf(0))    # 在 x=0 处为 ~0.3989\n \n# 两个正态分布的距离（Wasserstein 距离）\nnd2 = NormalDist(mu=1, sigma=2)\nprint(nd.dist(normdist2))\n\n\nNormalDist(mu, sigma) 创建一个正态分布实例。\n\n\n常用方法：\n\n\ncdf(x)：计算累积分布函数 P(X≤x)P(X \\le x)P(X≤x)。\n\n\npdf(x)：概率密度函数值。\n\n\ninv_cdf(p)：给定概率 ppp，返回对应的分位点 xxx。\n\n\ndist(other)：与另一个 NormalDist 实例计算 Wasserstein 距离（或 2-范数距离）。\n\n\n如果 sigma &lt;= 0，会抛出 StatisticsError。\n\n\n7.3 对样本集中最大/最小值位置做插值：mode() 已在第 3 节介绍，multimode() 同样已说明。\n\n8. 异常类型与注意事项\n8.1 StatisticsError\n\n\nstatistics 模块中，所有输入不符合要求时都会抛出 statistics.StatisticsError。\n\n\n常见触发场景：\n\n\n计算均值时传入空序列。\n\n\n计算 variance 或 stdev 时样本数量 &lt; 2。\n\n\n计算 mode 时没有唯一众数。\n\n\n输入中存在无法转换为数字的元素（如传入字符串）。\n\n\ngeometric_mean / harmonic_mean 中含非正数。\n\n\ncovariance / correlation 时两组数据长度不同或长度 &lt; 2。\n\n\nlinear_regression 时两组数据长度不同或长度 &lt; 2。\n\n\nNormalDist 构造时 sigma &lt;= 0。\n\n\n8.2 总体 vs 样本\n\n总体（Population）：当你认为手头的整个数据集就是整体时，使用 pvariance、pstdev。\n样本（Sample）：当你认为手头的数据是从更大总体中抽样得到时，使用 variance、stdev。\n公式上的区别在于分母：总体使用 NNN，样本使用 n−1n-1n−1。\n\n8.3 数据类型与精度\n\n如果输入序列中包含整数和浮点数，输出结果类型通常为浮点数。\n当数值非常大或方差计算时，可能出现浮点舍入误差，需要酌情使用高精度算术库或先做中心化（xi - mean）。\n\n\n9. 综合示例\n下面给出一个包含多种 statistics 功能的综合示例，演示从数据生成、描述性统计到基本推断统计的完整流程。\nimport statistics\nfrom statistics import NormalDist\n \n# 假设有一组学生考试成绩\nscores = [88, 92, 79, 93, 85, 90, 78, 94, 88, 91]\n \n# 1. 描述性统计：均值、中位数、众数\nmean_score = statistics.mean(scores)\nmedian_score = statistics.median(scores)\ntry:\n    mode_score = statistics.mode(scores)\nexcept statistics.StatisticsError:\n    mode_score = statistics.multimode(scores)  # 多众数情形\n \nprint(&quot;均值（Mean）：&quot;, mean_score)\nprint(&quot;中位数（Median）：&quot;, median_score)\nprint(&quot;众数（Mode）：&quot;, mode_score)\n \n# 2. 变异性测量：总体与样本方差、标准差\npop_var = statistics.pvariance(scores)\npop_std = statistics.pstdev(scores)\nsamp_var = statistics.variance(scores)\nsamp_std = statistics.stdev(scores)\n \nprint(f&quot;总体方差（pvariance）：{pop_var:.2f}&quot;)\nprint(f&quot;总体标准差（pstdev）：{pop_std:.2f}&quot;)\nprint(f&quot;样本方差（variance）：{samp_var:.2f}&quot;)\nprint(f&quot;样本标准差（stdev）：{samp_std:.2f}&quot;)\n \n# 3. 分位数计算：四分位数\nq1, q2, q3 = statistics.quantiles(scores, n=4, method=&#039;inclusive&#039;)\nprint(&quot;25% 分位数：&quot;, q1)\nprint(&quot;50% 分位数（中位数）：&quot;, q2)\nprint(&quot;75% 分位数：&quot;, q3)\n \n# 4. 协方差与相关系数\n# 假设有另一组自习时长（小时）数据，与成绩作相关性分析\nhours = [2, 3, 1.5, 3.5, 2.5, 3, 1, 4, 2.5, 3]\n \ncov = statistics.covariance(scores, hours)\ncorr = statistics.correlation(scores, hours)\nprint(f&quot;成绩与自习时长的协方差：{cov:.2f}&quot;)\nprint(f&quot;成绩与自习时长的相关系数：{corr:.2f}&quot;)\n \n# 5. 线性回归：拟合成绩与自习时长的关系\nslope, intercept = statistics.linear_regression(hours, scores)\nprint(f&quot;拟合直线：score = {slope:.2f} * hours + {intercept:.2f}&quot;)\n \n# 6. 假设成绩近似正态分布，用 NormalDist 估算概率\n# 以样本均值和样本标准差近似总体分布\nnd = NormalDist(mu=mean_score, sigma=samp_std)\n# 估算某位学生得分 ≥ 95 的概率\np_above_95 = 1 - nd.cdf(95)\nprint(f&quot;得分 ≥ 95 的近似概率：{p_above_95:.4f}&quot;)\n \n# 7. 几何与调和均值示例\nrates = [1.05, 1.02, 1.03, 1.07]  # 假设 4 年的复合增长率\nprint(&quot;几何均值（年度复合增长率平均）：&quot;,\n      statistics.geometric_mean(rates))\n \nspeeds = [60, 80, 100]  # 3 段旅程速度\nprint(&quot;调和均值（总平均速度）：&quot;,\n      statistics.harmonic_mean(speeds))\n解释：\n\n均值/中位数/众数：快速了解成绩分布的中心趋势。\n总体 vs 样本 方差/标准差：如果认为这 10 个数据就是全体学生成绩，就用总体；若认为这是大群体的样本，就用样本。\n分位数：四分位数可以看出成绩的分布情况（下四分位、中位、上四分位）。\n协方差 &amp; 相关系数：分析成绩与自习时长之间是否存在线性关系。\n线性回归：进一步得到“每增加 1 小时自习，成绩大致上升多少点”。\nNormalDist：假设成绩近似正态分布，可估算极端值出现的概率。\n几何 &amp; 调和均值：分别用于计算复合增长率和平均速度。\n"},"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/bz2":{"slug":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/bz2","filePath":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/bz2.md","title":"bz2","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/gzip":{"slug":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/gzip","filePath":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/gzip.md","title":"gzip","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/lzma":{"slug":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/lzma","filePath":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/lzma.md","title":"lzma","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/tarfile":{"slug":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/tarfile","filePath":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/tarfile.md","title":"tarfile","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/zipfile":{"slug":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/zipfile","filePath":"python/2.常用库与工具/标准库与内置模块/数据压缩与归档/zipfile.md","title":"zipfile","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据处理/csv":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/csv","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/csv.md","title":"csv","links":[],"tags":[],"content":"1. csv 模块概述\n\n\ncsv 模块是 Python 标准库之一，用于读取和写入以逗号或其他分隔符分隔的文本文件。\n\n\n本质上，它并不是简单地按逗号拆分字符串，而是提供了“方言（dialect）”机制，根据不同格式规范（如 Excel CSV、Unix CSV 等）灵活处理分隔符、引用符、转义字符等细节。\n\n\n主要接口：\n\n\ncsv.reader：创建一个迭代器，每次返回一行分割后的列表（list of strings）。\n\n\ncsv.writer：返回一个写入器，通过 writer.writerow() 或 writer.writerows() 写入条目。\n\n\ncsv.DictReader：将每行转换为字典，键由文件头（header）决定。\n\n\ncsv.DictWriter：以字典形式写入，每个字段对应一个键。\n\n\ncsv.register_dialect / csv.get_dialect / csv.unregister_dialect：用于自定义方言。\n\n\n\n2. 如何读取（Reader）CSV 文件\n2.1 最简单的读取示例\nimport csv\n \nwith open(&#039;data.csv&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.reader(f)     # 默认方言为 &#039;excel&#039;\n    for row in reader:\n        # row 是一个列表，比如 [&#039;Alice&#039;, &#039;30&#039;, &#039;Beijing&#039;]\n        print(row)\n\nmode=&#039;r&#039;：以只读模式打开文件。\nencoding=&#039;utf-8&#039;：指定编码，避免中文乱码。\nnewline=&#039;&#039;：推荐在 Python 3 中写法，避免在 Windows 平台出现多余换行。\ncsv.reader(f)：返回一个 reader 对象，逐行读取并根据逗号分隔。\n\n2.2 自定义分隔符和引用字符\n假设文件使用制表符（\\t）作为分隔符，且用单引号（&#039;）作为引用（quoted）字符：\nimport csv\n \nwith open(&#039;data_tab.csv&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.reader(f, delimiter=&#039;\\t&#039;, quotechar=&quot;&#039;&quot;)\n    for row in reader:\n        print(row)\n\ndelimiter=&#039;\\t&#039;：指定制表符为字段分隔符。\nquotechar=&quot;&#039;&quot;：指定单引号为引用符，用于包含带有分隔符的字段。\n\n2.3 跳过文件头（Header）\n如果 CSV 文件第一行是表头（列名），我们想跳过它，可以先读一行：\nimport csv\n \nwith open(&#039;data.csv&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.reader(f)\n    header = next(reader)     # 读走表头行\n    print(&quot;Headers:&quot;, header)\n    for row in reader:\n        print(row)\n\n3. 如何写入（Writer）CSV 文件\n3.1 最简单的写入示例\nimport csv\n \nrows = [\n    [&#039;姓名&#039;, &#039;年龄&#039;, &#039;城市&#039;],\n    [&#039;Alice&#039;, 30, &#039;Beijing&#039;],\n    [&#039;Bob&#039;, 25, &#039;Shanghai&#039;],\n    [&#039;Charlie&#039;, 22, &#039;Guangzhou&#039;],\n]\n \nwith open(&#039;out.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.writer(f)   # 默认方言 &#039;excel&#039;\n    for row in rows:\n        writer.writerow(row)\n\nmode=&#039;w&#039;：写模式，会覆盖已存在文件。\nnewline=&#039;&#039;：避免每行之间出现空行。\nwriter.writerow(row)：传入一个列表，写入一行。\n\n3.2 一次写入多行\nwith open(&#039;out2.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.writer(f)\n    writer.writerows(rows)   # 传入列表的列表，一次写入多行\n3.3 自定义分隔符、引用符、转义符\nimport csv\n \nrows = [\n    [&#039;Name&#039;, &#039;Comment&#039;],\n    [&#039;Alice&#039;, &#039;Hello, world!&#039;],\n    [&#039;Bob&#039;, &#039;He said &quot;Hi&quot;.&#039;],\n]\n \nwith open(&#039;out_custom.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.writer(\n        f,\n        delimiter=&#039;;&#039;,          # 分号分隔字段\n        quotechar=&quot;&#039;&quot;,          # 单引号作为引用符\n        quoting=csv.QUOTE_MINIMAL,  # 只在必要时引用\n        escapechar=&#039;\\\\&#039;         # 转义字符\n    )\n    writer.writerows(rows)\n\ndelimiter=&#039;;&#039;：将分隔符设为分号。\nquotechar=&quot;&#039;&quot;：将引用符设为单引号。\nquoting=csv.QUOTE_MINIMAL（默认值）：如果字段中包含分隔符、引号或换行符，才添加引用符。\nescapechar=&#039;\\\\&#039;：用于转义 quotechar 或者 delimiter 本身。\n\n常见的 quoting 参数值：\n\ncsv.QUOTE_MINIMAL：只有在必要时（如字段含有分隔符、换行符或 quotechar）才加引号。\ncsv.QUOTE_ALL：所有字段都加引号。\ncsv.QUOTE_NONNUMERIC：数字字段不加引号，其他字段加引号；读取时会把没有引用符的字段当作浮点数。\ncsv.QUOTE_NONE：不加引用符，此时必须提供 escapechar 来转义字段中的分隔符。\n\n\n4. Dialect 与方言定制\n4.1 什么是 Dialect\nDialect（方言）用于集中定义一系列参数（如 delimiter、quotechar、quoting、skipinitialspace、lineterminator 等）。有助于在多个地方复用同一组格式配置。标准库自带几种方言：\n\n&#039;excel&#039;（默认）：以逗号分隔，双引号引用，lineterminator=&#039;\\r\\n&#039;（Windows 风格）。\n&#039;excel-tab&#039;：以制表符 \\t 分隔，其他同 &#039;excel&#039;。\n\n4.2 自定义方言\nimport csv\n \n# 定义一个新方言\ncsv.register_dialect(\n    &#039;mydialect&#039;,\n    delimiter=&#039;|&#039;,\n    quotechar=&#039;&quot;&#039;,\n    quoting=csv.QUOTE_MINIMAL,\n    skipinitialspace=True,\n    lineterminator=&#039;\\n&#039;\n)\n \n# 使用自定义方言读取\nwith open(&#039;pipe_delimited.csv&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.reader(f, dialect=&#039;mydialect&#039;)\n    for row in reader:\n        print(row)\n \n# 使用自定义方言写入\nwith open(&#039;out_pipe.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.writer(f, dialect=&#039;mydialect&#039;)\n    writer.writerow([&#039;field1&#039;, &#039;field2&#039;, &#039;field3&#039;])\n\n\ncsv.register_dialect(name, **kwargs)：注册新方言，name 为标识符。\n\n\n常用参数：\n\n\ndelimiter：字段分隔符。\n\n\nquotechar：字段引用符。\n\n\nquoting：引用策略（见前文）。\n\n\nskipinitialspace（布尔）：是否跳过字段分隔符后首个空格。\n\n\nlineterminator：行结束符（如 &#039;\\n&#039;、&#039;\\r\\n&#039; 等）。\n\n\ndoublequote（布尔）：当字段中出现 quotechar 时是否重复 quotechar 以表示转义（Excel 默认行为）。\n\n\nescapechar：用于当 doublequote=False 时，转义 quotechar。\n\n\n4.3 查询与注销方言\nimport csv\n \n# 查询某个方言的配置信息\ndialect = csv.get_dialect(&#039;excel&#039;)\nprint(&quot;Excel 方言的分隔符：&quot;, dialect.delimiter)\n \n# 注销自定义方言\ncsv.unregister_dialect(&#039;mydialect&#039;)\n\n5. DictReader 与 DictWriter 的应用\n当 CSV 有表头字段时，通常更方便使用字典（dict）方式读取和写入。\n5.1 使用 DictReader 读取为字典\nimport csv\n \nwith open(&#039;data_with_header.csv&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.DictReader(f)  # 自动把第一行当作字段名\n    for row in reader:\n        # row 是一个字典，例如 {&#039;Name&#039;: &#039;Alice&#039;, &#039;Age&#039;: &#039;30&#039;, &#039;City&#039;: &#039;Beijing&#039;}\n        print(row[&#039;Name&#039;], row[&#039;Age&#039;], row[&#039;City&#039;])\n\n\ncsv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect=&#039;excel&#039;, *args, **kwargs)：\n\n\n如果不指定 fieldnames，则默认使用文件的第一行作为字段名。\n\n\nrestkey：当某一行字段数多于 fieldnames，多余的部分会放在同名列表下，键为 restkey 对应的字符串。\n\n\nrestval：当某一行字段数少于 fieldnames，缺失字段会填充为 restval。\n\n\n其他参数如同 reader，可通过 delimiter、quotechar 等定制。\n\n\n5.2 使用 DictWriter 以字典方式写入\nimport csv\n \nfieldnames = [&#039;Name&#039;, &#039;Age&#039;, &#039;City&#039;]\nrows = [\n    {&#039;Name&#039;: &#039;Alice&#039;, &#039;Age&#039;: 30, &#039;City&#039;: &#039;Beijing&#039;},\n    {&#039;Name&#039;: &#039;Bob&#039;, &#039;Age&#039;: 25, &#039;City&#039;: &#039;Shanghai&#039;},\n    {&#039;Name&#039;: &#039;Charlie&#039;, &#039;Age&#039;: 22, &#039;City&#039;: &#039;Guangzhou&#039;},\n]\n \nwith open(&#039;out_dict.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    writer.writeheader()           # 写入表头\n    for data in rows:\n        writer.writerow(data)\n\n\ncsv.DictWriter(f, fieldnames, restval=&#039;&#039;, extrasaction=&#039;raise&#039;, dialect=&#039;excel&#039;, *args, **kwargs)：\n\n\nfieldnames：必须提供写入时的字段名列表，决定字典中哪些键会写入。\n\n\nwriteheader()：自动写入字段名作为第一行。\n\n\nextrasaction：对于字典中出现但 fieldnames 中不存在的键，可选择 &#039;raise&#039;（抛错）或 &#039;ignore&#039;（忽略）。\n\n\nrestval：当字典缺少某些字段时，用此值填充。\n\n\n\n6. 常见参数说明\n下表汇总了 csv.reader/csv.writer/DictReader/DictWriter 中常用参数及其含义：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n参数名作用适用场景delimiter指定字段分隔符，默认为逗号 &#039;,&#039;使用非逗号分隔时需要指定quotechar指定引用符，默认为双引号 &#039;&quot;&#039;需要处理包含分隔符的字段quoting引用策略，共有 4 个取值：  csv.QUOTE_MINIMAL（默认）  csv.QUOTE_ALL  csv.QUOTE_NONNUMERIC  csv.QUOTE_NONE控制何时添加/识别引号escapechar指定转义符，仅在 quoting=csv.QUOTE_NONE或 doublequote=False时有效字段内出现分隔符或引用符需转义时doublequote布尔值，表示当字段中出现 quotechar时，是否通过重复 quotechar进行转义（True）还是使用 escapechar（需先设定）控制引号转义方式skipinitialspace布尔值，表示在遇到分隔符后，是否跳过紧跟的空格，默认为 False字段分隔符后出现多余空格时lineterminator写入文件时使用的行终止符，默认为 OS 相关（Windows 下为 &#039;\\r\\n&#039;，Linux 下为 &#039;\\n&#039;）控制输出文件的换行格式fieldnames（仅 Dict）字段名列表，用于 DictReader或 DictWriter的初始化以字典方式读写时必须指定restkey（仅 Dict）当某行字段数多于 fieldnames时，多余字段存放到 row[restkey]的列表中处理不规整、列数不一致的文件restval（仅 Dict）当某行字段数少于 fieldnames时，缺失字段使用此值填充同上extrasaction（仅 Dict）当字典中出现不在 fieldnames中的键时，选择 &#039;raise&#039;（报错）或 &#039;ignore&#039;（忽略）写入时字典与字段名不一致时\n\n7. Python 3 下的字符编码与换行注意事项\n\n打开文件时指定 **newline=&#039;&#039;**\n\n\nPython 3 官方文档建议读取或写入 CSV 文件时，一定要用 open(..., newline=&#039;&#039;)，否则在 Windows 平台会出现读到空行或写入文件每行后多出空行的问题。\n原因：csv 模块自己处理了换行符，如果让 Python 再做一次换行转换，容易出现混乱。\n\n\n字符编码（encoding）\n\n\n默认情况下，Python 会以系统默认编码打开文件（Windows 通常是 cp936，Linux 通常是 UTF-8）。\n为保证跨平台、跨编辑环境的一致性，建议显式指定 encoding=&#039;utf-8&#039;（如果文件是 UTF-8 编码）。\n如果文件含有 BOM（Byte Order Mark），可使用 encoding=&#039;utf-8-sig&#039; 来自动去除 BOM。\n\n\n二进制模式 vs 文本模式\n\n\n在 Python 2 中，推荐使用二进制模式 mode=&#039;rb&#039; / mode=&#039;wb&#039;；但在 Python 3 中，只需使用文本模式并加 newline=&#039;&#039;。\n\n\n8. 示例汇总与实战场景\n8.1 将 CSV 转换为 JSON\n很多场景需要把 CSV 转为 JSON。可以结合 DictReader 和 json 模块：\nimport csv\nimport json\n \ncsv_file = &#039;employees.csv&#039;\njson_file = &#039;employees.json&#039;\n \nwith open(csv_file, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f_csv, \\\n     open(json_file, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;) as f_json:\n \n    reader = csv.DictReader(f_csv)\n    data_list = [row for row in reader]  # 每行是字典\n    json.dump(data_list, f_json, ensure_ascii=False, indent=4)\n \nprint(f&quot;已将 {csv_file} 转换为 {json_file}&quot;)\n8.2 从列表写入包含嵌入逗号的字段\n当字段本身包含逗号时，csv 模块会自动为该字段加上引号。例如：\nimport csv\n \nrows = [\n    [&#039;Name&#039;, &#039;Address&#039;],\n    [&#039;Alice&#039;, &#039;123 Main St, Apt 4&#039;],\n    [&#039;Bob&#039;, &#039;456 Oak St&#039;],\n]\n \nwith open(&#039;address.csv&#039;, mode=&#039;w&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    writer = csv.writer(f)\n    writer.writerows(rows)\n生成的 address.csv 内容会像：\nName,Address\nAlice,&quot;123 Main St, Apt 4&quot;\nBob,456 Oak St\n这样确保下次读取时，&quot;123 Main St, Apt 4&quot; 会被识别为一个字段。\n8.3 处理不同分隔符、多余空格、缺失字段\n假设一行中字段数不一致，且有多余空格，我们可以结合 skipinitialspace、restval、restkey 等参数：\nimport csv\n \n# 示例文件 lines.txt 内容：\n# Name | Age | City\n# Alice | 30  | Beijing\n# Bob |  | Shanghai\n# Charlie | 22 | Guangzhou | ExtraField1 | ExtraField2\n \nwith open(&#039;lines.txt&#039;, mode=&#039;r&#039;, encoding=&#039;utf-8&#039;, newline=&#039;&#039;) as f:\n    reader = csv.DictReader(\n        f,\n        fieldnames=[&#039;Name&#039;, &#039;Age&#039;, &#039;City&#039;],\n        delimiter=&#039;|&#039;,\n        skipinitialspace=True,     # 跳过分隔符后面的空格\n        restkey=&#039;Others&#039;,          # 多余字段放到 row[&#039;Others&#039;]\n        restval=&#039;N/A&#039;              # 缺失字段填充 &#039;N/A&#039;\n    )\n    for row in reader:\n        print(row)\n输出示例：\n{&#039;Name&#039;: &#039;Name&#039;, &#039;Age&#039;: &#039;Age&#039;, &#039;City&#039;: &#039;City&#039;}  \n{&#039;Name&#039;: &#039;Alice&#039;, &#039;Age&#039;: &#039;30&#039;, &#039;City&#039;: &#039;Beijing&#039;}  \n{&#039;Name&#039;: &#039;Bob&#039;, &#039;Age&#039;: &#039;&#039;, &#039;City&#039;: &#039;Shanghai&#039;}  \n{&#039;Name&#039;: &#039;Charlie&#039;, &#039;Age&#039;: &#039;22&#039;, &#039;City&#039;: &#039;Guangzhou&#039;, &#039;Others&#039;: [&#039;ExtraField1&#039;, &#039;ExtraField2&#039;]}\n\n第一行是标题行，因为我们显式指定了 fieldnames，不过它也被当作数据行一起读入。\n第二行的 Age 字段有值，正常读取。\n第三行的 Age 缺失，被设为 &#039;&#039;（空字符串）；如果想让其显示为 &#039;N/A&#039;，可在写入时再进行检查或直接在这里对其进行填充。\n第四行多出两个字段，通过 restkey=&#039;Others&#039; 收集，它们会形成一个列表。\n\n8.4 在 Pandas 与 csv 互转时的注意\n虽然 Pandas read_csv / to_csv 更强大，但在某些轻量场景下，只需用内置的 csv 模块即可。例如，我们要处理大文件，一边读取一边处理，就可用 csv.reader 节省内存；而不是一次性把整个文件加载到 DataFrame 中。\n\n9. 总结\n\n**csv.reader** 与 **csv.writer**：最常用。逐行读取/写入列表形式。\n**csv.DictReader** 与 **csv.DictWriter**：当 CSV 有表头且希望以「列名→值」方式操作时更简洁。\n方言（Dialect）：通过 register_dialect、get_dialect、unregister_dialect 定制并复用一组参数。\n常见参数：\n\n\ndelimiter：自定义分隔符（如 &#039;,&#039;、\\t、&#039;|&#039; 等）。\nquotechar、quoting、escapechar：处理字段中包含分隔符或引号时的转义和引用策略。\nskipinitialspace：跳过分隔符后可能出现的空格。\nlineterminator：写文件时行结束符。\nrestkey / restval / extrasaction：用于不规整 CSV（列数不一致、字典写入时多余或缺失字段）。\n\n\n编码与换行：\n\n\nPython 3 中，打开文件时统一使用 encoding=&#039;utf-8&#039;（或根据实际编码），并确保加上 newline=&#039;&#039;。\n如果遇到带 BOM 的文件，请用 encoding=&#039;utf-8-sig&#039; 自动去除 BOM。\n\n\n实战技巧：\n\n\n如果文件很大，不要一次性 readlines()，而用 for row in reader: 按行处理。\n若需要把 CSV 转为 JSON，可先用 DictReader 读入列表，再用 json.dump 输出。\n当字段中会包含分隔符或换行符时，务必保证设置正确的 quotechar / quoting。\n"},"python/2.常用库与工具/标准库与内置模块/数据处理/heapq":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/heapq","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/heapq.md","title":"heapq","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据处理/html":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/html","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/html.md","title":"html","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据处理/json":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/json","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/json.md","title":"json","links":[],"tags":[],"content":"一、基本概念与用途\n\nJSON 格式概述\n\n\nJSON 本质上是一种文本格式，表示对象（dictionary）和数组（list）等数据结构。\n在 JSON 中，数据结构映射如下：\n\nJSON 值          ↔︎   Python 对象\n---------------------------------\nobject            ↔   dict\narray             ↔   list\nstring            ↔   str\nnumber(int/float) ↔   int 或 float\ntrue              ↔   True\nfalse             ↔   False\nnull              ↔   None\n\n典型的 JSON 示例：\n\n{\n  &quot;name&quot;: &quot;Alice&quot;,\n  &quot;age&quot;: 30,\n  &quot;is_student&quot;: false,\n  &quot;scores&quot;: [85, 92, 78],\n  &quot;address&quot;: {\n    &quot;city&quot;: &quot;Beijing&quot;,\n    &quot;zip&quot;: &quot;100000&quot;\n  }\n}\n\n模块用途\n\n\n序列化（Python → JSON）：将 Python 对象转换为 JSON 格式的字符串或写入文件。\n反序列化（JSON → Python）：将 JSON 格式的字符串或文件内容转换回对应的 Python 对象。\n\n具体使用场景包括但不限于：\n\n将 Python 中的数据结构发送给前端（AJAX 请求、HTTP API）。\n从外部读取 JSON 配置文件，将其解析成字典/列表供程序使用。\n将计算结果保存为 JSON 格式供其他语言或系统读取。\n\n\n二、主要函数和参数\n1. json.loads() / json.dumps()\n\n\n**json.loads(s: str, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None) -&gt; object**\n\n\n将 JSON 格式的字符串 s 反序列化为 Python 对象。\n\n\n常用参数：\n\n\nobject_hook: 如果传入函数，则在解码完成后，会将解析出的 dict 交给该函数进行进一步处理（用于自定义转换）。\n\n\nparse_float、parse_int：可指定在解析数字时使用的自定义函数，例如将数字解析为 Decimal 类型而非浮点。\n\n\nobject_pairs_hook: 类似于 object_hook，但接收 (key, value) 列表，返回一个自定义的映射类型（如 OrderedDict）。\n\n\nimport json\n \njson_str = &#039;{&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 25, &quot;scores&quot;: [90, 88, 76]}&#039;\ndata = json.loads(json_str)\n# data -&gt; {&#039;name&#039;: &#039;Bob&#039;, &#039;age&#039;: 25, &#039;scores&#039;: [90, 88, 76]}\n\n\n**json.dumps(obj: object, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False) -&gt; str**\n\n\n将 Python 对象 obj 序列化为 JSON 格式的字符串。\n\n\n常用参数：\n\n\nensure_ascii（默认 True）：是否只输出 ASCII 字符，如果为 True，则所有非 ASCII 字符会被转义为 \\uXXXX。设置为 False 可以直接输出中文字符。\n\n\nindent：如果给定整数 n，则对输出进行缩进，每个层级缩进 n 个空格；如果 None，则输出结果为一行，不做格式化。\n\n\nseparators：用于定制分隔符，默认 (&#039;,&#039;, &#039;: &#039;)；常见用法是 (&#039;,&#039;, &#039;:&#039;)，去掉冒号后面的空格以减少文件大小。\n\n\ndefault：如果遇到无法序列化的对象（如自定义类实例），会调用该函数以返回可序列化的类型（通常是一个可 JSON 化的类型，比如 dict 或 str）。\n\n\nsort_keys：如果为 True，则按键名对字典进行排序，有利于日志或文件比较时保持一致性。\n\n\nimport json\n \ndata = {\n    &quot;name&quot;: &quot;张三&quot;,\n    &quot;age&quot;: 28,\n    &quot;languages&quot;: [&quot;Python&quot;, &quot;JavaScript&quot;]\n}\njson_str = json.dumps(data, ensure_ascii=False, indent=2)\n# 输出（含中文，无转义）：\n# {\n#   &quot;name&quot;: &quot;张三&quot;,\n#   &quot;age&quot;: 28,\n#   &quot;languages&quot;: [\n#     &quot;Python&quot;,\n#     &quot;JavaScript&quot;\n#   ]\n# }\n2. json.load() / json.dump()\n\n\n**json.load(fp: TextIOBase, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None) -&gt; object**\n\n\n从文件对象 fp 中读取 JSON 文本，并直接返回对应的 Python 对象。\n\n\n与 loads() 对应，区别在于前者直接读取并解析文件。\n\n\nimport json\n \nwith open(&#039;data.json&#039;, &#039;r&#039;, encoding=&#039;utf-8&#039;) as f:\n    data = json.load(f)\n# data 即为解析结果，通常为 dict 或 list\n\n\n**json.dump(obj: object, fp: TextIOBase, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False)**\n\n\n将 Python 对象 obj 序列化为 JSON 文本，并写入到文件对象 fp 中。\n\n\n与 dumps() 对应，区别在于前者将结果直接写入文件。\n\n\nimport json\n \ndata = {&quot;city&quot;: &quot;上海&quot;, &quot;temp&quot;: 22.5}\nwith open(&#039;output.json&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    json.dump(data, f, ensure_ascii=False, indent=4)\n# 这样就会在 output.json 中写入可读性较高的 JSON 文本\n\n三、常见使用示例\n1. 将 JSON 文件读取到 Python\n假设文件 config.json 内容如下：\n{\n  &quot;host&quot;: &quot;localhost&quot;,\n  &quot;port&quot;: 8080,\n  &quot;use_ssl&quot;: true,\n  &quot;paths&quot;: [&quot;/api/v1/users&quot;, &quot;/api/v1/orders&quot;]\n}\nimport json\n \ndef load_config(path):\n    with open(path, &#039;r&#039;, encoding=&#039;utf-8&#039;) as f:\n        cfg = json.load(f)\n    return cfg\n \nconfig = load_config(&#039;config.json&#039;)\nprint(config[&#039;host&#039;], config[&#039;port&#039;], config[&#039;use_ssl&#039;])\n# 输出：localhost 8080 True\n2. 从字符串解析并访问数据\nimport json\n \nraw = &#039;{&quot;product&quot;: &quot;laptop&quot;, &quot;price&quot;: 999.99, &quot;tags&quot;: [&quot;electronics&quot;, &quot;computer&quot;]}&#039;\nobj = json.loads(raw)\nprint(obj[&#039;product&#039;])   # &#039;laptop&#039;\nprint(obj[&#039;tags&#039;][1])   # &#039;computer&#039;\n3. 将 Python 对象写入文件\nimport json\nfrom datetime import datetime\n \ndata = {\n    &quot;event&quot;: &quot;login&quot;,\n    &quot;user&quot;: &quot;Alice&quot;,\n    &quot;timestamp&quot;: datetime.now().isoformat()\n}\n \nwith open(&#039;event.json&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    json.dump(data, f, ensure_ascii=False, indent=2)\n4. 控制输出格式：indent、separators、sort_keys\nimport json\n \nperson = {&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3}\n# 不格式化，默认分隔符\nprint(json.dumps(person))                 # {&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3}\n \n# 排序键名、不换行、去除多余空格\nprint(json.dumps(person, sort_keys=True, separators=(&quot;,&quot;, &quot;:&quot;)))\n# {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}\n \n# 美化输出\nprint(json.dumps(person, sort_keys=True, indent=4, ensure_ascii=False))\n# {\n#     &quot;a&quot;: 1,\n#     &quot;b&quot;: 2,\n#     &quot;c&quot;: 3\n# }\n\n四、进阶功能\n1. 定制化解码：object_hook 与 object_pairs_hook\n\n场景：当想把 JSON 中的某些字典转换为自定义的 Python 类实例时，可以使用 object_hook。\nobject_hook 会在解析每个 JSON 对象（dict）后被调用，其返回值会替换原本的 dict。\n\nimport json\n \nclass User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return f&quot;&lt;User name={self.name} age={self.age}&gt;&quot;\n \ndef user_decoder(dct):\n    # 如果 dict 中包含 &#039;name&#039; 和 &#039;age&#039; 字段，就生成 User 对象\n    if &#039;name&#039; in dct and &#039;age&#039; in dct:\n        return User(dct[&#039;name&#039;], dct[&#039;age&#039;])\n    return dct\n \njson_str = &#039;[{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20},{&quot;score&quot;:95}]&#039;\nobjs = json.loads(json_str, object_hook=user_decoder)\n# 结果： [&lt;User name=Tom age=20&gt;, {&#039;score&#039;: 95}]\n\n\n**object_pairs_hook**\n\n\n如果需要保留 JSON 对象中键的原始顺序，或者想用有序字典（如 collections.OrderedDict）来接收数据，则可以使用 object_pairs_hook。\n\n\n参数接受列表形式的 (key, value) 元组列表。\n\n\nimport json\nfrom collections import OrderedDict\n \njson_str = &#039;{&quot;b&quot;: 2, &quot;a&quot;: 1, &quot;c&quot;: 3}&#039;\nordered = json.loads(json_str, object_pairs_hook=OrderedDict)\n# ordered -&gt; OrderedDict([(&#039;b&#039;, 2), (&#039;a&#039;, 1), (&#039;c&#039;, 3)])\n2. 定制化序列化：default 参数\n\n当需要将自定义类或无法直接 JSON 化的对象（如 datetime、Decimal 等）转换为 JSON 时，可通过 default 参数指定如何“降级”成可序列化的类型。\n\nimport json\nfrom datetime import datetime, date\n \nclass DateEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, (datetime, date)):\n            return obj.isoformat()\n        # 调用基类方法抛出 TypeError\n        return super().default(obj)\n \ndata = {&quot;today&quot;: date.today(), &quot;event&quot;: &quot;meeting&quot;}\njson_str = json.dumps(data, cls=DateEncoder, ensure_ascii=False)\n# {&quot;today&quot;: &quot;2025-06-01&quot;, &quot;event&quot;: &quot;meeting&quot;}\n或者直接给 default 参数传入一个函数：\nimport json\nfrom datetime import datetime\n \ndef default(o):\n    if isinstance(o, datetime):\n        return o.isoformat()\n    raise TypeError(f&quot;{o!r} is not JSON serializable&quot;)\n \ndata = {&quot;time&quot;: datetime.now()}\nprint(json.dumps(data, default=default, ensure_ascii=False))\n3. 处理浮点数精度：parse_float 与 parse_int\n\n在解析大型金融数据或需要高精度的场景下，可能不希望使用 Python 默认的 float（二进制浮点），而希望使用 decimal.Decimal。\n\nimport json\nfrom decimal import Decimal\n \njson_str = &#039;{&quot;price&quot;: 19.99, &quot;quantity&quot;: 3}&#039;\n# 使用 Decimal 来解析浮点数\ndata = json.loads(json_str, parse_float=Decimal)\n# data[&#039;price&#039;] 是 Decimal(&#039;19.99&#039;)\n同理，也可自定义 parse_int，将整数字段解析为其他类型。\n\n五、错误与异常\n\n\n**json.JSONDecodeError**\n\n\n当传入的 JSON 字符串格式不合法时，会抛出此异常。通常可以捕获并定位错误位置。\n\n\nimport json\n \nbad = &#039;{&quot;name&quot;: &quot;Alice&quot;, age: 30}&#039;  # age 没有加引号\ntry:\n    obj = json.loads(bad)\nexcept json.JSONDecodeError as e:\n    print(&quot;解析错误：&quot;, e)  \n    # 输出示例：解析错误： Expecting property name enclosed in double quotes: line 1 column 17 (char 16)\n\n\n**TypeError**\n\n\n在调用 json.dumps() 时，如果遇到无法序列化且未提供 default 回调，就会抛出 TypeError。\n\n\nimport json\n \nclass A:\n    pass\n \ntry:\n    json.dumps(A())\nexcept TypeError as e:\n    print(&quot;序列化错误：&quot;, e)\n    # 输出：序列化错误： Object of type A is not JSON serializable\n\n六、性能与注意事项\n\n性能\n\n\nPython 的内建 json 模块在多数场景下性能表现合理，但对于大规模数据（几 MB 或更大），可以考虑第三方库 ujson、orjson 等，它们在序列化/反序列化速度上更快。\n如果对重复读写同一个 JSON 文件，避免频繁调用 load/dump，可考虑将内容缓存到内存中。\n\n\n字符编码\n\n\nPython 3 中，json.load/dump 时应指定正确的 encoding=&#039;utf-8&#039;（尽管在 Python 3.9+ 默认就是 UTF-8）。\n默认 json.dumps(..., ensure_ascii=True) 会把所有非 ASCII 字符转义为 \\uXXXX。如要直接输出中文或其他 Unicode 字符，需要 ensure_ascii=False。\n\n\n安全性\n\n\n从不可信来源解析 JSON 时，一般是安全的，因为 JSON 仅表示数据结构，不包含可执行代码。\n但如果将 JSON 字符串 eval、exec，则会有安全风险。切勿用 Python 的 eval 来处理 JSON。\n\n\n浮点数精度\n\n\n如果需要高精度浮点运算或金融计算，强烈建议使用 parse_float=Decimal；否则 JSON 中的浮点会被解析为 Python float，存在精度误差。\n\n\n七、常见场景示例\n1. 将自定义对象批量序列化\nimport json\nfrom datetime import datetime\n \nclass Order:\n    def __init__(self, order_id, price, date):\n        self.order_id = order_id\n        self.price = price\n        self.date = date\n \ndef order_default(obj):\n    if isinstance(obj, Order):\n        return {\n            &quot;order_id&quot;: obj.order_id,\n            &quot;price&quot;: obj.price,\n            &quot;date&quot;: obj.date.isoformat()\n        }\n    raise TypeError(f&quot;Type {type(obj)} not serializable&quot;)\n \norders = [\n    Order(1001, 199.99, datetime(2025, 5, 20)),\n    Order(1002, 289.50, datetime(2025, 5, 21))\n]\n \njson_str = json.dumps(orders, default=order_default, ensure_ascii=False, indent=2)\nprint(json_str)\n输出示例：\n[\n  {\n    &quot;order_id&quot;: 1001,\n    &quot;price&quot;: 199.99,\n    &quot;date&quot;: &quot;2025-05-20T00:00:00&quot;\n  },\n  {\n    &quot;order_id&quot;: 1002,\n    &quot;price&quot;: 289.5,\n    &quot;date&quot;: &quot;2025-05-21T00:00:00&quot;\n  }\n]\n2. 使用 object_hook 自动反序列化为自定义对象\nimport json\nfrom datetime import datetime\n \nclass Event:\n    def __init__(self, name, timestamp):\n        self.name = name\n        self.timestamp = timestamp\n    def __repr__(self):\n        return f&quot;&lt;Event {self.name} at {self.timestamp}&gt;&quot;\n \ndef event_hook(dct):\n    if &#039;name&#039; in dct and &#039;timestamp&#039; in dct:\n        dct[&#039;timestamp&#039;] = datetime.fromisoformat(dct[&#039;timestamp&#039;])\n        return Event(dct[&#039;name&#039;], dct[&#039;timestamp&#039;])\n    return dct\n \njson_data = &#039;&#039;&#039;\n[\n  {&quot;name&quot;: &quot;start&quot;, &quot;timestamp&quot;: &quot;2025-06-01T08:30:00&quot;},\n  {&quot;name&quot;: &quot;stop&quot;,  &quot;timestamp&quot;: &quot;2025-06-01T09:00:00&quot;}\n]\n&#039;&#039;&#039;\n \nevents = json.loads(json_data, object_hook=event_hook)\n# events -&gt; [&lt;Event start at 2025-06-01 08:30:00&gt;, &lt;Event stop at 2025-06-01 09:00:00&gt;]\n\n八、常见问题\n\n对 JSON 字符串进行增量解析\n\n\n标准库不支持流式增量解析，但可以借助第三方库如 json.JSONDecoder.raw_decode 方法手动分段解析。\n也可以使用 ijson、yajl 等第三方库实现对超大 JSON 的流式处理。\n\n\n如何保证序列化后字段顺序？\n\n\nPython 3.7+ 中，普通 dict 保留插入顺序，若想确保按键排序可在 dumps 时传入 sort_keys=True。\n如果需要在反序列化时保留 JSON 文件中的原始顺序，可以使用 object_pairs_hook=collections.OrderedDict。\n\n\nJSON 中含有注释怎么办？\n\n\n标准 JSON 规范中不支持注释；如果配置文件里包含注释，直接用 json 模块会报错。\n常见解决方式是：\n\n\n\n事先用正则或简单逻辑去除注释行（// ...、/* ... */）。\n\n\n使用支持注释的扩展库，如 json5、ruamel.yaml（既可读 JSON 又可读 YAML）。\n\n\n如何处理非 ASCII 字符？\n\n\n\n默认 json.dumps(..., ensure_ascii=True) 会将中文等 Unicode 字符转义为 \\uXXXX 格式。\n如需直接输出中文，使用 ensure_ascii=False。同时文件读写时注意指定 encoding=&#039;utf-8&#039;。\n\nimport json\n \ndata = {&quot;city&quot;: &quot;北京&quot;, &quot;天气&quot;: &quot;晴&quot;}\nprint(json.dumps(data, ensure_ascii=False))  # {&quot;city&quot;: &quot;北京&quot;, &quot;天气&quot;: &quot;晴&quot;}\n\n九、小结\n\n\njson 模块提供了四个核心函数：\n\n\nloads()、dumps()：处理字符串与 Python 对象互转。\n\n\nload()、dump()：处理文件与 Python 对象互转。\n\n\n常用参数：\n\n\n反序列化：object_hook（自定义类）、parse_float/parse_int（高精度数字）。\n\n\n序列化：ensure_ascii=False（保留 Unicode 非 ASCII 字符）、indent（格式化缩进）、default（自定义对象处理）、sort_keys（键排序）。\n\n\n进阶场景：\n\n\n使用 object_pairs_hook=OrderedDict 保留键顺序。\n\n\n使用自定义 JSONEncoder 或 default 函数序列化 datetime、Decimal 等类型。\n\n\n第三方库（如 ujson、orjson）可在性能敏感场景下替代内置 json。\n\n"},"python/2.常用库与工具/标准库与内置模块/数据处理/pickle":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/pickle","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/pickle.md","title":"pickle","links":[],"tags":[],"content":"一、模块概述\n\n什么是 **pickle**\n\n\npickle 是 Python 标准库提供的将 Python 对象转换为字节流（序列化，pickling）以及将字节流恢复为原始 Python 对象（反序列化，unpickling）的工具。\n其设计目标是：在同一台机器或通过网络在受信任环境中，保存或传输复杂的 Python 对象（如列表、字典、类实例、函数引用等），并在之后恢复为“活”的对象，以便继续操作。\n\n\n主要应用场景\n\n\n持久化存储：将某些中间计算结果或数据结构缓存到磁盘，下次程序启动时直接加载，而不用重新计算。\n跨进程/网络传输：在分布式任务、RPC、消息队列等场景中，将 Python 对象打包传输，接收端再恢复。\n深拷贝：利用 pickle.dumps() + pickle.loads() 可快速复制复杂对象（对循环引用也能正确处理）。\n调试与快照：在运行时把程序状态“拍照”保存下来，以便后续分析。\n\n\n与其他序列化工具的对比\n\n\n与 json 相比，pickle 可以序列化几乎所有 Python 对象（包括自定义类、函数引用、循环引用等），而 json 只能处理基础类型（dict、list、字符串、数字、布尔、None）或者需要自行转换。\n与 marshal 相比，marshal 更底层、速度略快，但只适用于 Python 内部对象（比如编译后的字节码），且在不同 Python 版本间不保证兼容，官方不推荐用于一般持久化。\n与第三方库（如 dill、cloudpickle）相比，pickle 局限在标准库中，不依赖第三方，但对闭包、Lambda、动态生成的类或函数支持有限，且在跨 Python 版本时可能不兼容。\n\n\n二、核心接口与示例\n1. pickle.dump 与 pickle.load\n\n\n**dump(obj, file, protocol=None, *, fix_imports=True)**\n\n\n将 obj 序列化后写入到给定的文件类对象 file（必须以二进制模式打开，如 &#039;wb&#039;）。\n\n\nprotocol 参数用于指定使用的序列化协议版本，默认为 pickle.HIGHEST_PROTOCOL（当前 Python 版本最高支持的协议）。\n\n\nfix_imports 用于在 Python 2/3 兼容时修正模块名，一般保持默认即可。\n\n\n**load(file, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)**\n\n\n从文件对象 file（必须以二进制模式打开，如 &#039;rb&#039;）中读取字节流，并尝试反序列化为 Python 对象。\n\n\n如果 pickle 数据来源于 Python 2，且在 Python 3 中加载，需要配合 encoding 参数（常用 &#039;utf-8&#039; 或 &#039;latin1&#039;）来正确解码原始字节。\n\n\nimport pickle\n \n# 示例：将一个列表写入文件\ndata = {&#039;a&#039;: [1, 2, 3], &#039;b&#039;: (&quot;hello&quot;, 3.14)}\nwith open(&#039;data.pkl&#039;, &#039;wb&#039;) as f:\n    # 指定协议版本为 4（可选）\n    pickle.dump(data, f, protocol=4)\n \n# 从文件中加载\nwith open(&#039;data.pkl&#039;, &#039;rb&#039;) as f:\n    loaded = pickle.load(f)\n    print(type(loaded), loaded)  # &lt;class &#039;dict&#039;&gt; {&#039;a&#039;: [1, 2, 3], &#039;b&#039;: (&#039;hello&#039;, 3.14)}\n2. pickle.dumps 与 pickle.loads\n\n\n**dumps(obj, protocol=None, *, fix_imports=True)**\n\n\n将 obj 序列化为 bytes 对象并返回，可用于网络传输或存入数据库等。\n\n\n**loads(data_bytes, *, fix_imports=True, encoding=&quot;ASCII&quot;, errors=&quot;strict&quot;)**\n\n\n将 data_bytes（类型为 bytes 或 bytearray）反序列化为 Python 对象。\n\n\nimport pickle\n \n# 将对象序列化为内存中的 bytes\nraw = pickle.dumps([1, 2, 3], protocol=pickle.HIGHEST_PROTOCOL)\nprint(type(raw), raw[:10], &#039;...&#039;)  # &lt;class &#039;bytes&#039;&gt; b&#039;\\x80\\x05]\\x00\\x00\\x00\\x00\\x00\\x00\\x...&#039;\n \n# 从 bytes 恢复原始对象\nlst = pickle.loads(raw)\nprint(type(lst), lst)  # &lt;class &#039;list&#039;&gt; [1, 2, 3]\n要点提示\n\ndump/load 适用于文件，dumps/loads 适用于内存或网络。\npickle 数据格式本质是 Python 专用的二进制格式（也支持早期的 ASCII 文本协议，但默认为二进制）。\n始终以二进制模式打开文件：写模式 &#039;wb&#039;，读模式 &#039;rb&#039;。\n\n\n三、协议（Protocols）与兼容性\nPython 的 pickle 协议随着版本演进不断扩展新功能、优化性能与压缩率。常见协议版本包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n协议版本描述Python 添加版本0原始 ASCII 文本格式，兼容极早期的 Python 。Python 1.0 及以上1第一版二进制格式，比协议 0 更紧凑。Python 1.42支持扩展类型（extension types）和新式类（new-style classes）。Python 2.33Python 3 专用的二进制协议，不兼容 Python 2 的反序列化。Python 3.04改进对大对象（例如大于 4GB）支持，提供对 collections.OrderedDict等新内置类型的优化。Python 3.45引入对 out-of-band 缓冲区（buffer out-of-band）协议的支持，可更高效地序列化大型字节对象（如 bytes）。Python 3.8\n\n\n默认协议\n\n\n在 Python 3.x 中，pickle.dump 默认使用 pickle.HIGHEST_PROTOCOL，一般会选择当前解释器能支持的最高协议（例如 Python 3.10 就是协议 5）。\n\n\n如果需要与旧版本 Python 共享数据，可显式指定 protocol=2 或 protocol=3。\n\n\n跨版本兼容\n\n\n若要在 Python 2.x 与 Python 3.x 之间共享 pickle 数据，推荐在两端都使用协议 2 或 3；Python 2 只能读到 2 及以下，不兼容 3。\n\n\n在 Python 3 中加载由 Python 2 生成的 pickle 时，可能需要指定 encoding=&#039;latin1&#039; 或 encoding=&#039;bytes&#039;，以保留原始字节值，否则默认 ASCII 解码会报错。\n\n\n# Python 2 端生成（示意）：\n#   import pickle\n#   data = {&#039;x&#039;: b&#039;\\xe4\\xb8\\xad&#039;}  # 一些二进制\n#   with open(&#039;py2data.pkl&#039;, &#039;wb&#039;) as f:\n#       pickle.dump(data, f, protocol=2)\n \n# Python 3 端加载：\nimport pickle\n \nwith open(&#039;py2data.pkl&#039;, &#039;rb&#039;) as f:\n    # 使用 latin1 保证原始字节不丢失\n    data_py2 = pickle.load(f, fix_imports=True, encoding=&#039;latin1&#039;)\n    print(data_py2)  # {&#039;x&#039;: b&#039;\\xe4\\xb8\\xad&#039;}\n要点提示\n\n尽量保持协议一致：如果项目中有多台机器互通 pickle 二进制，最好统一指定协议版本并写入文档说明。\n协议 4/5 对大对象更友好：当你的数据中包含超大 bytes、bytearray 时，协议 5 在性能和内存占用上有明显改进。\n明确 **encoding**：跨 Python 版本加载时，encoding=&#039;latin1&#039; 会把所有原始字节映射到对应 Unicode 0–255 码位，不会丢数据。\n\n\n四、示例：简单读写流程\n下面以一个稍复杂的对象为例，演示完整的序列化与反序列化流程。\nimport pickle\nimport datetime\n \n# 1. 定义一个自定义类，用于演示\nclass Person:\n    def __init__(self, name, birth):\n        self.name = name\n        self.birth = birth  # datetime.date 对象\n    def __repr__(self):\n        return f&quot;&lt;Person name={self.name!r} birth={self.birth!r}&gt;&quot;\n \n# 2. 创建一个复杂结构：包含列表、字典、实例、内置对象\nalice = Person(&quot;Alice&quot;, datetime.date(1990, 5, 17))\nbob = Person(&quot;Bob&quot;, datetime.date(1985, 12, 3))\nteam = {\n    &quot;members&quot;: [alice, bob],\n    &quot;created&quot;: datetime.datetime.now(),\n    &quot;metadata&quot;: {&quot;project&quot;: &quot;Demo&quot;, &quot;count&quot;: 2}\n}\n \n# 3. 序列化到文件\nwith open(&quot;team.pkl&quot;, &quot;wb&quot;) as fw:\n    pickle.dump(team, fw, protocol=pickle.HIGHEST_PROTOCOL)\n \n# 4. 反序列化回内存\nwith open(&quot;team.pkl&quot;, &quot;rb&quot;) as fr:\n    loaded_team = pickle.load(fr)\n \nprint(type(loaded_team), loaded_team)\n# &lt;class &#039;dict&#039;&gt; {&#039;members&#039;: [&lt;Person name=&#039;Alice&#039; birth=datetime.date(1990, 5, 17)&gt;, ...], ...}\n \n# 5. 验证对象类型保持不变\nfor member in loaded_team[&quot;members&quot;]:\n    print(type(member), member.name, member.birth, member.birth.year)\n# &lt;class &#039;__main__.Person&#039;&gt; Alice 1990-05-17 1990\n# &lt;class &#039;__main__.Person&#039;&gt; Bob 1985-12-03 1985\n要点提示\n\n自定义类实例可以“开箱即用”被 pickle 化，前提是：类定义可以被导入（即在反序列化时能够按同样的模块路径找到该类）。\n如果你的类定义在交互式解释器（__main__）或某些动态生成的模块中，反序列化时可能会因找不到类而报错。\n内置类型（如 datetime.date、list、dict、tuple）都会自动按理想方式序列化。\n\n\n五、安全注意事项\n⚠️ 非常重要：不要对来自不可信来源的 pickle 数据执行 **pickle.load** 或 **pickle.loads**。\n\n为什么不安全\n\n\npickle 在反序列化时会执行“任意”构造指令、调用任意类/函数、甚至导入模块并执行它们的 __reduce__、__setstate__ 等方法。一个恶意构造的 pickle 二进制可以在反序列化阶段执行恶意代码（如删除文件或下载执行脚本）。\n\n\n安全替代\n\n\n如果需要从不可信来源加载数据，应使用更安全的格式，例如 JSON、YAML（需谨慎选择安全加载函数）、或专门的沙箱化反序列化库。\n也可在可信环境下先解析 pickle 流，检查其中的内容，但这一般非常复杂且容易出错。\n\n\n仅限受信任环境\n\n\n如果你明确知道数据来源、运行环境完全可信，可放心使用 pickle，以获得最灵活的序列化能力。\n网络服务中若需要传输 Python 对象，推荐在应用层加签名或加密 pickle 数据，以确保接收端能够识别来源并防止中间人篡改。\n\n\n六、进阶用法：定制序列化与反序列化\n1. 基本原理：__getstate__ 与 __setstate__\n\n如果一个类定义了 __getstate__(self)，则在 pickle 时会调用该方法，获取一个状态（通常为字典或基本类型）作为实际要 pickle 的“payload”。\n在 unpickle 时，如果类定义了 __setstate__(self, state)，反序列化后会先创建一个空对象实例，然后将 state 传入该方法，以恢复实例状态。\n\nimport pickle\nimport datetime\n \nclass Event:\n    def __init__(self, name, timestamp=None):\n        self.name = name\n        # timestamp 不可直接序列化，举例替换成 ISO 格式字符串\n        self.timestamp = timestamp or datetime.datetime.now()\n \n    def __getstate__(self):\n        # 返回要 pickle 的状态。timestamp 转成 ISO 字符串\n        state = self.__dict__.copy()\n        state[&#039;timestamp&#039;] = self.timestamp.isoformat()\n        return state\n \n    def __setstate__(self, state):\n        # 反序列化时，将字符串再转换为 datetime 对象\n        timestamp_str = state.get(&#039;timestamp&#039;)\n        if timestamp_str:\n            state[&#039;timestamp&#039;] = datetime.datetime.fromisoformat(timestamp_str)\n        self.__dict__.update(state)\n \n    def __repr__(self):\n        return f&quot;&lt;Event {self.name} at {self.timestamp}&gt;&quot;\n \n# 演示\nevt = Event(&quot;TestEvent&quot;)\nraw = pickle.dumps(evt)\nevt2 = pickle.loads(raw)\nprint(evt2, type(evt2.timestamp))  # &lt;Event TestEvent at 2025-06-02T...&gt; &lt;class &#039;datetime.datetime&#039;&gt;\n要点提示\n\n当类包含某些不可序列化的成员（如打开的文件句柄、数据库连接、线程锁等），可以在 __getstate__ 中剔除或转换，仅保留可恢复的必要部分。\n__getstate__ 必须返回纯 Python 类型（内置类型或其他能直接 pickle 的类型）；__setstate__ 则以相反思路恢复。\n如果未定义 __getstate__/__setstate__，pickle 默认会将 obj.__dict__ 全部 pickle（即逐属性写入），然后反序列化时重建 __dict__。\n\n2. 更灵活的钩子：__reduce__ 与 __reduce_ex__\n\n\n__reduce__ 返回一个元组，告诉 pickle 如何重建该对象。典型格式为 (callable, args, state, listiterator, dictiterator) 中前两个元素最常用。\n\n\ncallable：用于创建新对象的可调用对象（如类本身、工厂函数等）。\n\n\nargs：调用该 callable(*args) 时的参数元组，用于生成“空”对象。\n\n\nstate：一个任意的状态（如 __dict__），pickle 会在创建新对象后，将其传递给新对象的 __setstate__ 或直接赋值 obj.__dict__ = state。\n\n\n__reduce_ex__ 是更高级的接口，默认实现会调用 __reduce__。通常无需自定义，除非对不同协议版本有细粒度控制。\n\n\nimport pickle\n \nclass MyRange:\n    def __init__(self, start, stop):\n        self.start = start\n        self.stop = stop\n \n    def __iter__(self):\n        return iter(range(self.start, self.stop))\n \n    def __reduce__(self):\n        # 当 pickle 时，告诉它如何重建自己：\n        #   首先调用 MyRange(self.start, self.stop)，得到一个实例\n        #   然后 pickle 会将 __dict__ 作为 state 继续处理，但这里没有额外 state\n        return (MyRange, (self.start, self.stop))\n \n# 演示\nr = MyRange(5, 10)\ndata = pickle.dumps(r)\nr2 = pickle.loads(data)\nprint(list(r2))  # [5, 6, 7, 8, 9]\n要点提示\n\n当类需要更细粒度地控制序列化流程（例如类有工厂函数、单例模式、缓存机制等），可通过 __reduce__ 指定“重建步骤”。\n返回的元组可以包含 2 到 5 个元素，最常见仅返回 (callable, args) 或 (callable, args, state)。\n如果希望指定自定义的 state，则在返回 (callable, args, state) 之后，pickle 会先调用 callable(*args) 得到对象实例，再自动将 state 赋予该对象（即调用 __setstate__ 或直接 __dict__ 更新）。\n\n\n七、对象引用、循环引用与共享\n\n自动处理对象引用\n\n\nPickle 会自动记录对象引用（memoization），如果同一个对象在多个位置重复出现，pickle 只保存一份，并在反序列化时保持“共享”关系。\n例如，以下示例中，lst[0] 与 lst[1] 都指向同一个列表对象，反序列化后仍保持这一引用关系。\n\nimport pickle\n \nshared = [1, 2, 3]\ncontainer = [shared, shared]\nraw = pickle.dumps(container)\nrestored = pickle.loads(raw)\n \nprint(restored[0] is restored[1])  # True，说明指向同一对象\n\n循环引用\n\n\nPickle 能够正确处理“自引用”或“循环引用”的对象图。反序列化后仍能保持循环结构。\n例如，下面创建了一个节点循环引用的链表：a.next = b，b.next = a。\n\nimport pickle\n \nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = None\n    def __repr__(self):\n        nxt = self.next.name if self.next else None\n        return f&quot;&lt;Node {self.name}-&gt;{nxt}&gt;&quot;\n \na = Node(&quot;A&quot;)\nb = Node(&quot;B&quot;)\na.next = b\nb.next = a  # 循环\n \ndata = pickle.dumps(a)\na2 = pickle.loads(data)\n \n# 验证循环依然存在\nprint(a2, a2.next, a2.next.next)     # &lt;Node A-&gt;B&gt; &lt;Node B-&gt;A&gt; &lt;Node A-&gt;B&gt;\nprint(a2.next.next is a2)            # True\n要点提示\n\nPickle 底层维护一个 internal memo 表，记录已序列化的对象 id，以便避免重复并妥善处理循环和多次引用。\n循环引用不会导致死循环或无限递归，因为 pickle 会先为对象分配“占位标识”，之后再填充引用。\n\n\n八、流式读写与定制流\n除了最常见的直接对文件执行 dump/load，pickle 还提供了更底层的 Pickler 与 Unpickler 类，可对流进行更灵活的控制。\n1. 使用 Pickler 与 Unpickler\nimport pickle\n \n# Pickler 用于直接向文件流或其他可写二进制流写入 pickle 数据\nwith open(&quot;stream.pkl&quot;, &quot;wb&quot;) as f:\n    pkl = pickle.Pickler(f, protocol=pickle.HIGHEST_PROTOCOL)\n    pkl.dump({&quot;x&quot;: 1})\n    pkl.dump([1, 2, 3])\n    # 这样做，将在同一文件中接连写入两个 pickle 对象\n \n# Unpickler 逐个读取 pickle 对象\nwith open(&quot;stream.pkl&quot;, &quot;rb&quot;) as f:\n    up = pickle.Unpickler(f)\n    obj1 = up.load()\n    obj2 = up.load()\n    print(obj1)  # {&#039;x&#039;: 1}\n    print(obj2)  # [1, 2, 3]\n2. 从自定义字节流（如 BytesIO）读写\nimport pickle\nfrom io import BytesIO\n \nbuf = BytesIO()\npicker = pickle.Pickler(buf)\npicker.dump((&quot;hello&quot;, 123))\n# 此时 buf.getvalue() 返回完整的 pickle bytes\n \nbuf.seek(0)\nunpicker = pickle.Unpickler(buf)\ntup = unpicker.load()\nprint(tup)  # (&#039;hello&#039;, 123)\n要点提示\n\n通过 Pickler 的 dump 方法可以多次写入多个对象；相应地，Unpickler 的 load 方法可反复调用，一次读一个对象。\n如果你希望在网络传输层面对 pickle 二进制做分块处理或加密，使用 Pickler/Unpickler 加上自定义的流（socket、加密通道等）能更灵活地控制读写过程。\n\n\n九、自定义扩展：copyreg 与扩展类型注册\n在一些高级场景下，你可能需要为某些类型提供“全局”注册的定制序列化逻辑，而不想在类内部写 __reduce__。这时可以使用标准库的 copyreg（Python 2 中称 copy_reg）。\n1. 注册简单函数实现\nimport pickle\nimport copyreg\n \n# 假设有一个不可变的类型：Fraction（可直接用 fractions.Fraction，可用此示意）\nclass Fraction:\n    def __init__(self, num, den):\n        self.num = num\n        self.den = den\n    def __repr__(self):\n        return f&quot;{self.num}/{self.den}&quot;\n \n# 定制的 reduce 函数：返回 (callable, args)\ndef reduce_fraction(frac):\n    return (Fraction, (frac.num, frac.den))\n \n# 注册到 copyreg\ncopyreg.pickle(Fraction, reduce_fraction)\n \n# 使用示例\nf = Fraction(3, 4)\ndata = pickle.dumps(f)\nf2 = pickle.loads(data)\nprint(f2, type(f2))  # 3/4 &lt;class &#039;__main__.Fraction&#039;&gt;\n要点提示\n\ncopyreg.pickle(type, reduce_func)：告诉 pickle，当碰到 type 的实例时，直接调用 reduce_func(obj)，该函数需返回一个 (callable, args) 元组或 (callable, args, state)。\n相比在类内部写 __reduce__，copyreg 实现了“与类解耦”，更适合向第三方类型（如在你控制不到其源码的情况下）或当你不想在类内添加序列化逻辑时使用。\n\n\n十、进阶功能：Persistent ID / Persistent Load\n在一些场景下，比如大型对象图中有数以千计的重复子对象，你希望在序列化时不把它们都打散到文件里，而是只保存一个“标识符”，在反序列化时通过“回调”去查找或重建实际对象。Pickle 提供了“persistent_id”和“persistent_load”机制来支持这样的策略。\n1. 概念简述\n\n**persistent_id(obj)**：当 Pickler 在序列化时，为每个对象调用该方法。如果该方法返回 None，表示按正常流程序列化；如果返回一个任意非 None 的值（如字符串、数字、元组等），Pickle 会把这个值写入序列化流中，而不序列化该对象本身。\n**persistent_load(pid)**：当 Unpickler 反序列化时，如果看到某个 PID（persistent ID）占位符，会调用此方法，将 pid 转换为“真正”的对象。\n\n通过这两个钩子，可以实现对大型共享对象或数据库对象的灵活处理。\n2. 示例：数据表行引用\n假设有一个进程需要把“用户对象”与“订单对象”序列化，但想把用户对象保存在数据库里，只在 pickle 中保留其 user_id，反序列化时再从数据库中查回完整 User 对象。\nimport pickle\n \n# 模拟数据库\nDB = {\n    &#039;users&#039;: {\n        1: {&#039;name&#039;: &#039;Alice&#039;, &#039;age&#039;: 30},\n        2: {&#039;name&#039;: &#039;Bob&#039;, &#039;age&#039;: 25},\n    }\n}\n \nclass User:\n    def __init__(self, uid):\n        self.uid = uid\n        # 其余属性从 DB 动态加载\n    def __repr__(self):\n        data = DB[&#039;users&#039;][self.uid]\n        return f&quot;&lt;User id={self.uid} name={data[&#039;name&#039;]} age={data[&#039;age&#039;]}&gt;&quot;\n \nclass Order:\n    def __init__(self, order_id, user):\n        self.order_id = order_id\n        self.user = user\n    def __repr__(self):\n        return f&quot;&lt;Order id={self.order_id} user={self.user!r}&gt;&quot;\n \n# 1. 自定义 Pickler，重写 persistent_id\nclass MyPickler(pickle.Pickler):\n    def persistent_id(self, obj):\n        if isinstance(obj, User):\n            # 返回用户的唯一标识符，而非 pickle 对象本身\n            return (&#039;USER&#039;, obj.uid)\n        else:\n            return None   # 否则按常规 pickle 处理\n \n# 2. 自定义 Unpickler，重写 persistent_load\nclass MyUnpickler(pickle.Unpickler):\n    def persistent_load(self, pid):\n        # pid 是 (&#039;USER&#039;, uid)\n        type_tag, uid = pid\n        if type_tag == &#039;USER&#039;:\n            # 根据 uid 从 DB 重建 User 实例\n            return User(uid)\n        else:\n            raise pickle.UnpicklingError(&quot;Unsupported persistent object: %r&quot; % (pid,))\n \n# 演示\nuser1 = User(1)\norder = Order(1001, user1)\n \n# 序列化时，仅把 (&#039;USER&#039;, 1) 写入 pickle 流\nbuf = BytesIO()\nmp = MyPickler(buf)\nmp.dump(order)\n \n# 反序列化时，根据 pid 再从 DB 里查回 User(1)\nbuf.seek(0)\nmu = MyUnpickler(buf)\nrestored_order = mu.load()\nprint(restored_order)  # &lt;Order id=1001 user=&lt;User id=1 name=Alice age=30&gt;&gt;\n要点提示\n\npersistent_id 接受一个对象实例，如果该方法返回非 None，Pickler 在序列化时只保留该 “持久化 ID”。\npersistent_load 接受这个 ID，并负责将其转换为新的对象实例。\n这种模式下，你可以避免在 pickle 文件中写入大量冗余数据，只保留外部资源的引用（如数据库主键、文件路径等），在反序列化时再做重建。\n\n\n十一、常见问题与最佳实践\n1. 不要把函数、Lambda 或本地（nested）类轻易 pickle\n\n只能对顶层（module 级）定义的函数和类进行 pickle。如果你用 lambda、嵌套函数或交互式脚本里定义的类，pickle 会报错：“Can’t pickle &lt;lambda&gt;: attribute lookup … failed”。\n如果确实想序列化函数，可考虑使用第三方库（如 dill、cloudpickle），它们对闭包、Lambda 支持更好。\n\nimport pickle\n \ndef fn(x): return x * 2\nraw = pickle.dumps(fn)          # 可以，因为 fn 是顶层函数\ng = pickle.loads(raw)\nprint(g(5))                     # 10\n \nh = lambda x: x+1\npickle.dumps(h)                 # 报错：Can&#039;t pickle &lt;function &lt;lambda&gt; ...&gt;\n2. 注意对象定义位置与导入路径\n\n反序列化时，pickle 会根据对象在序列化时的 __module__ 和 __qualname__ 去定位类/函数。所以如果类定义移动到其他模块或改名，反序列化就会失败。\n例如，如果你把 class Foo 从 mymodule 移动到 newmodule，之前 pickle 的数据就会报错：ModuleNotFoundError 或 AttributeError。\n\n3. 避免臃肿的数据结构\n\n\n虽然 pickle 能序列化任意复杂对象，但对非常巨大的图结构，pickle 文件会很大，并且反序列化耗时也长。可考虑：\n\n\n对关键数据做筛选，只 pickle 必要字段。\n\n\n对深度嵌套对象或循环引用做好评估，或使用数据库/专门存储工具。\n\n\n4. 当心版本升级导致的不兼容\n\n如果你的应用需要在不同版本的 Python、或不同版本的自定义类之间共享 pickle 数据，最好：\n\n\n明确记录协议版本：在文档里标记“此数据使用 protocol=2”，以确保各方使用一致。\n编写兼容代码：在类定义中提供兼容旧版本 pickle 的 __setstate__、__reduce__ 等方法，动态根据不同状态初始化。\n迁移工具：如果类结构改变（新增/删除属性），可写脚本遍历旧数据，做“升级迁移”。\n\n5. 性能与 C 实现的区别\n\nCPython 实现中，_pickle 模块（C 语言版本）在大多数情况下会优先被导入，以获得更高的执行效率；它与 Python 版本的纯 Python 实现具有相同 API。\n反序列化大型对象时，若能选用 C 版的 pickle，可显著提升速度。通常在不做特别限制的情况下，导入 import pickle 就会自动使用 C 版实现；若需要纯 Python 实现可显式：\n\nimport pickle\n# 强制使用纯 Python 版本\nimport _pickle as cPickle  # 反而更快，通常不做此操作\n\n\n对比来看：\n\n\n协议 0/1/2/3/4/5：协议本身决定了编码方式和功能。\n\n\n实现：pickle（Python） vs _pickle（C）只是性能差异，API 完全相同。\n\n\n\n十二、常用示例汇总\n1. 将多个对象存储到同一个文件中\nimport pickle\n \nobjs = [{&quot;name&quot;: &quot;A&quot;}, {&quot;name&quot;: &quot;B&quot;}, [1, 2, 3]]\n \nwith open(&quot;multi.pkl&quot;, &quot;wb&quot;) as f:\n    p = pickle.Pickler(f)\n    for obj in objs:\n        p.dump(obj)\n \n# 读取时逐行 load\nwith open(&quot;multi.pkl&quot;, &quot;rb&quot;) as f:\n    up = pickle.Unpickler(f)\n    while True:\n        try:\n            o = up.load()\n            print(&quot;Loaded:&quot;, o)\n        except EOFError:\n            break\n2. 使用 shelve 模拟简单数据库\n虽然 shelve 背后也是基于 pickle，但它为你封装了 key→value 存储，类似字典接口：\nimport shelve\n \n# 打开一个 on-disk “字典”\nwith shelve.open(&quot;mydata.db&quot;) as db:\n    db[&quot;config&quot;] = {&quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 8080}\n    db[&quot;users&quot;] = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;]\n \n# 再次打开时，直接像访问字典一样访问\nwith shelve.open(&quot;mydata.db&quot;) as db2:\n    print(db2[&quot;config&quot;])  # {&#039;host&#039;: &#039;127.0.0.1&#039;, &#039;port&#039;: 8080}\n    print(db2[&quot;users&quot;])   # [&#039;Alice&#039;, &#039;Bob&#039;, &#039;Carol&#039;]\n要点提示\n\nshelve 的实现：对每个 key 对应的 value 都是 pickle 化后存储为值。\nshelve 底层一般有 dbm（如 dbm.gnu、dbm.ndbm 等）来做索引，value 部分才是 pickle 数据。\n\n3. 使用 pickle 实现简单缓存（Memoization）\nimport pickle\nimport os\nimport functools\n \ndef disk_cache(cache_file):\n    &quot;&quot;&quot;\n    简单的磁盘缓存装饰器：如果 cache_file 存在，直接 load，否则执行 func 并 save。\n    &quot;&quot;&quot;\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            if os.path.exists(cache_file):\n                with open(cache_file, &#039;rb&#039;) as f:\n                    print(&quot;Loading from cache...&quot;)\n                    return pickle.load(f)\n            result = func(*args, **kwargs)\n            with open(cache_file, &#039;wb&#039;) as f:\n                print(&quot;Storing to cache...&quot;)\n                pickle.dump(result, f, protocol=pickle.HIGHEST_PROTOCOL)\n            return result\n        return wrapper\n    return decorator\n \n@disk_cache(&quot;heavy_calc.pkl&quot;)\ndef heavy_calculation(x):\n    # 模拟耗时计算\n    import time; time.sleep(2)\n    return x * x\n \n# 第一次执行要模拟耗时\nprint(heavy_calculation(10))  # 延迟 ~2s，存入 cache\n# 第二次直接从 cache 中读取\nprint(heavy_calculation(10))  # 立即返回\n\n十三、常见错误与排查\n\n**AttributeError: Can&#039;t pickle &lt;class &#039;XXX&#039;&gt;: attribute lookup failed**\n\n\n原因：要 pickle 的对象所属类（或函数）定义在交互式环境、本地作用域或动态创建上下文，不在可 import 的模块路径下。\n解决：将类/函数提取到单独的 .py 模块文件中，并以模块方式导入；确保模块路径在 sys.path 中。\n\n\n**UnpicklingError: invalid load key, &#039;&lt;fragments of data&gt;&#039;**\n\n\n\n原因：试图对非 pickle 数据调用 pickle.load，如直接打开了文本文件、或文件损坏、读写混用了文本模式与二进制模式。\n\n\n解决：\n\n\n确保序列化时使用 wb，反序列化时使用 rb。\n\n\n确认读写的是同一个 pickle 文件，且文件无损坏。\n\n\n\n跨版本 **UnicodeDecodeError** 或 **TypeError**\n\n\n原因：Python 2 序列化的某些对象（如 bytes）在 Python 3 中默认当作文本处理，需要额外指定 encoding=&#039;latin1&#039;。\n解决：加载时用：\n\npickle.load(f, fix_imports=True, encoding=&#039;latin1&#039;)\n\n十四、总结与最佳实践要点\n\n仅在受信任环境中使用：绝对不要 pickle.load 来自网络、用户上传或其他不可信数据。\n协议选择：\n\n\n默认使用 pickle.HIGHEST_PROTOCOL 以获得更高效的编码。\n若需跨 Python 版本，统一指定一个兼容协议（如 2 或 3）。\n\n\n类定义要尽量模块化：避免把类定义写在交互式环境或脚本内部，以免反序列化时报 ModuleNotFoundError。\n定制序列化：利用 __getstate__/__setstate__ 或 __reduce__ 实现对不可序列化成员（文件句柄、线程锁、数据库连接等）的剥离与恢复。\n循环引用与共享：pickle 自动处理，不用额外干预，但要注意序列化的图形规模，过大可能导致内存和性能问题。\n性能考虑：\n\n\n对大型二进制对象（如大数组、大 bytes）使用协议 5 更高效。\n在 CPython 中会自动使用 C 版 _pickle，无需手动干预。\n\n\n对外部资源引用：使用 persistent_id / persistent_load 可避免把所有数据都写入文件，仅存储引用；适用于数据库对象、大文件句柄等。\n替代方案：在跨语言、跨平台需求下，建议使用 JSON、MessagePack、Protocol Buffers、Avro 等更通用的序列化方案。\n调试与验证：\n\n\n如果不确定序列化后是否可安全反序列化，可在开发环境先 dump 再 load，验证对象属性、方法是否完整。\n使用 pickletools.dis 可以反汇编码数据，了解 pickle 流的组成。\n"},"python/2.常用库与工具/标准库与内置模块/数据处理/re（正则表达式）":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/re（正则表达式）","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/re（正则表达式）.md","title":"re（正则表达式）","links":[],"tags":[],"content":"一、re 模块概述\n\nre 模块提供对正则表达式（Regular Expression）的支持，用于在字符串中进行模式匹配、搜索、替换、切分等操作。\n正则表达式是一种描述字符模式的语言，能够用一行“式子”表示复杂的匹配逻辑，适用于验证、提取和改写文本内容。\n在 Python 中，re 模块封装了 C 语言层面的正则引擎，因此性能较好，API 也相对完整。\n\n\n二、编译与匹配流程\n\n编译（Compiling）\n\n\nPython 中的正则表达式在首次使用时会被编译成内部表示（字节码），并缓存以供后续重复使用（最多缓存 512 个模式）。\n通过 re.compile(pattern, flags=0) 可以显式地把模式字符串编译成一个正则对象（Pattern），这样在循环或重复匹配时可以提高性能。\n如果直接使用 re.search()、re.match() 等顶级函数，底层也会隐式地调用编译和缓存机制。\n\nimport re\n \n# 显式编译\npat = re.compile(r&#039;\\d{3}-\\d{4}&#039;)    # 匹配“xxx-xxxx”格式的简易电话号码\nm = pat.search(&quot;联系：010-1234 或 021-5678&quot;)\nif m:\n    print(m.group())   # 输出：010-1234\n\n匹配流程（Matching）\n\n\n**Pattern** 对象：由 compile() 返回，包含了可复用的匹配方法，如 search()、match()、findall()、finditer()、split()、sub() 等。\n**Match** 对象：调用匹配方法（如 search()、match() 等）后返回。Match 对象封装了匹配位置、分组信息，可通过 group()、groups()、start()、end()、span() 等方法获取具体结果。\n缓存机制：如果多次使用相同 pattern 而未显式编译，Python 会自动缓存并复用，节省反复编译的开销。\n\n\n三、正则表达式语法与常用用法\n1. 字符匹配基础\n\n普通字符：如英文字母、数字等，直接与文本中的字符一一对应。\n点号（**.**）：匹配除换行符（\\n）之外的任意单个字符。若启用 DOTALL 标志，则可匹配包括换行在内的所有字符。\n转义字符（**\\**）：用于引用特殊字符或表示元字符。例如，\\d 表示数字（等价于 [0-9]），\\w 表示字母/数字/下划线（等价于 [A-Za-z0-9_]），\\s 表示空白字符（包含空格、制表符、换行等）。要匹配普通符号或元字符本身，需要在它们前面加 \\，如 \\. 表示匹配“点号本身”。\n\n常见预定义字符类别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n语法含义\\d匹配一个数字字符，等价于 [0-9]\\D匹配一个非数字字符，等价于 [^0-9]\\w匹配一个字母、数字或下划线字符，等价于 [A-Za-z0-9_]\\W匹配一个非字母数字下划线字符，等价于 [^A-Za-z0-9_]\\s匹配一个空白字符（空格、制表符、换行、回车等），等价于 [ \\t\\n\\r\\f\\v]\\S匹配一个非空白字符.匹配除换行符 \\n之外的任意字符（若启用 DOTALL，则匹配任何字符，包括换行）\n2. 量词（Quantifiers）：重复次数的控制\n量词用于指定前一个原子（单个字符、字符类或分组）的重复次数。默认情况下，量词为“贪婪”（greedy），尽可能多地匹配。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n量词含义示例*匹配前一个原子 0 次或多次（相当于 {0,}）a*匹配 &#039;&#039;, &#039;a&#039;, &#039;aaaa&#039;+匹配前一个原子 1 次或多次（相当于 {1,}）a+匹配 &#039;a&#039;, &#039;aaaa&#039;，但不匹配 &#039;&#039;?匹配前一个原子 0 次或 1 次（相当于 {0,1}）a?匹配 &#039;&#039;或 &#039;a&#039;{m}精确匹配前一个原子 m 次a{3}匹配 &#039;aaa&#039;{m,n}匹配前一个原子至少 m 次，最多 n 次a{2,4}匹配 &#039;aa&#039;, &#039;aaa&#039;, &#039;aaaa&#039;{m,}匹配前一个原子至少 m 次a{2,}匹配 &#039;aa&#039;, &#039;aaa&#039;等\n贪婪 vs 非贪婪\n\n\n默认量词为贪婪：尽可能多地匹配，再回溯以满足整个表达式。\n\n\n在量词后面加 ?，即可变为非贪婪（reluctant/lazy），尽可能少地匹配。例如：\n\n\na.*b：从第一个 a 开始，匹配到最后一个 b（若原文中有多个），范围最大。\n\n\na.*?b：从第一个 a 开始，匹配到最靠近的第一个 b，范围最小。\n\n\n实际对比：\nimport re\n \ntext = &quot;a123b456b&quot;\nprint(re.search(r&#039;a.*b&#039;, text).group())    # 匹配 &#039;a123b456b&#039;\nprint(re.search(r&#039;a.*?b&#039;, text).group())   # 匹配 &#039;a123b&#039;\n3. 边界（Anchors）与位置匹配\n\n^：匹配字符串的开始（若启用 MULTILINE，也匹配每行开头）。\n$：匹配字符串的结束（若启用 MULTILINE，也匹配每行结尾，注意在末尾 \\n 前匹配）。\n\\b：匹配“单词边界”（word boundary），即字母、数字或下划线与非字母数字下划线之间的位置。\n\\B：匹配非单词边界。\n\n示例：\nimport re\n \ns = &quot;Hello world\\nabc def&quot;\nprint(re.findall(r&#039;^abc&#039;, s))     # []，因为 &#039;abc&#039; 并非整个字符串开头\nprint(re.findall(r&#039;^abc&#039;, s, re.MULTILINE))  # [&#039;abc&#039;]，匹配第二行行首\nprint(re.findall(r&#039;world$&#039;, s))   # []，因为末尾有换行\nprint(re.findall(r&#039;world$&#039;, s, re.MULTILINE))  # [&#039;world&#039;]\n4. 分组（Grouping）与捕获（Capturing）／非捕获（Non-capturing）\n捕获分组\n\n使用圆括号 () 把子模式“捕获”起来，可通过 Match.group() 或 Match.groups() 获取各分组对应的匹配内容。\n分组编号是根据左括号出现的顺序，从 1 开始依次递增。\n\nimport re\n \ntext = &quot;姓名：张三， 电话：123-4567&quot;\nm = re.search(r&#039;姓名：(.+?)，\\s*电话：(\\d{3}-\\d{4})&#039;, text)\nif m:\n    print(m.group(0))   # 完整匹配：&#039;姓名：张三， 电话：123-4567&#039;\n    print(m.group(1))   # 第一个分组：&#039;张三&#039;\n    print(m.group(2))   # 第二个分组：&#039;123-4567&#039;\n    print(m.groups())   # 返回 (&#039;张三&#039;, &#039;123-4567&#039;)\n非捕获分组\n\n如果只想对子模式进行“分组”或添加量词，但不想捕获内容，可使用 (?:...)。\n这不会出现在 groups() 返回值中，也不会占用分组编号。\n\nimport re\n \n# 如果不想捕获国旗前缀“+86-”，只想提取手机号主体\nm = re.search(r&#039;(?:\\+86-)?(\\d{3}-\\d{4})&#039;, &quot;联系电话：+86-123-4567&quot;)\nprint(m.group(1))   # &#039;123-4567&#039;，没有将“+86-”作为分组返回\n命名分组\n\n使用 (?P&lt;name&gt;...) 可以对分组命名，后续可通过分组名取值，也可在正则内部使用反向引用 (?P=name)。\n\nimport re\n \ntext = &quot;用户：alice，邮箱：alice@example.com&quot;\npattern = r&#039;用户：(?P&lt;username&gt;\\w+)，邮箱：(?P&lt;email&gt;[\\w.@]+)&#039;\nm = re.search(pattern, text)\nif m:\n    print(m.group(&#039;username&#039;))   # &#039;alice&#039;\n    print(m.group(&#039;email&#039;))      # &#039;alice@example.com&#039;\n\n反向引用示例（匹配 XML/HTML 样式标签，要求开标签和闭标签名字一致）：\n\nimport re\n \ntext = &quot;&lt;div&gt;内容&lt;/div&gt; &lt;span&gt;忽略&lt;/div&gt;&quot;\npattern = r&#039;&lt;(?P&lt;tag&gt;\\w+)&gt;(.*?)&lt;/(?P=tag)&gt;&#039;\nprint(re.findall(pattern, text))  # 仅匹配 &#039;&lt;div&gt;内容&lt;/div&gt;&#039;，不匹配不对称的 &#039;&lt;/div&gt;&#039;\n5. 字符类（Character Classes）与集合\n\n\n方括号 **[]** 用于定义字符集合，匹配其中任何一个字符：\n\n\n[abc]：匹配 a、b 或 c。\n\n\n[a-z]：匹配任意小写字母。\n\n\n[A-Za-z0-9_]：等价于 \\w。\n\n\n[^0-9]：匹配任何非数字字符。\n\n\nimport re\n \nprint(re.findall(r&#039;[0-9]&#039;, &quot;a1b2c3&quot;))        # [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;]\nprint(re.findall(r&#039;[A-Za-z]+&#039;, &quot;Hello123&quot;))  # [&#039;Hello&#039;]\nprint(re.findall(rA-Za-z0-9]+&#039;, &quot;Hello, 123!&quot;))  # [&#039;, &#039;, &#039;!&#039;]\n\n\nPOSIX 风格（并非所有 &#039;re&#039; 实现都支持，但 Python 中支持）：\n\n\n[:digit:] 等价于 \\d，例如 [[:digit:]] 与 \\d 相同。不过在 Python 标准 re 中并不推荐使用 POSIX 内置字符类，直接使用 \\d、\\w 等更为常见。\n\n\n6. 模式修饰符（Flags / Modifiers）\n可以在编译正则或直接在顶级函数中通过 flags= 参数，或在模式字符串开头插入 (?iLmsux) 形式来改变匹配行为。常用选项包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n标志描述re.IGNORECASE/ re.I忽略大小写匹配re.MULTILINE/ re.M使 ^匹配行首，$匹配行尾（而不仅仅是整个字符串的首尾）re.DOTALL/ re.S使 .匹配包括换行符在内的所有字符re.VERBOSE/ re.X允许在正则里写注释并使用空白字符增强可读性（会忽略未转义的空格、换行，并可插入 #注释）re.ASCII/ re.A使 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S等只匹配 ASCII 范围内的字符re.DEBUG/ re.U调试模式，会打印正则解析过程的中间信息\n示例（多行忽略大小写匹配）：\nimport re\n \ntext = &quot;Hello\\nWorld\\nHELLO\\nworld&quot;\npattern = re.compile(r&#039;^hello&#039;, re.IGNORECASE | re.MULTILINE)\nprint(re.findall(pattern, text))  # [&#039;Hello&#039;, &#039;HELLO&#039;]\n7. 常用顶级函数\n除了通过 re.compile() 得到 Pattern 对象后调用其方法，也可以直接使用顶级函数，这些函数会自动调用缓存中预编译的模式。\n7.1 re.match(pattern, string, flags=0)\n\n从字符串开头开始匹配，如果开头不符合模式，则返回 None；否则返回一个 Match 对象。\n只匹配第一个位置，不会在其他位置搜索。\n等价于 re.compile(pattern, flags).match(string)。\n\nimport re\n \nprint(re.match(r&#039;\\d+&#039;, &quot;123abc&quot;).group())   # &#039;123&#039;\nprint(re.match(r&#039;\\d+&#039;, &quot;abc123&quot;))           # None\n7.2 re.search(pattern, string, flags=0)\n\n在整个字符串中搜索第一个符合模式的位置，找到则返回 Match 对象，否则返回 None。\n等价于 re.compile(pattern, flags).search(string)。\n\nimport re\n \nprint(re.search(r&#039;\\d+&#039;, &quot;abc123def&quot;).group())  # &#039;123&#039;\n7.3 re.findall(pattern, string, flags=0)\n\n返回字符串中所有非重叠匹配（以列表形式），如果模式包含捕获分组，则返回分组内容组成的元组列表。\n等价于：对于每次 search()，将匹配到的内容添加到列表中，直到搜索完毕。\n\nimport re\n \nprint(re.findall(r&#039;\\d+&#039;, &quot;a1b2c3&quot;))  # [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;]\n# 含分组时：\nprint(re.findall(r&#039;(\\d)([A-Za-z])&#039;, &quot;1a2b3c&quot;))  # [(&#039;1&#039;,&#039;a&#039;),(&#039;2&#039;,&#039;b&#039;),(&#039;3&#039;,&#039;c&#039;)]\n7.4 re.finditer(pattern, string, flags=0)\n\n与 findall() 类似，但返回一个迭代器，迭代器的每个元素都是一个 Match 对象，可获取更多详细信息（如起始位置、分组位置等）。\n\nimport re\n \nfor m in re.finditer(r&#039;\\d+&#039;, &quot;a1b22c333&quot;):\n    print(f&quot;{m.group()} 在位置 {m.span()}&quot;)\n# 输出：\n# 1 在位置 (1, 2)\n# 22 在位置 (3, 5)\n# 333 在位置 (5, 8)\n7.5 re.split(pattern, string, maxsplit=0, flags=0)\n\n按照能够匹配的子串将字符串切割成列表，默认不限制切割次数 (maxsplit=0 表示无上限)。\n如果模式中有捕获分组，那么这些组匹配的内容也会出现在结果列表中。\n\nimport re\n \nprint(re.split(r&#039;\\s+&#039;, &quot;Hello   world  Python&quot;))  # [&#039;Hello&#039;, &#039;world&#039;, &#039;Python&#039;]\nprint(re.split(r&#039;(\\d+)&#039;, &quot;a1b22c&quot;))  # [&#039;a&#039;, &#039;1&#039;, &#039;b&#039;, &#039;22&#039;, &#039;c&#039;]\n7.6 re.sub(pattern, repl, string, count=0, flags=0)\n\n在 string 中，将所有匹配 pattern 的子串替换为 repl，返回替换后的新字符串。\nrepl 可以是普通字符串，也可以是一个回调函数 func(match_obj)，返回要替换的内容。\ncount 参数限制最多替换次数，默认 0 表示替换所有。\n\nimport re\n \n# 用星号替换所有数字\nprint(re.sub(r&#039;\\d+&#039;, &#039;*&#039;, &quot;a1b22c3&quot;))  # &#039;a*b*c*&#039;\n \n# 使用回调函数，给所有数字加上括号\ndef wrap_digits(m):\n    return f&quot;[{m.group()}]&quot;\n \nprint(re.sub(r&#039;\\d+&#039;, wrap_digits, &quot;a1b22c3&quot;))  # &#039;a[1]b[22]c[3]&#039;\n7.7 re.subn(pattern, repl, string, count=0, flags=0)\n\n与 sub() 功能相同，但返回值为 (new_string, 替换次数) 二元组。\n\nimport re\n \nres, num = re.subn(r&#039;\\d+&#039;, &#039;#&#039;, &quot;a1b22c3&quot;)\nprint(res, num)  # &#039;a#b#c#&#039; 3\n7.8 re.escape(string)\n\n对传入字符串中所有可能被解释为正则元字符的字符自动加上反斜杠 \\，将其按字面意义进行匹配。\n常用于根据用户输入动态构建正则表达式，避免特殊字符被误解析。\n\nimport re\n \nuser_input = &quot;a.b*c+?&quot;\nescaped = re.escape(user_input)  # &#039;a\\.b\\*c\\+\\?&#039;\npattern = re.compile(escaped)\nprint(bool(pattern.search(&quot;这是 a.b*c+? 例子&quot;)))  # True\n\n四、常见实用示例\n1. 验证电子邮件地址\n一个相对简单的邮箱正则示例（并非覆盖所有情况，仅供演示）：\nimport re\n \nemail_pattern = re.compile(\n    r&#039;^[A-Za-z0-9._%+-]+@&#039;      # 用户名部分：字母、数字、点、下划线、百分号、加号、减号等\n    r&#039;(?:[A-Za-z0-9-]+\\.)+&#039;      # 域名：多个“子域.”，如 “example.”、“subdomain.”\n    r&#039;[A-Za-z]{2,}$&#039;             # 顶级域名：至少两个字母\n)\n \ntests = [&quot;alice@example.com&quot;, &quot;bob.smith@sub.dom.com&quot;, &quot;invalid@.com&quot;, &quot;name@domain.c&quot;]\nfor e in tests:\n    print(e, bool(email_pattern.match(e)))\n# 输出：\n# alice@example.com True\n# bob.smith@sub.dom.com True\n# invalid@.com False\n# name@domain.c False\n2. 提取 HTML 标签内容\n虽然不建议用正则解析复杂的 HTML，但简单场景可以：\nimport re\n \nhtml = &quot;&lt;div&gt;第一行内容&lt;/div&gt;&lt;span&gt;第二行&lt;/span&gt;&quot;\npattern = re.compile(r&#039;&lt;(\\w+)&gt;(.*?)&lt;/\\1&gt;&#039;, re.DOTALL)  \n# (\\w+) 捕获标签名，\\1 反向引用，(.*?) 非贪婪匹配内容，DOTALL 让 . 匹配换行\n \nfor m in pattern.finditer(html):\n    tag, content = m.group(1), m.group(2)\n    print(tag, &quot;=&gt;&quot;, content)\n# 输出：\n# div =&gt; 第一行内容\n# span =&gt; 第二行\n3. 将文本按多个分隔符切分\n假设要将字符串按逗号、分号、空格等多种分隔符切分：\nimport re\n \ntext = &quot;apple,pear;banana grape\\torange&quot;\nparts = re.split(r&#039;[,\\s;]+&#039;, text)\nprint(parts)  # [&#039;apple&#039;, &#039;pear&#039;, &#039;banana&#039;, &#039;grape&#039;, &#039;orange&#039;]\n4. 验证手机号（示例：国内 11 位手机号）\nimport re\n \nphone_pattern = re.compile(r&#039;^1[3-9]\\d{9}$&#039;)\ntests = [&quot;13812345678&quot;, &quot;12345678901&quot;, &quot;159abc67890&quot;]\nfor p in tests:\n    print(p, bool(phone_pattern.match(p)))\n# 输出：\n# 13812345678 True\n# 12345678901 False\n# 159abc67890 False\n5. 替换文本中特定关键词\n将文本中的敏感词（如“色情”、“赌博”）替换为“***”：\nimport re\n \ntext = &quot;请不要参与赌博或传播色情内容。&quot;\npattern = re.compile(r&#039;赌博|色情&#039;)\ncleaned = pattern.sub(&quot;***&quot;, text)\nprint(cleaned)  # &#039;请不要参与***或传播***内容。&#039;\n\n五、进阶技巧\n1. 使用 (?P&lt;name&gt;...) 与 (?P=name) 处理嵌套与反向引用\n\n命名分组结合反向引用可用于匹配成对出现的内容，如括号、引号等。\n示例：匹配同时成对的单引号或双引号字符串内容。\n\nimport re\n \ntext = &quot;他说：&#039;这是单引号&#039;，她说：\\&quot;这是双引号\\&quot;，还有 &#039;不闭合 但不匹配&quot;\npattern = re.compile(r&#039;(?P&lt;quote&gt;[&quot;\\&#039;])(.*?)\\1&#039;)  \n# (?P&lt;quote&gt;[&quot;\\&#039;])：捕获一个引号（单或双），命名为 quote；\\1 代表与之相同的引号\nfor m in pattern.finditer(text):\n    print(&quot;引号类型：&quot;, m.group(&#039;quote&#039;), &quot;内容：&quot;, m.group(2))\n# 输出：\n# 引号类型： &#039; 内容： 这是单引号\n# 引号类型： &quot; 内容： 这是双引号\n2. 零宽断言（Lookahead / Lookbehind）\n零宽断言用于在不消耗字符的前提下，检查某位置前后是否满足某种条件。分为前瞻（lookahead）和后顾（lookbehind）两类。\n前瞻（Lookahead）\n\n(?=...)：正向前瞻——当前位置后面必须匹配 ... 才算成功，但不消耗字符。\n(?!...)：负向前瞻——当前位置后面不能匹配 ...。\n\n示例：匹配后面跟着“USD”的数字，但不包含“USD”：\nimport re\n \ntext = &quot;100USD or 200 EUR, 300USD&quot;\npattern = re.compile(r&#039;\\d+(?=USD)&#039;)\nprint(re.findall(pattern, text))  # [&#039;100&#039;, &#039;300&#039;]\n后顾（Lookbehind）\n\n(?&lt;=...)：正向后顾——当前位置前面必须匹配 ...，但不消耗字符。\n(?&lt;!...)：负向后顾——当前位置前面不能匹配 ...。\n\n示例：匹配以“USD”结尾且前面有数字的金额（只取数字部分）：\nimport re\n \ntext = &quot;100USD or 200 EUR, 300USD&quot;\npattern = re.compile(r&#039;(?&lt;=USD)\\d+&#039;)   # 这其实倒过来，不符合常见需求；更常见的是：(?&lt;= )\\d+(?=USD)\n# 更常见：匹配前面是数字，后面跟着 USD 的数字\npattern = re.compile(r&#039;(?&lt;=\\b)\\d+(?=USD)&#039;)\nprint(re.findall(pattern, text))  # [&#039;100&#039;, &#039;300&#039;]\n后顾断言要注意：在 Python 正则中，后顾断言的子模式长度必须固定（即无法写可变长度的后顾，如 (?&lt;=\\d+) 会报错）。\n3. 使用 re.VERBOSE（re.X）增强可读性\n在复杂模式中，可借助此标志插入空格或注释，使表达式更易维护。例如：\nimport re\n \n# 匹配 IPv4 地址\nipv4_pattern = re.compile(r&#039;&#039;&#039;\n    ^\n    (?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)   # 第一段：0-255\n    \\.\n    (?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)   # 第二段\n    \\.\n    (?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)   # 第三段\n    \\.\n    (?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)   # 第四段\n    $\n&#039;&#039;&#039;, re.VERBOSE)\n \ntests = [&quot;192.168.0.1&quot;, &quot;255.255.255.255&quot;, &quot;256.100.0.1&quot;]\nfor ip in tests:\n    print(ip, bool(ipv4_pattern.match(ip)))\n# 输出：\n# 192.168.0.1 True\n# 255.255.255.255 True\n# 256.100.0.1 False\n在 re.VERBOSE 模式下，正则内部的空白（非转义的空格、换行）会被忽略，# 后的内容到行末算注释。\n4. 预编译与缓存策略\n\n在需要频繁多次使用同一模式进行匹配时，显式调用 re.compile() 并复用返回的 Pattern 对象，可以明显减少自动编译带来的开销。\n顶级函数如 re.search()、re.match() 会隐式调用编译并缓存，可用于少量简单场景，但不建议在极端性能敏感的循环中反复使用同字符串模式的顶级函数。\n\n\n六、性能与注意事项\n\n回溯与效率\n\n\n设计不当的正则可能导致“回溯爆炸（catastrophic backtracking）”，即在大量文本上递归尝试不同匹配分支时耗费巨大时间，甚至造成程序假死。\n常见导致回溯爆炸的模式有：嵌套的多种重复（如 (a+)+、(.*)(.*)）等。\n避免过度依赖“贪婪”量词，必要时可使用非贪婪（?）或限定范围的量词（如 {m,n}）。\n\n\n精确性与可维护性\n\n\n正则表达式一旦变得冗长复杂，可读性会显著下降，可考虑拆分为多个子表达式，或者写成多行并使用 re.VERBOSE。\n对于非常结构化或复杂的文本（如 HTML、XML、JSON 等），尽量使用专门的解析库（如 BeautifulSoup、ElementTree、json 模块）而不是正则，以提高可靠性。\n\n\n字符编码与 Unicode\n\n\nPython 3 默认使用 Unicode 字符串，正则 \\w、\\d、\\s 等在默认状态下已经支持 Unicode 类别，如果想限制为 ASCII，则可加 re.ASCII 标志。\n在处理多字节语言（如中文、日文、韩文）时，注意字符范围是否包含在自定义的字符类（如 [a-z] 只能匹配 ASCII，而不能匹配中文）。\n\n\n线程安全\n\n\nre 缓存机制是线程安全的，但如果在多线程中大量编译/反复正则，建议显式编译并在各线程内复用 Pattern 对象，以减少锁竞争。\n\n\n替代方案与第三方库\n\n\n标准库的 re 在大多数场景下足够使用，但如果需要更高级的 Unicode 支持（如递归模式、条件模式分支、子例程调用等）可考虑第三方库 regex（PyPI 包名 regex），其功能更丰富，性能相近。\n\n\n七、常见问题与实用技巧\n1. 如何在正则里匹配中文字符？\n\n可以使用 Unicode 范围：[\\u4e00-\\u9fa5]（仅限常用汉字区段），也可以直接使用 \\w（但 \\w 同时匹配字母、数字、下划线等）或显式罗列。\n示例：匹配由 2～4 个汉字组成的人名：\n\nimport re\n \nname_pattern = re.compile(r&#039;^[\\u4e00-\\u9fa5]{2,4}$&#039;)\nfor n in [&quot;张三&quot;, &quot;李小龙&quot;, &quot;王&quot;, &quot;王小二&quot;]:\n    print(n, bool(name_pattern.match(n)))\n# 输出：\n# 张三 True\n# 李小龙 True\n# 王 False\n# 王小二 True\n2. 在多行字符串中提取所有符合特定模式的行\n\n若想对每一行分别进行匹配，可结合 re.MULTILINE 标志和 ^...$ 锚点。\n示例：从日志中提取所有包含 “ERROR” 的行：\n\nimport re\n \nlog = &quot;&quot;&quot;INFO Starting service\nDEBUG Initialized\nERROR Connection failed\nINFO Retrying\nERROR Timeout\n&quot;&quot;&quot;\nerrors = re.findall(r&#039;^ERROR.*$&#039;, log, re.MULTILINE)\nprint(errors)  # [&#039;ERROR Connection failed&#039;, &#039;ERROR Timeout&#039;]\n3. 匹配浮点数、整数、科学计数法\n可使用如下示例模式匹配多种数字格式：\nimport re\n \nnumber_pattern = re.compile(\n    r&#039;&#039;&#039;\n    [-+]?                   # 可选符号\n    (?:\\d+\\.\\d*|\\.\\d+|\\d+)  # 匹配浮点或整数： 123.45 | .67 | 89\n    (?:[eE][-+]?\\d+)?       # 可选科学计数法部分： e-10、E+5 等\n    &#039;&#039;&#039;, re.VERBOSE)\n \ntests = [&quot;123&quot;, &quot;-123.45&quot;, &quot;.678&quot;, &quot;+0.5e-10&quot;, &quot;3E+8&quot;, &quot;abc&quot;, &quot;12.3.4&quot;]\nfor x in tests:\n    print(x, bool(number_pattern.fullmatch(x)))\n# 输出：\n# 123 True\n# -123.45 True\n# .678 True\n# +0.5e-10 True\n# 3E+8 True\n# abc False\n# 12.3.4 False\n4. 替换时使用函数动态生成结果\n\n有时替换内容依赖于匹配结果自身，可在 re.sub() 中传入回调函数。示例：将文本中的所有数字加 1 后再替换回去。\n\nimport re\n \ndef add_one(m):\n    val = int(m.group())\n    return str(val + 1)\n \ntext = &quot;a=1, b=42, c=100&quot;\nresult = re.sub(r&#039;\\d+&#039;, add_one, text)\nprint(result)  # &#039;a=2, b=43, c=101&#039;\n5. 使用原始字符串（Raw String）避免多重转义\n\n在 Python 中，正则字符串往往会包含大量的反斜杠 \\。为了避免 Python 先对反斜杠进行转义，习惯上将正则模式写成原始字符串（以 r&#039;...&#039; 或 r&quot;...&quot;），这样可以直接把 \\n、\\t 等保留给正则引擎解释，而不被 Python 字面值处理。\n例如，要匹配一个反斜杠 \\ 本身，则可以写成 r&#039;\\\\&#039;；如果不加 r 前缀，就需要写成 &#039;\\\\\\\\&#039;。\n\n\n八、总结\n\n核心对象\n\n\nPattern：通过 re.compile(pattern, flags) 构造，提供匹配、搜索、替换、切分等多种方法。\nMatch：匹配成功时返回，通过 group()、span()、groups() 等方法获取匹配信息。\n\n\n常用顶级函数\n\n\nre.match()：从字符串开头匹配。\nre.search()：在字符串任意位置寻找第一个符合的子串。\nre.findall()：返回所有符合的子串（列表形式）。\nre.finditer()：返回所有符合的子串（迭代器形式，元素为 Match 对象）。\nre.split()：按照匹配内容切分字符串。\nre.sub() / re.subn()：替换所有匹配子串。\n\n\n语法要点\n\n\n熟练使用量词（*, +, ?, {m,n}）控制重复。\n掌握贪婪与非贪婪量词（.* vs .*?）的区别。\n了解锚点（^, $, \\b）及其在多行模式下的变化。\n掌握分组与捕获（()、(?:...)、(?P&lt;name&gt;...)）以及反向引用。\n运用零宽断言（(?=...), (?&lt;=...), (?!...), (?&lt;!...)）实现复杂位置判断。\n\n\n进阶与优化\n\n\n使用 re.VERBOSE 提高可读性；用 re.IGNORECASE、re.MULTILINE、re.DOTALL 等标志灵活控制匹配行为。\n避免复杂的回溯模式，防止“回溯爆炸”，保持表达式简洁明了。\n在高频匹配场景下显式编译正则并复用 Pattern 对象，以减少编译开销。\n"},"python/2.常用库与工具/标准库与内置模块/数据处理/sqlite3":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/sqlite3","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/sqlite3.md","title":"sqlite3","links":[],"tags":[],"content":"一、模块概述\n\n什么是 **sqlite3** 模块\n\n\nsqlite3 是 Python 标准库内置的、用于与 SQLite 数据库交互的模块。它实现了 DB-API 2.0（PEP 249）接口规范，允许你在 Python 程序中通过纯 SQL 语句对 SQLite 数据库文件进行增删改查操作。\nSQLite 是轻量级的嵌入式关系型数据库，其数据库引擎以单个文件的形式直接嵌入到应用程序中，无需独立的服务器进程。Python 通过 sqlite3 模块直接调用 SQLite C 库，实现零配置、本地存储的数据库功能。\n\n\n模块特点与优点\n\n\n零依赖、开箱即用：只要安装了 Python，就能够直接导入并使用 import sqlite3。\n文件即数据库：一个 .db 文件即可存储整个数据库，不需要额外部署数据库服务器。\n支持事务：默认开启自动提交（autocommit=false），可以通过 commit() 和 rollback() 进行事务管理。\n跨平台：同一个 .db 文件可以在 Windows、macOS、Linux 等平台间自由拷贝和使用。\n丰富的功能：支持大多数常用的 SQL 标准（DDL、DML、事务、索引、视图、触发器等），并暴露了 SQLite 特有的 PRAGMA、全文检索（FTS）、触发器等扩展功能。\n\n\n模块主要对象\n\n\nsqlite3.Connection：数据库连接对象，代表对某个 SQLite 数据库文件（或内存）的一次会话。\nsqlite3.Cursor：游标对象，用于在连接上执行 SQL 语句、获取查询结果、控制结果集迭代。\nsqlite3.Row：行工厂类，用于让查询结果以字典或类似方式访问。\n以及一系列异常类，如 sqlite3.Error、sqlite3.OperationalError、sqlite3.IntegrityError 等，用于捕获不同类型的数据库错误。\n\n\n何时使用 **sqlite3**\n\n\n小型应用或本地存储：如桌面应用、单用户 Web 应用、临时开发、原型系统、教育/学习场景等。\n测试与调试：可快速创建一个干净的数据库环境，用于单元测试或功能验证。\n嵌入式设备：无需运维数据库服务器，直接把 .db 文件打包到设备中。\n小到中等并发量：SQLite 适合单机、低并发场景；如果项目需要高并发、分布式部署，则应考虑 MySQL、PostgreSQL 等服务器型数据库。\n\n\n二、连接到数据库\n1. 打开（或创建）一个数据库\nimport sqlite3\n \n# 1) 连接到一个本地文件（如果文件不存在会自动创建）\nconn = sqlite3.connect(&#039;example.db&#039;)\n \n# 2) 使用内存数据库（进程结束后数据库消失）\nmem_conn = sqlite3.connect(&#039;:memory:&#039;)\n \n# 3) 配置超时时间、检查多线程访问\nconn2 = sqlite3.connect(\n    &#039;example2.db&#039;,\n    timeout=10,        # 当数据库被锁时，最多等待 10 秒\n    check_same_thread=False  # 允许跨线程使用同一个连接（需自行保证线程安全）\n)\n\n\n**sqlite3.connect(database, timeout=5.0, detect_types=0, isolation_level=&#039;DEFERRED&#039;, check_same_thread=True, factory=Connection, cached_statements=128, uri=False)**\n\n\ndatabase：数据库文件路径，若为 &#039;:memory:&#039; 则创建一个内存数据库；也可以使用 URI 方式（如 &#039;file:my.db#039;，需 uri=True）。\n\n\ntimeout：在数据库文件被锁定时，等待锁释放的最长时间，单位秒；在高并发写入时可适当调大此值。\n\n\ndetect_types：用于启用 SQLite 类型检测与转换，常与 PARSE_DECLTYPES、PARSE_COLNAMES 一起使用，详见下文“数据类型与转换”。\n\n\nisolation_level：事务隔离级别，默认为 &#039;DEFERRED&#039;（延迟开始）；可设置为 &#039;IMMEDIATE&#039;、&#039;EXCLUSIVE&#039; 或 None（自动提交模式）。\n\n\ncheck_same_thread：默认值 True，意味着同一个连接只能在创建它的线程中使用；若设置为 False，可跨线程共享连接，需要自行保证线程安全。\n\n\nfactory：指定一个 Connection 子类以自定义连接行为；一般无需修改。\n\n\ncached_statements：SQLite 语句缓存数量，可适当增大以提升性能。\n\n\nuri：若为 True，database 参数会被当作 URI 解析；可指定只读、共享内存等高级选项。\n\n\n要点提示\n\n内存数据库（**&#039;:memory:&#039;**）适用于临时数据、测试用例。\n默认情况下，一个连接只能在创建它的线程中使用（check_same_thread=True）。如果在多线程环境下共享连接，要将其设为 False，但要注意加锁保护。\nSQLite 单文件同时只能有一个写锁，当其他线程/进程进行写操作时会进行等待，直到当前写事务提交或回滚。可以通过调整 timeout 缩短或延长等待时间。\n\n2. 连接属性与方法\n\nconn.cursor()：创建并返回一个游标（Cursor）对象，用于执行 SQL 语句与获取结果。\nconn.commit()：提交当前事务，将所有未提交的写操作同步到数据库文件。\nconn.rollback()：回滚当前事务，撤销自上次 commit() 以来的所有更改。\nconn.close()：关闭连接，释放资源；若还有未提交的事务，会自动回滚。\nconn.execute(sql, parameters)：以最简方式执行 SQL 并返回一个 Cursor 对象；等价于 cursor = conn.cursor(); cursor.execute(sql, parameters)。\nconn.executemany(sql, seq_of_parameters)：批量执行相同 SQL 但不同参数；等价于循环调用 execute。\nconn.executescript(script)：一次执行多条 SQL 语句（不支持参数绑定），通常用于初始化表、创建索引、插入多行等场景。\n\n# 示例：基本连接与关闭\nimport sqlite3\n \nconn = sqlite3.connect(&#039;mydb.db&#039;)\nprint(type(conn))  # &lt;class &#039;sqlite3.Connection&#039;&gt;\n \n# 快捷执行\ncursor = conn.execute(&#039;SELECT sqlite_version()&#039;)\nversion = cursor.fetchone()[0]\nprint(&#039;SQLite version:&#039;, version)\n \nconn.commit()   # 如果有写操作，需要手动提交\nconn.close()\n要点提示\n\nconn.execute(...) 返回的游标可以直接使用 fetchone()、fetchall() 获取结果，也可以 for row in conn.execute(...) 迭代。\n每次对数据库做写操作（INSERT/UPDATE/DELETE/CREATE/DROP 等）都需要显式 **commit()**，否则在连接关闭时会自动回滚。\n使用 executescript 时，SQL 语句之间用分号分隔；此方法不支持参数占位。\n\n\n三、游标（Cursor）与执行 SQL\n1. 创建与使用游标\nimport sqlite3\n \nconn = sqlite3.connect(&#039;example.db&#039;)\ncursor = conn.cursor()  # 创建一个游标实例\n \n# 执行一条 CREATE TABLE 语句\ncursor.execute(&#039;&#039;&#039;\n    CREATE TABLE IF NOT EXISTS users (\n        id      INTEGER PRIMARY KEY AUTOINCREMENT,\n        username TEXT NOT NULL UNIQUE,\n        age     INTEGER,\n        email   TEXT\n    )\n&#039;&#039;&#039;)\n \n# 插入一条记录（写操作）\ncursor.execute(\n    &#039;INSERT INTO users (username, age, email) VALUES (?, ?, ?)&#039;,\n    (&#039;alice&#039;, 30, &#039;alice@example.com&#039;)\n)\n \n# 查询所有记录\ncursor.execute(&#039;SELECT id, username, age, email FROM users&#039;)\nall_rows = cursor.fetchall()  # 获取所有结果，返回列表，每项是元组\nprint(all_rows)\n \n# 记得提交事务\nconn.commit()\ncursor.close()\nconn.close()\n\n\n常用方法\n\n\ncursor.execute(sql, parameters=())：执行单条 SQL，使用参数绑定替代字符串拼接，防止 SQL 注入。\n\n\ncursor.executemany(sql, seq_of_parameters)：批量执行相同 SQL，参数为可迭代对象（如列表）中的多组参数。\n\n\ncursor.executescript(script)：一次执行包含多条 SQL 的脚本，不支持参数绑定。\n\n\ncursor.fetchone()：获取一行查询结果，若无更多行则返回 None。\n\n\ncursor.fetchmany(size=N)：获取 size 条结果，返回列表；若剩余行数少于 size，则返回剩余行。\n\n\ncursor.fetchall()：获取所有剩余查询结果，返回列表。\n\n\n迭代游标：可以直接写 for row in cursor: 或 for row in conn.execute(...): 进行行级别迭代。\n\n\n要点提示\n\n调用 **fetchall()** 时会一次性把结果加载到内存，若查询结果非常大，可能会导致内存压力；可使用 fetchone() 或 fetchmany() 做分批处理。\n在执行写操作（INSERT/UPDATE/DELETE）后一定要调用 **conn.commit()**，否则这些更改不会保存。\n参数绑定：在 SQL 语句中使用问号占位符（?），或命名占位符（:name 或 @name），将参数作为第二个参数传入 execute，可自动适配并防止注入。\n\n2. 参数绑定方式\n\n位置参数（qmark style）\n\ncursor.execute(\n    &#039;INSERT INTO users (username, age) VALUES (?, ?)&#039;,\n    (&#039;bob&#039;, 25)\n)\n\n命名参数（named style）\n\ncursor.execute(\n    &#039;INSERT INTO users (username, age) VALUES (:uname, :uage)&#039;,\n    {&#039;uname&#039;: &#039;carol&#039;, &#039;uage&#039;: 28}\n)\n\n数字参数（numeric style）\n\ncursor.execute(\n    &#039;INSERT INTO users (username, age) VALUES (?1, ?2)&#039;,\n    (&#039;dave&#039;, 22)\n)\n要点提示\n\n切勿使用字符串格式化（**%**、**str.format()**、f-string 等）拼接 SQL，会导致严重的 SQL 注入风险。\n在批量插入时，尽量使用 executemany，效率比在循环里单次 execute 更高。\n\n3. 批量操作：executemany\nusers_to_add = [\n    (&#039;eve&#039;, 35, &#039;eve@example.com&#039;),\n    (&#039;frank&#039;, 40, &#039;frank@example.com&#039;),\n    (&#039;grace&#039;, 27, &#039;grace@example.com&#039;),\n]\n \ncursor.executemany(\n    &#039;INSERT INTO users (username, age, email) VALUES (?, ?, ?)&#039;,\n    users_to_add\n)\nconn.commit()\n\n原理：executemany 会将同一条 SQL 与多组参数组合，内部会循环执行多次 execute，但是它会尽可能地在 C 层进行参数绑定，提升性能。\n注意：如果列表非常大，也会一次性将所有 SQL 执行完；如果担心事务过于庞大无法回滚或内存压力，可手动分批执行，比如每 1000 条提交一次。\n\n4. 同时执行多条语句：executescript\nscript = &quot;&quot;&quot;\n    PRAGMA foreign_keys = ON;\n    CREATE TABLE IF NOT EXISTS departments (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL UNIQUE\n    );\n    CREATE TABLE IF NOT EXISTS employees (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        dept_id INTEGER,\n        FOREIGN KEY(dept_id) REFERENCES departments(id)\n    );\n&quot;&quot;&quot;\n \nconn.executescript(script)\nconn.commit()\n\n\n**executescript(script_string)**\n\n\n参数是一个包含多条以分号 ; 分隔的 SQL 语句的字符串。\n\n\n内部会按分号分割并依次执行，不支持参数绑定。\n\n\n适合一次性创建多张表、添加多条记录、设置多个 PRAGMA 等场景。\n\n\n要点提示\n\n**executescript** 不支持参数占位，若需要以变量创建表名或字段名，必须手动拼接字符串并自行保证安全，但一般不建议动态生成表结构。\n通常将数据库初始化脚本（DDL）放到多行字符串里，通过 executescript 一次运行，逻辑更清晰。\n\n\n四、事务与上下文管理\n1. 自动提交与手动提交\n\n默认情况下，sqlite3 连接是在 事务模式（autocommit=False）。这意味着在执行任何写操作（INSERT、UPDATE、DELETE、CREATE、DROP 等）时，必须显式调用 conn.commit()，否则在连接关闭时会自动回滚所有更改。\n若希望进入自动提交模式，可将 isolation_level=None 作为 connect() 参数。此时对数据库的每条写操作都会立即提交。\n\n# 自动提交模式\nconn = sqlite3.connect(&#039;auto.db&#039;, isolation_level=None)\ncursor = conn.cursor()\ncursor.execute(&quot;INSERT INTO users (username) VALUES (&#039;tina&#039;)&quot;)  # 自动提交\n\n常见事务控制\n\nconn = sqlite3.connect(&#039;example.db&#039;)\ncursor = conn.cursor()\n \ntry:\n    cursor.execute(&quot;BEGIN&quot;)      # 开始一个显式事务（与 isolation_level=None 的自动提交相反）\n    cursor.execute(&quot;UPDATE accounts SET balance = balance - 100 WHERE id = ?&quot;, (1,))\n    cursor.execute(&quot;UPDATE accounts SET balance = balance + 100 WHERE id = ?&quot;, (2,))\n    conn.commit()                # 提交\nexcept Exception as e:\n    conn.rollback()              # 出错回滚\n    raise\nfinally:\n    cursor.close()\n    conn.close()\n要点提示\n\n在 Python 3.6+ 中，若你使用 **with conn:** 上下文管理，离开 **with** 块时会自动根据是否发生异常进行提交或回滚。\n事务粒度：默认为 DEFERRED，即第一次执行 DML（写操作）时才真正加锁；也可以显式 BEGIN IMMEDIATE（在事务开始时加写锁）、BEGIN EXCLUSIVE（加独占锁），适用于并发控制。\n\n2. 使用上下文管理（with）\nimport sqlite3\n \n# 方式一：针对 Connection 使用 with，自动 commit/rollback\nwith sqlite3.connect(&#039;example.db&#039;) as conn:\n    cursor = conn.cursor()\n    cursor.execute(&#039;INSERT INTO users (username) VALUES (?)&#039;, (&#039;uma&#039;,))\n    # 若此处没有异常，离开 with 块时会自动 conn.commit()\n    # 若出现异常，离开 with 块时会自动 conn.rollback()\n \n# 方式二：针对 Cursor 也可使用 with（在 Python 3.7+ 支持）\nwith sqlite3.connect(&#039;example.db&#039;) as conn:\n    with conn.cursor() as cursor:\n        cursor.execute(&#039;DELETE FROM users WHERE username = ?&#039;, (&#039;unknown&#039;,))\n\n\n行为说明\n\n\nwith sqlite3.connect(...) as conn: 相当于在 __enter__ 时返回 conn，在正常退出时调用 conn.commit()，在发生异常时调用 conn.rollback() 并将异常向外抛出。\n\n\n在 Python 3.7+，Cursor 也支持上下文管理，可以在 with conn.cursor() as cursor: 结束后自动 cursor.close()。\n\n\n要点提示\n\n推荐使用 **with** 来管理连接和游标，可以减少漏写 commit 或漏 close 导致的资源泄漏与事务未提交问题。\n对于多次写操作应放在同一个 with 块中，确保它们在同一事务内要么全部成功、要么全部回滚。\n\n\n五、行工厂（Row Factory）与结果处理\n默认情况下，Cursor 返回的每一行是一个元组（tuple），列的顺序与查询语句中的 SELECT 列顺序一致。如果想要更方便地通过列名访问结果，则可以使用行工厂。\n1. 使用内置的 sqlite3.Row\nimport sqlite3\n \nconn = sqlite3.connect(&#039;example.db&#039;)\n# 将 row_factory 设置为 sqlite3.Row，之后 cursor.fetchall() 返回的每行是 sqlite3.Row 对象\nconn.row_factory = sqlite3.Row  \ncursor = conn.cursor()\n \ncursor.execute(&#039;SELECT id, username, age FROM users WHERE age &gt; ?&#039;, (20,))\nrows = cursor.fetchall()\n \nfor row in rows:\n    # row[&#039;username&#039;] 或 row[&#039;age&#039;] 等都可以\n    print(f&quot;User {row[&#039;id&#039;]}: {row[&#039;username&#039;]} (age={row[&#039;age&#039;]})&quot;)\n\n\n**sqlite3.Row** 特点\n\n\n继承自 tuple，既可以像元组一样使用索引访问，也可以像字典一样通过列名访问。\n\n\nrow.keys() 可以获取列名列表；list(row) 则是值列表。\n\n\n要点提示\n\n在连接级别设置 **row_factory** 后，该设置对该连接的所有游标均有效。\nsqlite3.Row 在小结果集下性能足够，但若对数千行做高频访问，访问字典键会略慢于元组访问。\n\n2. 自定义行工厂\n如果希望将查询结果放到自定义的 Python 对象、命名元组（collections.namedtuple）或字典中，也可自定义 row_factory 函数/类。\n2.1 命名元组示例\nimport sqlite3\nfrom collections import namedtuple\n \ndef namedtuple_factory(cursor, row):\n    # 根据 cursor.description 中的列名动态创建 namedtuple 类型\n    fields = [column[0] for column in cursor.description]\n    RowClass = namedtuple(&#039;Row&#039;, fields)\n    return RowClass(*row)\n \nconn = sqlite3.connect(&#039;example.db&#039;)\nconn.row_factory = namedtuple_factory\ncursor = conn.cursor()\n \ncursor.execute(&#039;SELECT id, username, age FROM users&#039;)\nfor row in cursor.fetchall():\n    # 现在 row.id、row.username、row.age 都可以直接访问\n    print(f&quot;{row.id}: {row.username} is {row.age} years old&quot;)\n2.2 字典示例\nimport sqlite3\n \ndef dict_factory(cursor, row):\n    d = {}\n    for idx, col in enumerate(cursor.description):\n        d[col[0]] = row[idx]\n    return d\n \nconn = sqlite3.connect(&#039;example.db&#039;)\nconn.row_factory = dict_factory\ncursor = conn.cursor()\n \ncursor.execute(&#039;SELECT id, username, age FROM users&#039;)\nfor row in cursor.fetchall():\n    # 现在 row[&#039;username&#039;]、row[&#039;age&#039;] 访问更直观\n    print(row[&#039;id&#039;], row[&#039;username&#039;], row[&#039;age&#039;])\n要点提示\n\n自定义 **row_factory** 会在每次 **fetch*()** 时调用，若对每行动态生成类会有额外开销。如果结果集较大，建议创建一次命名元组类型后复用，而非每行都动态创建。\n如果只需偶尔通过列名访问，可将 **cursor.description** 缓存下来，然后用索引访问元组。例如：\n\ncursor.execute(&#039;SELECT * FROM users&#039;)\ncolumns = [col[0] for col in cursor.description]\nfor row in cursor.fetchall():\n    user = dict(zip(columns, row))\n    # ...\n\n六、数据类型与转换\nSQLite 本质上是弱类型（动态类型）的数据库，引擎在内部对“类型”采用“类型亲和性（type affinity）”而非严格的列类型约束。sqlite3 模块会把 SQLite 中的数据类型映射到相应的 Python 类型，但为了更精确地处理某些类型，可借助 detect_types、PARSE_DECLTYPES、PARSE_COLNAMES、自定义适配器与转换器等手段。\n1. SQLite 的类型亲和性简介\n\nSQLite 列在创建表时可以指定类型名称，例如 INTEGER、TEXT、BLOB、REAL、NUMERIC 等，但 SQLite 并不会对插入数据做严格的类型检查，而是根据以下规则决定存储类型：\n\n\n如果列声明中包含 “INT”，亲和力为 INTEGER。\n如果包含 “CHAR”、“CLOB” 或 “TEXT”，亲和力为 TEXT。\n如果包含 “BLOB” 或声明为空，则亲和力为 BLOB。\n如果包含 “REAL”、“FLOA” 或 “DOUB”，亲和力为 REAL。\n否则，亲和力为 NUMERIC。\n\n\n插入时，SQLite 会尝试将值转换到列的亲和类型，如果转换失败，则按原始类型存储。例如，如果往 INTEGER 列插入 &#039;123&#039;（字符串），则自动转换为整数 123；若插入 &#039;abc&#039;，则保留文本 &#039;abc&#039;。\n\n2. Python 与 SQLite 类型映射\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSQLite 存储类型对应 Python 类型备注NULLNoneType(None)INTEGERint64 位有符号整数REALfloatIEEE 浮点数TEXTstrPython 字符串（Unicode）BLOBbytesPython 原始字节序列\n\n在大多数场景下，直接插入上述类型时，无需关注额外转换，模块会自动映射。例如：\n\ncursor.execute(&quot;INSERT INTO ttext (content) VALUES (?)&quot;, (&quot;你好，世界&quot;,))\ncursor.execute(&quot;INSERT INTO tblob (data) VALUES (?)&quot;, (b&#039;\\x00\\x01\\x02&#039;,))\n要点提示\n\n如果对数据类型有更严格的需求，可在表定义时指定合适的列类型，但 SQLite 不会强制执行，主要用于亲和力提示。\n对于 **NUMERIC** 亲和列，可以插入 **decimal.Decimal**，但 SQLite 内部会先转换为文本或浮点，因此若要在 Python 中精确还原成 **Decimal**，需要自定义转换器。\n\n3. detect_types、PARSE_DECLTYPES 与 PARSE_COLNAMES\n\n\n**detect_types** 参数：在调用 connect() 时，可指定为以下任意组合：\n\n\nsqlite3.PARSE_DECLTYPES：根据列在创建表时声明的类型来转换结果。例如，如果表定义为 created_at TIMESTAMP，则查询时 Python 可以将该列自动转换成 datetime.datetime（前提是注册了相应的转换器）。\n\n\nsqlite3.PARSE_COLNAMES：根据查询时 SELECT 子句中为列起的别名（alias）来判断类型。例如：\n\n\nSELECT created AS &quot;created [timestamp]&quot; FROM events;\n如果在别名中指定了 [timestamp]，则可让 Python 按照 timestamp 类型进行转换。\n\n示例：自动转换 **datetime**\n\n\n创建表时声明列类型：\n\nCREATE TABLE events (\n    id INTEGER PRIMARY KEY,\n    name TEXT,\n    created TIMESTAMP\n);\n\n在 Python 中连接时启用 PARSE_DECLTYPES：\n\nimport sqlite3\nimport datetime\n \n# 先注册 datetime 转换器\nsqlite3.register_adapter(datetime.datetime, lambda val: val.isoformat(&#039; &#039;))\nsqlite3.register_converter(&quot;timestamp&quot;, lambda val: datetime.datetime.fromisoformat(val.decode()))\n \n# 连接并启用类型检测\nconn = sqlite3.connect(\n    &#039;events.db&#039;,\n    detect_types=sqlite3.PARSE_DECLTYPES\n)\ncursor = conn.cursor()\n \n# 插入 datetime 对象，适配器会将其转换为 ISO 格式字符串\nnow = datetime.datetime.now()\ncursor.execute(\n    &#039;INSERT INTO events (name, created) VALUES (?, ?)&#039;,\n    (&#039;Test Event&#039;, now)\n)\nconn.commit()\n \n# 查询时，“created”列会自动恢复为 datetime 对象（因声明类型为 TIMESTAMP 并注册了转换器）\ncursor.execute(&#039;SELECT id, name, created FROM events&#039;)\nrow = cursor.fetchone()\nprint(type(row[&#039;created&#039;]), row[&#039;created&#039;])  # &lt;class &#039;datetime.datetime&#039;&gt; 2025-06-02 12:34:56.789\n\n示例中关键点：\n\n\n先用 register_adapter(datetime.datetime, adapter_func) 将 datetime → 可存储类型（如字符串）的转换逻辑注册给模块。\n再用 register_converter(&quot;timestamp&quot;, converter_func) 将数据库中类型名字 &quot;timestamp&quot; 对应的字节值转换回 Python 对象。\n在 connect() 时加上 detect_types=sqlite3.PARSE_DECLTYPES，让模块根据表声明的列类型来启用转换器。\n\n要点提示\n\n**PARSE_DECLTYPES**：根据表创建时为列指定的类型名称（不区分大小写）来决定是否调用相应的转换函数。\n**PARSE_COLNAMES**：根据 **SELECT ... AS &quot;colname [typename]&quot;** 中的 **typename** 来决定是否调用转换函数。\n对于多种自定义类型，都可以先调用 **sqlite3.register_adapter** 和 **sqlite3.register_converter** 注册后，再配合 **detect_types** 进行自定义序列化。\n\n\n七、自定义适配器（Adapter）与转换器（Converter）\n当你想让 SQLite 自动存储并还原某些 Python 原生类型（如 datetime.date、decimal.Decimal、uuid.UUID、自定义对象等），可以使用 sqlite3.register_adapter() 和 sqlite3.register_converter() 注册对应逻辑。\n1. register_adapter\n\n\n用法：sqlite3.register_adapter(py_type, adapter_func)\n\n\npy_type：需要适配的 Python 类型（class）。\n\n\nadapter_func(value)：将 value 转换为 SQLite 可存储的类型（通常是 bytes 或 str），返回转换后的值。\n\n\nimport sqlite3\nimport uuid\n \n# 1. 定义如何把 uuid.UUID 转成可存储类型（字符串）\ndef adapt_uuid(u):\n    return u.hex  # 或 str(u)\n \n# 2. 注册\nsqlite3.register_adapter(uuid.UUID, adapt_uuid)\n\n当你向数据库插入一个 uuid.UUID 实例时，SQLite 会自动调用 adapt_uuid() 把其转换为字符串；数据库内部存储为 TEXT 或 BLOB，具体取决于表定义。\n\n2. register_converter\n\n\n用法：sqlite3.register_converter(sqlite_type, converter_func)\n\n\nsqlite_type：数据库中声明的类型名（如 &quot;UUID&quot;、&quot;DATE&quot;、&quot;DECIMAL&quot; 等，需与表定义或列别名中对应）。不区分大小写。\n\n\nconverter_func(value_bytes)：接收数据库读取出的字节流（bytes），将其转换为对应 Python 类型后返回。\n\n\nimport sqlite3\nimport uuid\n \n# 1. 定义如何把数据库中的十六进制字符串转换回 uuid.UUID\ndef convert_uuid(b):\n    # b 是 bytes，例如 b&#039;550e8400e29b41d4a716446655440000&#039;\n    return uuid.UUID(hex=b.decode())\n \n# 2. 注册\nsqlite3.register_converter(&quot;UUID&quot;, convert_uuid)\n \n# 3. 示例：创建表时使用自定义类型\nconn = sqlite3.connect(\n    &#039;test_uuid.db&#039;,\n    detect_types=sqlite3.PARSE_DECLTYPES\n)\ncursor = conn.cursor()\n \ncursor.execute(&#039;CREATE TABLE IF NOT EXISTS items (id UUID PRIMARY KEY, name TEXT)&#039;)\nu = uuid.uuid4()\ncursor.execute(&#039;INSERT INTO items (id, name) VALUES (?, ?)&#039;, (u, &#039;Sample&#039;))\nconn.commit()\n \n# 查询时，id 列会被转换成 uuid.UUID\ncursor.execute(&#039;SELECT id, name FROM items&#039;)\nrow = cursor.fetchone()\nprint(type(row[0]), row[0])  # &lt;class &#039;uuid.UUID&#039;&gt; 550e8400-e29b-41d4-a716-446655440000\n要点提示\n\n适配器（Adapter）负责“Python 值 → 存储值”；通常在写入阶段参与。\n转换器（Converter）负责“存储值 → Python 值”；通常在查询阶段参与，需结合 detect_types 启用。\n类型名称匹配：register_converter 的第一个参数要和表定义中列类型或 SELECT 别名中的类型（不区分大小写）一致，否则不会自动调用。\n如果你想让适配器输出的字节/字符串对应不同类型的存储行为，可在表创建时显式指定列类型。例如把 UUID 存储为 BLOB，可先将 **adapt_uuid** 返回一个 16 字节二进制，再把列定义为 **BLOB**。\n\n\n八、常用实战示例\n下面通过几个常见场景，演示在 Python 中用 sqlite3 模块对数据库进行更全面的操作。\n1. 创建数据库并插入复杂数据\nimport sqlite3\nimport datetime\n \n# 1. 连接并启用 datetime 类型自动转换\nsqlite3.register_adapter(datetime.date, lambda d: d.isoformat())\nsqlite3.register_converter(&quot;DATE&quot;, lambda b: datetime.date.fromisoformat(b.decode()))\n \nconn = sqlite3.connect(\n    &#039;company.db&#039;,\n    detect_types=sqlite3.PARSE_DECLTYPES\n)\ncursor = conn.cursor()\n \n# 2. 创建部门（departments）表和员工（employees）表\ncursor.executescript(&quot;&quot;&quot;\nCREATE TABLE IF NOT EXISTS departments (\n    id   INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL UNIQUE\n);\n \nCREATE TABLE IF NOT EXISTS employees (\n    id        INTEGER PRIMARY KEY AUTOINCREMENT,\n    name      TEXT NOT NULL,\n    dept_id   INTEGER,\n    hire_date DATE,\n    salary    REAL,\n    FOREIGN KEY(dept_id) REFERENCES departments(id)\n);\n&quot;&quot;&quot;)\nconn.commit()\n \n# 3. 插入部门数据\ndepartments = [(&quot;HR&quot;,), (&quot;Engineering&quot;,), (&quot;Sales&quot;,)]\ncursor.executemany(&#039;INSERT OR IGNORE INTO departments (name) VALUES (?)&#039;, departments)\nconn.commit()\n \n# 4. 查询部门 ID 以便插入员工\ncursor.execute(&#039;SELECT id, name FROM departments&#039;)\ndept_map = {row[1]: row[0] for row in cursor.fetchall()}\n \n# 5. 批量插入员工\ntoday = datetime.date.today()\nemployees = [\n    (&quot;Alice&quot;, dept_map[&quot;Engineering&quot;], today, 90000.0),\n    (&quot;Bob&quot;, dept_map[&quot;HR&quot;], today, 60000.0),\n    (&quot;Carol&quot;, dept_map[&quot;Sales&quot;], today, 70000.0),\n]\ncursor.executemany(\n    &#039;INSERT INTO employees (name, dept_id, hire_date, salary) VALUES (?, ?, ?, ?)&#039;,\n    employees\n)\nconn.commit()\n要点提示\n\n使用 **INSERT OR IGNORE** 语法可以在唯一约束冲突时跳过该行插入，避免程序抛出 IntegrityError。\n结合 **datetime.date** 与 **register_adapter**/**register_converter**，可在 Python 端直接插入和读取日期类型而无需手动字符串转换。\n在插入数据前先查询关联表（如部门）的主键，避免硬编码 ID，提高灵活性。\n\n2. 使用事务保护多步写操作\nimport sqlite3\n \ndef transfer_funds(conn, from_acc, to_acc, amount):\n    &quot;&quot;&quot;\n    在 accounts 表中，将 from_acc 账户的金额减少 amount，将 to_acc 增加 amount。\n    如果余额不足或出现任何异常，回滚事务。\n    &quot;&quot;&quot;\n    try:\n        conn.execute(&#039;BEGIN IMMEDIATE&#039;)  # 显式启动一个写事务并加写锁\n        cur = conn.execute(&#039;SELECT balance FROM accounts WHERE id = ?&#039;, (from_acc,))\n        row = cur.fetchone()\n        if row is None:\n            raise ValueError(f&quot;Account {from_acc} does not exist&quot;)\n        if row[0] &lt; amount:\n            raise ValueError(&quot;Insufficient funds&quot;)\n \n        # 扣款\n        conn.execute(&#039;UPDATE accounts SET balance = balance - ? WHERE id = ?&#039;, (amount, from_acc))\n        # 收款\n        conn.execute(&#039;UPDATE accounts SET balance = balance + ? WHERE id = ?&#039;, (amount, to_acc))\n \n        conn.commit()\n        print(&quot;Transfer successful&quot;)\n    except Exception as e:\n        conn.rollback()\n        print(&quot;Transfer failed:&quot;, e)\n \n# 示例使用\nconn = sqlite3.connect(&#039;bank.db&#039;)\n# 假设 accounts 表已存在且有必要的初始数据\ntransfer_funds(conn, 1, 2, 100.0)\nconn.close()\n要点提示\n\n使用 **BEGIN IMMEDIATE** 可以确保事务一开始就获取写锁，防止在事务中途被其他写操作阻塞。\n在事务中任何一步出现异常，都要显式 **rollback()**，否则会导致数据库处于半提交状态。\n若只调用 **conn.commit()** 而无写操作，则 commit 不会报错；若进入自动提交模式（**isolation_level=None**），则每条写操作会自动提交，此时就需要手动管理事务。\n\n3. 动态生成 WHERE 子句与防注入\n当需要根据用户输入动态构建过滤条件时，千万不要直接字符串拼接。可以采用以下方法：\nimport sqlite3\n \ndef query_products(conn, filters):\n    &quot;&quot;&quot;\n    filters 是一个字典，例如 {&#039;category&#039;: &#039;Electronics&#039;, &#039;price_min&#039;: 100, &#039;price_max&#039;: 500}\n    动态构建 WHERE 子句，但使用参数绑定防止注入。\n    &quot;&quot;&quot;\n    sql = &quot;SELECT id, name, category, price FROM products&quot;\n    where_clauses = []\n    params = []\n \n    if &#039;category&#039; in filters:\n        where_clauses.append(&quot;category = ?&quot;)\n        params.append(filters[&#039;category&#039;])\n    if &#039;price_min&#039; in filters:\n        where_clauses.append(&quot;price &gt;= ?&quot;)\n        params.append(filters[&#039;price_min&#039;])\n    if &#039;price_max&#039; in filters:\n        where_clauses.append(&quot;price &lt;= ?&quot;)\n        params.append(filters[&#039;price_max&#039;])\n    if &#039;keyword&#039; in filters:\n        where_clauses.append(&quot;name LIKE ?&quot;)\n        params.append(f&quot;%{filters[&#039;keyword&#039;]}%&quot;)\n \n    if where_clauses:\n        sql += &quot; WHERE &quot; + &quot; AND &quot;.join(where_clauses)\n \n    cursor = conn.execute(sql, params)\n    return cursor.fetchall()\n \n# 示例调用\nconn = sqlite3.connect(&#039;shop.db&#039;)\nfilters = {&#039;category&#039;: &#039;Books&#039;, &#039;price_max&#039;: 50, &#039;keyword&#039;: &#039;Python&#039;}\nresults = query_products(conn, filters)\nfor row in results:\n    print(row)\nconn.close()\n要点提示\n\n在动态构建 SQL 时，只拼接固定的字段名和逻辑关键字（AND、OR 等），而将所有变量部分都放到参数列表里，通过 **?** 占位。\n不要把用户输入直接拼到 SQL 里，否则极易导致 SQL 注入漏洞。\n\n4. 处理 BLOB（二进制）数据\n假设你要在 SQLite 中存储图片或其他二进制文件，可以使用 sqlite3.Binary() 辅助函数将 bytes 包装为可以安全插入的类型。\nimport sqlite3\n \n# 存储图片到 BLOB 列\ndef store_image(conn, image_path, image_name):\n    with open(image_path, &#039;rb&#039;) as f:\n        img_data = f.read()\n    # sqlite3.Binary() 将 bytes 转换为合适的格式\n    conn.execute(\n        &#039;INSERT INTO images (name, data) VALUES (?, ?)&#039;,\n        (image_name, sqlite3.Binary(img_data))\n    )\n    conn.commit()\n \n# 从 BLOB 列读取图片到文件\ndef load_image(conn, image_id, output_path):\n    cursor = conn.execute(\n        &#039;SELECT data FROM images WHERE id = ?&#039;,\n        (image_id,)\n    )\n    row = cursor.fetchone()\n    if row is None:\n        raise ValueError(&quot;Image not found&quot;)\n    img_data = row[0]  # bytes\n    with open(output_path, &#039;wb&#039;) as f:\n        f.write(img_data)\n \n# 示例\nconn = sqlite3.connect(&#039;media.db&#039;)\nconn.execute(&#039;CREATE TABLE IF NOT EXISTS images (id INTEGER PRIMARY KEY, name TEXT, data BLOB)&#039;)\nconn.commit()\n \nstore_image(conn, &#039;photo.jpg&#039;, &#039;MyPhoto&#039;)\nload_image(conn, 1, &#039;exported_photo.jpg&#039;)\nconn.close()\n要点提示\n\n要插入二进制数据，务必使用 **sqlite3.Binary(bytes_data)**，否则在 Python 3 中直接传 bytes 也通常能工作，但在 Python 2 或者特定版本可能需要显式包装。\nBLOB 数据会增大 SQLite 文件体积，若需要存储大量大文件，建议改用文件系统 + 路径存储的方式。\n\n5. 使用 ATTACH 实现多库查询\nSQLite 支持同时打开多个数据库，通过 ATTACH 将其他数据库附加到当前连接，并赋予别名，然后在查询时通过别名指定库名。\nimport sqlite3\n \n# 连接主库\nconn = sqlite3.connect(&#039;main.db&#039;)\ncursor = conn.cursor()\n \n# 创建主库表\ncursor.execute(&#039;CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)&#039;)\ncursor.execute(&quot;INSERT OR IGNORE INTO users (id, name) VALUES (1, &#039;Alice&#039;)&quot;)\nconn.commit()\n \n# 附加另一个数据库\ncursor.execute(&quot;ATTACH DATABASE &#039;archive.db&#039; AS archive&quot;)\n# 在 archive 下创建同名表并插入数据\ncursor.executescript(&quot;&quot;&quot;\nCREATE TABLE IF NOT EXISTS archive.users (id INTEGER PRIMARY KEY, name TEXT);\nINSERT OR IGNORE INTO archive.users (id, name) VALUES (2, &#039;Bob&#039;);\n&quot;&quot;&quot;)\nconn.commit()\n \n# 联合查询主库和附加库中的用户\ncursor.execute(&quot;&quot;&quot;\nSELECT id, name, &#039;main&#039; AS source FROM users\nUNION ALL\nSELECT id, name, &#039;archive&#039; AS source FROM archive.users\n&quot;&quot;&quot;)\nfor row in cursor.fetchall():\n    print(row)  # (1, &#039;Alice&#039;, &#039;main&#039;)  和  (2, &#039;Bob&#039;, &#039;archive&#039;)\n \n# 分离附加库\ncursor.execute(&quot;DETACH DATABASE archive&quot;)\nconn.close()\n要点提示\n\n**ATTACH DATABASE &#039;filename&#039; AS alias** 可以在同一个连接内同时访问多个数据库文件。\n对附加的数据库执行 DML/DQL 时，需要在表名前加上 **alias.** 前缀，以区分不同数据库中的表。\n当不再需要访问附加库时，一定要调用 **DETACH DATABASE alias**，释放资源并关闭文件句柄。\n\n\n九、性能与优化\n虽然 SQLite 适合轻量级场景，但在数据量增大或并发需求提升时，仍有一些优化策略可以提升性能。\n1. 使用事务批量写入\n将多次写操作包裹在一个事务内，大幅减少文件 I/O 次数：\n# 坏示例：每条插入自动提交\nfor item in items:\n    cursor.execute(&#039;INSERT INTO t (a, b) VALUES (?, ?)&#039;, item)\n    conn.commit()  # 每次都同步到磁盘，极慢\n \n# 优化示例：一次性在事务中提交\ncursor.execute(&#039;BEGIN&#039;)\nfor item in items:\n    cursor.execute(&#039;INSERT INTO t (a, b) VALUES (?, ?)&#039;, item)\nconn.commit()  # 一次提交，最快\n要点提示\n\nSQLite 默认会为每个写操作做一次事务提交（若 isolation_level=None），或在游标执行时自动开启一个事务并在 commit() 时提交；无论哪种模式，都要避免在循环中频繁调用 commit()。\n推荐显式 BEGIN，完成所有写操作后再 commit()。\n\n2. 禁用同步与 WAL 模式\n在对性能要求极高、对数据持久性要求相对宽松的场景下，可以调整 PRAGMA 设置：\ncursor.executescript(&quot;&quot;&quot;\nPRAGMA synchronous = OFF;   -- 关闭同步，写操作后不等待磁盘刷新\nPRAGMA journal_mode = MEMORY; -- 日志保存在内存中而非磁盘\n&quot;&quot;&quot;)\nconn.commit()\n\n\nPRAGMA synchronous = OFF/0|NORMAL/1|FULL/2|EXTRA/3：\n\n\nFULL（默认）保证事务提交时会等待操作系统将数据写入物理磁盘。\n\n\nNORMAL 略微提升性能，但在崩溃时可能丢失少量最新事务。\n\n\nOFF 性能最高，但崩溃时易导致数据库损坏。\n\n\nPRAGMA journal_mode = DELETE/TRUNCATE/PERSIST/MEMORY/WAL/OFF：\n\n\nWAL（Write-Ahead Logging）模式通常能显著提升并发写入性能：写入时先追加到 WAL 文件，不会阻塞读操作。\n\n\nMEMORY 日志只保存在内存，性能更好，但程序终止后日志信息丢失。\n\n\nOFF 关闭写前日志（危险，不建议在生产使用）。\n\n\n要点提示\n\n这些 PRAGMA 设置会影响数据安全性，请评估崩溃与丢数据的风险后再决定。\n**PRAGMA journal_mode = WAL** 适合读多写少场景，允许多个并发读与一个写；但需要 SQLite 版本 ≥ 3.7.0。\n在同一个连接中执行 PRAGMA 后对其生效，对其他连接也有影响；需要谨慎使用。\n\n3. 索引 (Index)\n为常用的 WHERE、JOIN、ORDER BY 字段创建索引，可显著提升查询性能：\n# 假设 employees 表经常按 dept_id 查询\ncursor.execute(&#039;CREATE INDEX IF NOT EXISTS idx_emp_dept ON employees(dept_id)&#039;)\nconn.commit()\n要点提示\n\n不要盲目为每个列都创建索引，索引会占用空间且插入/更新时需要维护索引，影响写性能。\n可以使用 **EXPLAIN QUERY PLAN SELECT ...** 来查看查询计划，判断是否使用了索引。\n\n4. 减少 Python ↔ SQLite 之间的交互次数\n\n\n批量操作\n\n\n使用 executemany 代替循环调用 execute。\n\n\n如果需要大量数据加载，可考虑将数据先写到 CSV，再使用 SQLite 的 import 或通过 conn.executescript() 调用 .readtable() 等方式批量导入。\n\n\n绑定参数一次构建多个 SQL\n\n\n对于大量结构相同但值不同的插入，使用 INSERT INTO ... VALUES (...), (...), (...) 语句（SQLite 3.7.11+ 支持多值插入）可减少 round-trip 次数：\n\n\ndata = [(1, &#039;a&#039;), (2, &#039;b&#039;), (3, &#039;c&#039;)]\nplaceholders = &quot;,&quot;.join([&quot;(?, ?)&quot;] * len(data))\nflat_values = [x for tup in data for x in tup]\nsql = f&#039;INSERT INTO t (col1, col2) VALUES {placeholders}&#039;\nconn.execute(sql, flat_values)\nconn.commit()\n要点提示\n\n减少频繁的游标创建与销毁；在同一连接与游标中尽量合并多条 SQL。\n对于只读查询，可考虑把 **conn.row_factory = None** 保持默认，让查询结果直接以元组形式返回，速度略快于字典/Row 形式。\n\n\n十、异常处理与错误类型\nsqlite3 提供了一系列基于层次结构的异常类，用于在不同错误场景下捕获并处理。\n1. 常见异常类\nBaseException\n └── Exception\n      └── sqlite3.Error\n           ├── sqlite3.DatabaseError\n           │    ├── sqlite3.DataError\n           │    ├── sqlite3.IntegrityError\n           │    ├── sqlite3.ProgrammingError\n           │    ├── sqlite3.OperationalError\n           │    ├── sqlite3.NotSupportedError\n           │    └── sqlite3.InterfaceError\n           └── sqlite3.Warning\n\n**sqlite3.Error**：所有 sqlite3 异常的基类。\n**sqlite3.OperationalError**：底层库返回的错误，如数据库文件不存在、表不存在、磁盘空间不足、锁冲突等。\n**sqlite3.IntegrityError**：违反完整性约束时抛出，如主键重复、外键约束失败、CHECK 约束失败等。\n**sqlite3.ProgrammingError**：SQL 语法错误、错误的参数绑定、不正确的游标使用等。\n**sqlite3.DataError**：数据类型错误或值超出允许范围。\n**sqlite3.NotSupportedError**：调用了不支持的 SQLite 功能。\n**sqlite3.InterfaceError**：在 Python ↔ SQLite 接口层发生的问题，如参数类型不匹配。\n**sqlite3.Warning**：警告类型，一般较少用到。\n\n2. 捕获与处理示例\nimport sqlite3\n \nconn = sqlite3.connect(&#039;:memory:&#039;)\ncursor = conn.cursor()\n \ntry:\n    cursor.execute(&#039;CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT UNIQUE)&#039;)\n    conn.commit()\n \n    # 插入两条同名记录，触发 IntegrityError\n    cursor.execute(&quot;INSERT INTO test (name) VALUES (&#039;Bob&#039;)&quot;)\n    cursor.execute(&quot;INSERT INTO test (name) VALUES (&#039;Bob&#039;)&quot;)\n    conn.commit()\nexcept sqlite3.IntegrityError as ie:\n    print(&quot;IntegrityError:&quot;, ie)\n    conn.rollback()\nexcept sqlite3.OperationalError as oe:\n    print(&quot;OperationalError:&quot;, oe)\n    conn.rollback()\nexcept sqlite3.Error as e:\n    print(&quot;Other sqlite3 error:&quot;, e)\n    conn.rollback()\nfinally:\n    cursor.close()\n    conn.close()\n要点提示\n\n在写操作前后都要捕获并处理 **IntegrityError**、**OperationalError** 等，以保证数据库不会挂起未提交的事务。\n使用通用基类 **sqlite3.Error** 捕获所有类型时不要过度笼统，否则可能掩盖细节；在需要更细粒度识别时，可分开捕获子类。\n对 **fetchone()** 返回 **None** 也要做判断，避免后续访问 **row[0]** 类型错误。\n\n\n十一、最佳实践与注意事项\n\n强烈推荐使用参数化查询\n\n\n永远不要通过字符串拼接生成 SQL。\n使用 ?、:name 或 ?1, ?2 等占位符，将所有值都当做参数传入。\n\n\n在多线程环境下要小心\n\n\n每个线程应该使用各自的连接；若要跨线程共享同一个连接，需在 connect(..., check_same_thread=False) 并自行加锁，保证每次操作前后不会出现并发读写冲突。\n\n\n合理使用事务\n\n\n对多条写操作使用单个事务，避免循环中频繁 commit() 带来的性能问题。\n对于只读查询，可以使用自动提交模式 (isolation_level=None) 或者显式 BEGIN/END 提升并发读性能。\n\n\n及时关闭连接与游标\n\n\n不再使用游标后，调用 cursor.close()；不再使用连接后，调用 conn.close()。\n推荐使用上下文管理（with sqlite3.connect(...) as conn:）来自动管理关闭与回滚。\n\n\n使用适当的 PRAGMA 来优化\n\n\n通过 PRAGMA journal_mode = WAL、PRAGMA synchronous = NORMAL 等调整 SQLite 行为，以平衡安全性与性能。\n可使用 PRAGMA cache_size、PRAGMA temp_store 优化内存使用。\n\n\n谨慎存储大文件与 BLOB\n\n\n虽然可以在 SQLite 中存储图片、音频等 BLOB，但对于大量大文件，建议将文件存放在文件系统，数据库中仅存路径。\n\n\n时刻留意 SQLite 版本\n\n\nPython 自带的 SQLite 版本可能与系统的 SQLite 库版本不同；可通过 sqlite3.sqlite_version 查看 SQLite 引擎版本，通过 sqlite3.version 查看 Python 模块版本。\n不同的 SQLite 版本支持不同的 SQL 特性（如 FTS5、JSON1、窗口函数等），在使用高级功能前需要确认当前版本支持情况。\n\n\n备份与恢复\n\n\n在需要热备份（复制正在使用的数据库）时，可使用 SQLite 提供的在线备份 API：\n\nwith sqlite3.connect(&#039;target_backup.db&#039;) as bck:\n    conn.backup(bck, pages=0, progress=None)\n\n或者在应用层做文件级别的复制，但需保证在复制时没有未提交的写事务。\n\n\n十二、示例：使用 Connection.backup 做在线备份\nimport sqlite3\nimport time\n \ndef create_backup(source_db, backup_db):\n    # 连接源数据库（只读模式）\n    src = sqlite3.connect(f&#039;file:{source_db}?mode=ro&#039;, uri=True)\n    # 连接目标数据库\n    dest = sqlite3.connect(backup_db)\n    with dest:\n        # 将 src 数据库备份到 dest，pages=1 表示每次复制 1 个页面，可通过 progress 回调监控进度\n        src.backup(dest, pages=1, progress=lambda status, remaining, total: print(f&#039;Copied {total-remaining}/{total} pages...&#039;))\n    src.close()\n    dest.close()\n \n# 示例调用\ncreate_backup(&#039;production.db&#039;, &#039;backup.db&#039;)\nprint(&quot;Backup completed.&quot;)\n要点提示\n\n**Connection.backup()** 是原子操作，在备份过程中仍可对源数据库进行读写（但写入时会有短暂延迟），非常适合生产环境热备份。\n如果不需要进度通知，可以将 **pages=0, progress=None** 作为默认值，此时一次性完成所有页面复制。\n\n\n十三、综合示例：构建一个简单的数据访问层（DAO）\n下面演示一个较为完善的简单数据库封装类，使得上层业务调用更清晰。\nimport sqlite3\nimport threading\nfrom typing import Optional, List, Dict, Any\nimport datetime\n \nclass SQLiteDAO:\n    &quot;&quot;&quot;\n    一个线程安全的 SQLite 数据访问层示例（Demo）。\n    - 使用 threading.RLock 来保护连接。\n    - 支持自动创建连接、获取游标、事务管理、行工厂切换等功能。\n    &quot;&quot;&quot;\n \n    def __init__(self, db_path: str, detect_types=0, row_factory=sqlite3.Row):\n        self.db_path = db_path\n        self.detect_types = detect_types\n        self.row_factory = row_factory\n        self._lock = threading.RLock()\n        self._conn: Optional[sqlite3.Connection] = None\n \n    def _connect(self):\n        if self._conn is None:\n            conn = sqlite3.connect(\n                self.db_path,\n                detect_types=self.detect_types,\n                check_same_thread=False\n            )\n            conn.row_factory = self.row_factory\n            self._conn = conn\n        return self._conn\n \n    def _get_cursor(self):\n        conn = self._connect()\n        return conn.cursor()\n \n    def execute(self, sql: str, params: tuple = ()) -&gt; sqlite3.Cursor:\n        &quot;&quot;&quot;\n        执行单条 SQL，并返回游标。\n        自动加锁，保证多线程安全。\n        &quot;&quot;&quot;\n        with self._lock:\n            cursor = self._get_cursor()\n            try:\n                cursor.execute(sql, params)\n            except sqlite3.Error:\n                self._conn.rollback()\n                raise\n            return cursor\n \n    def executemany(self, sql: str, seq_of_params: List[tuple]) -&gt; None:\n        &quot;&quot;&quot;\n        批量执行 SQL。\n        &quot;&quot;&quot;\n        with self._lock:\n            cursor = self._get_cursor()\n            try:\n                cursor.executemany(sql, seq_of_params)\n            except sqlite3.Error:\n                self._conn.rollback()\n                raise\n \n    def query_one(self, sql: str, params: tuple = ()) -&gt; Optional[Dict[str, Any]]:\n        &quot;&quot;&quot;\n        查询单行，返回字典或 Row 对象。\n        &quot;&quot;&quot;\n        cursor = self.execute(sql, params)\n        result = cursor.fetchone()\n        return result\n \n    def query_all(self, sql: str, params: tuple = ()) -&gt; List[Dict[str, Any]]:\n        &quot;&quot;&quot;\n        查询多行，返回字典列表或 Row 列表。\n        &quot;&quot;&quot;\n        cursor = self.execute(sql, params)\n        return cursor.fetchall()\n \n    def commit(self):\n        &quot;&quot;&quot;\n        手动提交事务。\n        &quot;&quot;&quot;\n        with self._lock:\n            if self._conn:\n                self._conn.commit()\n \n    def close(self):\n        &quot;&quot;&quot;\n        关闭连接。\n        &quot;&quot;&quot;\n        with self._lock:\n            if self._conn:\n                self._conn.close()\n                self._conn = None\n \n    def __enter__(self):\n        return self\n \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        &quot;&quot;&quot;\n        如果退出时没有异常，则提交；否则回滚并关闭连接。\n        &quot;&quot;&quot;\n        if exc_type is None:\n            self.commit()\n        else:\n            with self._lock:\n                if self._conn:\n                    self._conn.rollback()\n        self.close()\n \n# 使用示例\nif __name__ == &#039;__main__&#039;:\n    # 先注册日期类型转换\n    def adapt_date(d: datetime.date) -&gt; str:\n        return d.isoformat()\n    def convert_date(b: bytes) -&gt; datetime.date:\n        return datetime.date.fromisoformat(b.decode())\n    sqlite3.register_adapter(datetime.date, adapt_date)\n    sqlite3.register_converter(&#039;DATE&#039;, convert_date)\n \n    with SQLiteDAO(&#039;company2.db&#039;, detect_types=sqlite3.PARSE_DECLTYPES) as dao:\n        # 创建表\n        dao.execute(&#039;&#039;&#039;\n            CREATE TABLE IF NOT EXISTS departments (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL UNIQUE\n            )\n        &#039;&#039;&#039;)\n        dao.execute(&#039;&#039;&#039;\n            CREATE TABLE IF NOT EXISTS employees (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                name TEXT NOT NULL,\n                dept_id INTEGER,\n                hire_date DATE,\n                salary REAL,\n                FOREIGN KEY(dept_id) REFERENCES departments(id)\n            )\n        &#039;&#039;&#039;)\n \n        # 插入数据\n        dao.execute(&#039;INSERT OR IGNORE INTO departments (name) VALUES (?)&#039;, (&#039;Marketing&#039;,))\n        dao.execute(&#039;INSERT OR IGNORE INTO departments (name) VALUES (?)&#039;, (&#039;Finance&#039;,))\n \n        # 查询部门 id\n        row = dao.query_one(&#039;SELECT id FROM departments WHERE name = ?&#039;, (&#039;Marketing&#039;,))\n        dept_id = row[&#039;id&#039;] if row else None\n \n        # 插入员工\n        today = datetime.date.today()\n        dao.execute(\n            &#039;INSERT INTO employees (name, dept_id, hire_date, salary) VALUES (?, ?, ?, ?)&#039;,\n            (&#039;Diana&#039;, dept_id, today, 80000.0)\n        )\n \n        # 查询员工\n        employees = dao.query_all(&#039;SELECT id, name, hire_date FROM employees&#039;)\n        for emp in employees:\n            print(emp[&#039;id&#039;], emp[&#039;name&#039;], emp[&#039;hire_date&#039;])\n要点提示\n\n封装一个简单的 DAO 类，可以规范化数据库连接管理、事务处理和异常处理，让业务逻辑更清晰。\n在多线程环境下，使用 **threading.RLock** 或其他锁机制保护连接与游标，防止竞态条件或并发冲突。\n在 **__exit__** 中既要 commit 也要 rollback，确保在出现异常时不会把事务挂在半提交状态，避免数据不一致。\n\n\n十四、总结\n\n**sqlite3** 模块：是 Python 标准库提供的用于与 SQLite 数据库交互的核心模块，支持 DB-API 2.0 接口，适合嵌入式、单机、小型或中等并发场景。\n核心步骤：\n\n\nsqlite3.connect() 打开（或创建）数据库并获取 Connection。\nconn.cursor() 或 conn.execute() 创建并获得 Cursor，执行 SQL，并使用参数绑定防止注入。\nfetchone() / fetchmany() / fetchall() 获取查询结果。\nconn.commit() 提交事务，或在 with 块中自动提交/回滚。\ncursor.close()、conn.close() 释放资源。\n\n\n\n关键功能：\n\n\n参数绑定：始终使用 ? 或命名占位符，绝不拼接 SQL 字符串。\n\n\n事务管理：多写操作包裹在单个事务中，避免频繁调用 commit()。\n\n\n行工厂：使用 sqlite3.Row 或自定义工厂，使查询结果支持通过列名访问。\n\n\n数据类型转换：通过 register_adapter/register_converter 与 detect_types 机制，实现如 datetime、Decimal、UUID 等自定义类型的自动存储与恢复。\n\n\nBLOB 操作：使用 sqlite3.Binary() 插入二进制数据，或从 BLOB 列读取 bytes 并写入文件。\n\n\n性能优化：使用批量插入、索引、PRAGMA（如 WAL、synchronous 设定）、减少 round-trip 调用等策略提升速度。\n\n\n错误处理：捕获并区别对待 IntegrityError、OperationalError、ProgrammingError 等异常，保证事务在错误时可回滚并释放锁。\n\n\n在线备份：利用 Connection.backup() 可在数据库运行时进行热备份。\n\n"},"python/2.常用库与工具/标准库与内置模块/数据处理/struct":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/struct","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/struct.md","title":"struct","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/数据处理/xml":{"slug":"python/2.常用库与工具/标准库与内置模块/数据处理/xml","filePath":"python/2.常用库与工具/标准库与内置模块/数据处理/xml.md","title":"xml","links":[],"tags":[],"content":"一、模块概述\n\n什么是 **xml** 模块\n\n\nPython 标准库的 xml 包（package）包含了一组子模块，用于解析、创建、操作、验证和序列化 XML 文档。\n它遵循了 W3C 的 XML 标准，可帮助开发者以多种方式（树形、DOM、事件驱动等）来处理 XML。\n\n\n为何选择 Python 内置的 **xml**\n\n\n开箱即用：无需安装任何第三方库，就能满足大多数 XML 解析与生成需求。\n多种 API 风格：支持基于树的 xml.etree.ElementTree、基于 DOM 的 xml.dom.minidom/xml.dom、基于事件的 xml.sax，甚至更底层的 xml.parsers.expat。可根据场景灵活选用。\n与标准兼容：虽然没有内置支持完整的 XSLT、XPath 规范，但对基本的 XML 处理相当完备。\n\n\n主要子模块一览\n\n\n\nxml.etree.ElementTree：简称 ElementTree（常写作 ET），提供类似于“轻量级 DOM”的树形 API，使用最广泛。\n\n\nxml.dom 与 xml.dom.minidom：实现了 W3C DOM Level 1/Level 2 的接口，可构建完整的节点对象模型。minidom 是纯 Python 的简单实现。\n\n\nxml.sax：基于 SAX（Simple API for XML）的事件驱动解析器，适合处理超大或流式 XML。\n\n\nxml.parsers.expat：Expat 库的 Python 绑定，提供低层的、基于 C 的高性能解析器，可用于对性能有严格要求的场景。\n\n\n其它辅助模块：\n\n\nxml.sax.saxutils：常用的工具函数（如 escape()、unescape()、XMLGenerator 等）。\n\n\nxml.sax.handler：定义了各种 SAX 事件处理类的基类。\n\n\nxml.dom.pulldom：结合 DOM 与 SAX 优点的“拉取式”解析 API。\n\n\nxml.parsers：模块化命名空间下，针对不同解析器的包装。\n\n\n\n何时用哪种方式\n\n\nElementTree（**xml.etree.ElementTree**）：最常用，API 简洁，既可解析入内存直接操作，也可增量（iterparse）处理，适合绝大多数中、小型 XML 文档。\nDOM（**xml.dom.minidom/xml.dom**）：需要完全符合 W3C DOM 规范、操作节点类型（如 DocumentType、ProcessingInstruction）或需要输出格式化（pretty-print）的场景，可选用 minidom。但 minidom 内存开销较大，性能较低。\nSAX（**xml.sax**）：适合处理“极大文件”或流式读取，不将整个文档加载到内存，通过回调函数处理各类节点事件。缺点是编程相对繁琐，需要维护“状态机”以记录解析进度。\nExpat（**xml.parsers.expat**）：与 SAX 类似，也是事件驱动，但更底层，提供更高性能，可用于自定义更细的回调；一般用户可不直用，除非有非常高性能需求。\nPullDOM（**xml.dom.pulldom**）：在需要结合 SAX 解析的低内存消耗与 DOM 的随机访问能力时，可使用 PullDOM，将部分子树在内存中构造为 DOM 节点。\n\n\n二、xml.etree.ElementTree（ElementTree）详解\n1. 模块引入与常用别名\nimport xml.etree.ElementTree as ET\n\n约定俗成：大多数示例与文档都使用别名 ET，以简化代码。\n\n2. 基本概念\n\nElement 对象\n\n\n\nElement 类代表 XML 树中的一个节点，其主要属性与方法包括：\n\n\ntag：元素的标签名称（字符串）。\n\n\nattrib：元素的属性字典（dict[str, str]）。\n\n\ntext：元素的文本内容（str 或 None）。\n\n\ntail：元素结束标签之后、下一个兄弟元素开始前的文本（常用于保持格式化换行及缩进时的空白）。\n\n\nlist(child elements)：可以直接当做列表来遍历其子节点；也可以通过 elem.append(child)、elem.insert(idx, child) 来添加。\n\n\nfind(path)、findall(path)、iterfind(path)：根据简单路径或 XPath 片段查找子元素。\n\n\nSubElement(parent, tag, attrib={})：创建并返回一个新的 Element，并自动追加到 parent 的子节点中。\n\n\n\nElementTree 对象\n\n\n\nElementTree 封装了 Element 对象以及与文件/流的解析和写出操作。\n\n\n常用方法：\n\n\nElementTree.parse(source)：从文件名或文件对象解析，返回一个 ElementTree 实例。\n\n\nElementTree(root_element)：通过已有的根 Element 构造对应的 ElementTree 实例。\n\n\ntree.getroot()：获取根元素（Element）。\n\n\ntree.write(file, encoding=&quot;utf-8&quot;, xml_declaration=True, default_namespace=None, method=&quot;xml&quot;)：将整个树写入到文件（或文件名）中。\n\n\n\nXPath 简化支持\n\n\n\nElementTree 支持有限的 XPath 查询，包括：\n\n\n&#039;.&#039;：当前节点；\n\n\n&#039;.//&#039;：所有后代元素；\n\n\n&#039;tag&#039;：直接子元素；\n\n\n&#039;.//tag&#039;：任意层级后代中匹配标签名的元素；\n\n\n&#039;./tag1/tag2&#039;：下一级嵌套；\n\n\n&#039;*&#039;：匹配所有元素；\n\n\n&#039;[@attrib=&quot;value&quot;]&#039;：按属性过滤；\n\n\n&#039;.//tag[@attrib=&quot;value&quot;]&#039;。\n\n\n不支持完整 XPath（如：position()、text()、| 并集操作、复杂函数等）。\n\n\n\n3. 解析 XML 文档\n\n从文件解析\n\nimport xml.etree.ElementTree as ET\n \n# 假设有一个 example.xml：\n# &lt;root&gt;\n#   &lt;user id=&quot;1&quot;&gt;Alice&lt;/user&gt;\n#   &lt;user id=&quot;2&quot;&gt;Bob&lt;/user&gt;\n# &lt;/root&gt;\n \ntree = ET.parse(&#039;example.xml&#039;)        # 读取并解析文件，返回 ElementTree\nroot = tree.getroot()                 # 获取根元素 &lt;root&gt;\nprint(root.tag)                       # &#039;root&#039;\n \nfor user in root.findall(&#039;user&#039;):     # 查找所有直接子元素 &lt;user&gt;\n    uid = user.get(&#039;id&#039;)              # 属性值：&#039;1&#039;、&#039;2&#039;\n    name = user.text                  # 文本内容：&#039;Alice&#039;、&#039;Bob&#039;\n    print(uid, name)\n\n从字符串解析\n\nimport xml.etree.ElementTree as ET\n \nxml_data = &quot;&quot;&quot;\n&lt;root&gt;\n    &lt;item name=&quot;Item1&quot; value=&quot;10&quot;/&gt;\n    &lt;item name=&quot;Item2&quot; value=&quot;20&quot;/&gt;\n&lt;/root&gt;\n&quot;&quot;&quot;\nroot = ET.fromstring(xml_data)       # 直接返回根 Element，无需 ElementTree\nfor item in root.findall(&#039;item&#039;):\n    print(item.attrib[&#039;name&#039;], item.attrib[&#039;value&#039;])\n\n增量解析（iterparse）\n\n\n对于超大 XML 文件，一次性加载会占用大量内存，可用 ET.iterparse() 按事件（start、end）逐步解析，并在不需要的时候清理已处理节点。\n典型用法：\n\nimport xml.etree.ElementTree as ET\n \n# iterparse 返回一个可迭代的 (event, element) 对\n# 默认只生成 &#039;end&#039; 事件，也可通过 events=(&#039;start&#039;, &#039;end&#039;) 指定\ncontext = ET.iterparse(&#039;huge.xml&#039;, events=(&#039;end&#039;,))\nfor event, elem in context:\n    # 当遇到 &lt;record&gt; 完整结束时进行处理\n    if elem.tag == &#039;record&#039;:\n        # 处理 record 节点\n        print(elem.find(&#039;field1&#039;).text)\n        # 清理已处理的子树，释放内存\n        elem.clear()\n要点提示\n\nparse() 会一次性构建完整树，适合中小型 XML；fromstring() 适合小量内存字符串解析；iterparse() 则适合大文件。\n在 iterparse 中，一旦 elem.clear()，该节点的所有子节点与文本都会被移除，需谨慎保证不再使用它们。\n\n\n4. 操作（创建/修改）XML 树\n\n创建树与子节点\n\nimport xml.etree.ElementTree as ET\n \n# 创建根元素\nroot = ET.Element(&#039;catalog&#039;)\n \n# 添加子元素\nbook1 = ET.SubElement(root, &#039;book&#039;, attrib={&#039;id&#039;: &#039;bk101&#039;})\ntitle = ET.SubElement(book1, &#039;title&#039;)\ntitle.text = &#039;XML Developer\\&#039;s Guide&#039;\nauthor = ET.SubElement(book1, &#039;author&#039;)\nauthor.text = &#039;Gambardella, Matthew&#039;\n \n# 继续添加另一本书\nbook2 = ET.SubElement(root, &#039;book&#039;, attrib={&#039;id&#039;: &#039;bk102&#039;})\nET.SubElement(book2, &#039;title&#039;).text = &#039;Midnight Rain&#039;\nET.SubElement(book2, &#039;author&#039;).text = &#039;Ralls, Kim&#039;\n\n修改节点与属性\n\n# 假设已通过 parse() 得到一个 tree 和 root\nfor book in root.findall(&#039;book&#039;):\n    if book.get(&#039;id&#039;) == &#039;bk101&#039;:\n        # 修改属性\n        book.set(&#039;lang&#039;, &#039;en&#039;)\n        # 修改子节点文本\n        title = book.find(&#039;title&#039;)\n        title.text = &#039;XML Developer\\&#039;s Guide (2nd Edition)&#039;\n \n# 删除某个子节点\nfor book in root.findall(&#039;book&#039;):\n    if book.get(&#039;id&#039;) == &#039;bk102&#039;:\n        root.remove(book)\n\n序列化并写入文件\n\n# 如果要输出带有 XML 声明的文档\ntree = ET.ElementTree(root)\ntree.write(&#039;output.xml&#039;, encoding=&#039;utf-8&#039;, xml_declaration=True)\n \n# 如果想获得字符串形式，可用 ET.tostring()\nxml_bytes = ET.tostring(root, encoding=&#039;utf-8&#039;, method=&#039;xml&#039;)\nxml_str = xml_bytes.decode(&#039;utf-8&#039;)\nprint(xml_str)\n\n美化（Pretty-Print）输出\n\n\nElementTree 原生 write() 不会自动添加缩进或换行，输出会全部连在一起。可借助 xml.dom.minidom 对字符串进行格式化：\n\nimport xml.etree.ElementTree as ET\nimport xml.dom.minidom as minidom\n \n# 假设 root 已构造完毕\nrough_string = ET.tostring(root, &#039;utf-8&#039;)\nreparsed = minidom.parseString(rough_string)\npretty_xml = reparsed.toprettyxml(indent=&quot;  &quot;)\nprint(pretty_xml)\n \n# 保存到文件\nwith open(&#039;pretty_output.xml&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    f.write(pretty_xml)\n要点提示\n\nElementTree 本身不关心缩进与格式；若需要可读性更好的格式，可借助 **minidom** 或第三方库（如 **xml.dom.minidom**、**lxml**）。\n在创建节点时，请始终对需要的子节点设定 **text**；若需要在子元素后加入额外文本，可使用 **tail** 属性。\n\n\n5. 命名空间（Namespaces）处理\n\n解析时映射命名空间前缀\n\n\n当 XML 文档中带有命名空间（xmlns=”…” 或 xmlns:ns=”…“）时，ElementTree 会将元素的 tag 改为包含完整 URI 的字符串，格式为 &#039;{namespace}localname&#039;。\n示例：\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;root xmlns:h=&quot;example.org/hello&quot; xmlns:f=&quot;example.org/farewell&quot;&gt;\n    &lt;h:msg&gt;Hello&lt;/h:msg&gt;\n    &lt;f:msg&gt;Goodbye&lt;/f:msg&gt;\n&lt;/root&gt;\nimport xml.etree.ElementTree as ET\n \ntree = ET.parse(&#039;ns_example.xml&#039;)\nroot = tree.getroot()\n \nfor elem in root:\n    print(elem.tag, elem.text)\n    # 输出类似：\n    # {example.org/hello}msg Hello\n    # {example.org/farewell}msg Goodbye\n\n查找带命名空间的元素\n\n\n当用 find()、findall() 时，需要在路径中带上完整的 {namespace}tag 格式，或者传入一个命名空间映射字典并使用前缀，在 ElementTree 1.3+（Python 3.8+）可以更简洁：\n\nns = {\n    &#039;h&#039;: &#039;example.org/hello&#039;,\n    &#039;f&#039;: &#039;example.org/farewell&#039;\n}\n \n# 找到 &lt;h:msg&gt;\nhello = root.find(&#039;h:msg&#039;, namespaces=ns)\nprint(hello.text)  # Hello\n \n# 或者查找任意命名空间下的 &lt;msg&gt;\nfor m in root.findall(&#039;.//{example.org/hello}msg&#039;):\n    print(m.text)\n\n创建带命名空间的元素\n\n\n在创建节点时，同样在 tag 中使用 {} 包含 URI，或者先注册命名空间并使用前缀：\n\nET.register_namespace(&#039;h&#039;, &#039;example.org/hello&#039;)\nET.register_namespace(&#039;f&#039;, &#039;example.org/farewell&#039;)\n \nroot = ET.Element(&#039;root&#039;)\n# 添加带命名空间的子元素\nh_msg = ET.SubElement(root, &#039;{example.org/hello}msg&#039;)\nh_msg.text = &#039;Hello&#039;\n \nf_msg = ET.SubElement(root, &#039;{example.org/farewell}msg&#039;)\nf_msg.text = &#039;Goodbye&#039;\n \ntree = ET.ElementTree(root)\ntree.write(&#039;ns_output.xml&#039;, encoding=&#039;utf-8&#039;, xml_declaration=True)\n\nregister_namespace(prefix, uri) 会让 write() 在输出时使用 prefix:tagname 而不是 {uri}tagname 形式。\n\n要点提示\n\nPython 内置的 ElementTree 对命名空间的支持相对原始，需要在 **tag** 本身手动带上 **{uri}**，并在查找时同样如此。\n推荐同时使用 **register_namespace**，否则直接写出会保留完整的 **{uri}** 语法，不够直观。\n命名空间映射（**namespaces=...**）从 Python 3.8 开始支持；更低版本需要手动拼接 **{uri}**，无法使用前缀形式。\n\n\n6. 错误处理与调试\n\n捕获解析错误\n\n\n在解析有语法错误或不合规范的 XML 文件时，ElementTree 会抛出 xml.etree.ElementTree.ParseError。可捕获并打印行号、列号、错误原因。\n\nimport xml.etree.ElementTree as ET\n \ntry:\n    tree = ET.parse(&#039;malformed.xml&#039;)\nexcept ET.ParseError as e:\n    print(f&quot;ParseError: {e}&quot;)  # e.pos 可获取行号和列号\n\n验证 XML 模式（XSD/DTD）\n\n\n注意：Python 标准库本身不支持 XML Schema (XSD) 或 DTD 验证。如果需要验证，可以借助第三方库（如 lxml）。\n对于简单的 DTD 验证，可使用 xml.dom.minidom 结合 DocumentType，但通常推荐直接使用 lxml.etree。\n\n\n调试输出\n\n\n可将树序列化为字符串并打印，结合 minidom.toprettyxml()，以便逐步检查树结构与内容是否符合预期。\n\nrough = ET.tostring(root, &#039;utf-8&#039;)\nprint(rough.decode(&#039;utf-8&#039;))\n# 或使用 minidom 格式化\nimport xml.dom.minidom as minidom\nprint(minidom.parseString(rough).toprettyxml(indent=&quot;  &quot;))\n\n三、xml.dom 与 xml.dom.minidom（DOM 解析）详解\n1. 概念简介\n\nDOM（Document Object Model）\n\n\nW3C 标准定义的节点型树结构，XML 文档在内存中被解析为一棵树，每个节点（元素、文本、注释、属性等）都对应一个对象。\n节点之间具有父子等关系，可通过 API 随意访问、修改、添加或删除任意位置的节点。\n\n\nPython 中的 DOM 实现\n\n\n标准库 xml.dom 定义了基础接口与类；xml.dom.minidom 是纯 Python 的简单实现，虽然效率不高，但 API 贴合 W3C DOM 规范，适合理解 DOM 概念或对小规模 XML 文档进行操作。\n\n2. 基本用法示例\n\n解析文件/字符串为 DOM 树\n\nfrom xml.dom import minidom\n \n# 从文件解析\ndoc: minidom.Document = minidom.parse(&#039;example.xml&#039;)\n \n# 从字符串解析\nxml_string = &#039;&lt;root&gt;&lt;user id=&quot;1&quot;&gt;Alice&lt;/user&gt;&lt;user id=&quot;2&quot;&gt;Bob&lt;/user&gt;&lt;/root&gt;&#039;\ndoc2 = minidom.parseString(xml_string)\n\n遍历节点\n\n\n\ndocumentElement：表示文档的根节点（相当于 getElementsByTagName() 的起点）。\n\n\ngetElementsByTagName(tag)：获取所有匹配标签的节点列表。\n\n\n节点类型常见枚举：Node.ELEMENT_NODE、Node.TEXT_NODE、Node.COMMENT_NODE、Node.DOCUMENT_NODE 等。\n\n\n节点属性：\n\n\nnode.tagName：元素的标签名。\n\n\nnode.attributes：一个名为 NamedNodeMap 的映射，可通过 getNamedItem(&#039;attr&#039;) 或 node.getAttribute(&#039;attr&#039;) 获取属性值。\n\n\nnode.childNodes：一个 NodeList，包含子节点。\n\n\nnode.firstChild、node.lastChild、node.nextSibling、node.previousSibling 等。\n\n\nfrom xml.dom import minidom\n \ndoc = minidom.parse(&#039;example.xml&#039;)\nroot = doc.documentElement        # &lt;root&gt; 节点\nusers = root.getElementsByTagName(&#039;user&#039;)\n \nfor u in users:\n    uid = u.getAttribute(&#039;id&#039;)\n    name = &#039;&#039;\n    # 假设 &lt;user&gt; 内部只包含文本节点\n    for node in u.childNodes:\n        if node.nodeType == node.TEXT_NODE:\n            name = node.nodeValue.strip()\n    print(uid, name)\n\n创建与修改节点\n\nfrom xml.dom import minidom\n \n# 创建一个空文档\ndoc = minidom.Document()\n \n# 创建根节点\nroot = doc.createElement(&#039;library&#039;)\ndoc.appendChild(root)\n \n# 创建 &lt;book id=&quot;b1&quot;&gt;\nbook = doc.createElement(&#039;book&#039;)\nbook.setAttribute(&#039;id&#039;, &#039;b1&#039;)\nroot.appendChild(book)\n \n# 添加 &lt;title&gt;XML in a Nutshell&lt;/title&gt;\ntitle = doc.createElement(&#039;title&#039;)\ntxt = doc.createTextNode(&#039;XML in a Nutshell&#039;)\ntitle.appendChild(txt)\nbook.appendChild(title)\n \n# 添加 &lt;author&gt;xxx&lt;/author&gt;\nauthor = doc.createElement(&#039;author&#039;)\nauthor.appendChild(doc.createTextNode(&#039;Elliotte Rusty Harold&#039;))\nbook.appendChild(author)\n \n# 序列化并输出\nxml_str = doc.toprettyxml(indent=&#039;  &#039;, encoding=&#039;utf-8&#039;)\nprint(xml_str.decode(&#039;utf-8&#039;))\n\n删除节点\n\n# 假设 doc 已有若干节点\nroot = doc.documentElement\nbooks = root.getElementsByTagName(&#039;book&#039;)\nfor bk in books:\n    if bk.getAttribute(&#039;id&#039;) == &#039;b2&#039;:\n        root.removeChild(bk)\n        bk.unlink()   # 解除引用，帮助垃圾回收\n        break\n要点提示\n\n**minidom** API 贴合 W3C DOM，但在纯 Python 实现下，解析与操作大量节点时会非常慢，内存占用也很高，慎用。\n节点的 **toxml()** 或 **toprettyxml()** 可将部分子树或整个文档序列化为字符串，但输出编码与缩进可控性有限。\n如果只需要轻量级操作，优先考虑 ElementTree；使用 minidom 仅在需要完整 DOM 功能（如节点类型判断、多文档导入导出、DocumentType 操作等）时才用。\n\n\n四、xml.sax（SAX 解析）详解\n1. 基本概念\n\nSAX（Simple API for XML）\n\n\n基于事件驱动的解析模型：解析器在扫描到起始标签、文本、结束标签、注释等事件时，会回调用户定义的处理函数（Handler 方法）。\n优点：不需要将整个文档加载到内存中，适合流式读取或超大 XML 文件。\n缺点：编程方式更接近“状态机”，需要用户自己维护上下文与父子关系，不如 DOM/ElementTree 直观。\n\n\nPython 中的 **xml.sax**\n\n\n\n提供了一个 SAX 解析器工厂 xml.sax.make_parser()，默认使用 Expat 解析器。\n\n\n需要定义一个或多个继承自 xml.sax.ContentHandler（或 xml.sax.handler.ContentHandler）的类，重写其中的方法来处理各类事件：\n\n\nstartDocument()、endDocument()：文档开始与结束时触发。\n\n\nstartElement(name, attrs)：遇到起始标签时触发；attrs 是一个类似字典的对象，可用 attrs.getValue(&#039;attrName&#039;)。\n\n\nendElement(name)：遇到结束标签时触发。\n\n\ncharacters(content)：遇到文本节点时触发；连续的文本可能会多次调用此方法，需拼接。\n\n\nignorableWhitespace(whitespace)、processingInstruction(target, data)、startPrefixMapping(prefix, uri)、endPrefixMapping(prefix) 等可选事件。\n\n\n通过 parser.setContentHandler(your_handler) 来注册处理器，然后调用 parser.parse(source) 开始解析（source 可以是文件路径、文件对象、URL 等）。\n\n\n2. 示例：统计元素出现次数\nimport xml.sax\n \nclass CountHandler(xml.sax.ContentHandler):\n    def __init__(self):\n        super().__init__()\n        self.counts = {}\n    def startElement(self, name, attrs):\n        # 每次遇到一个起始标签，就记录\n        self.counts[name] = self.counts.get(name, 0) + 1\n    def endDocument(self):\n        print(&quot;元素出现次数：&quot;)\n        for tag, cnt in self.counts.items():\n            print(f&quot;{tag}: {cnt}&quot;)\n \nif __name__ == &#039;__main__&#039;:\n    parser = xml.sax.make_parser()\n    handler = CountHandler()\n    parser.setContentHandler(handler)\n    parser.parse(&#039;large.xml&#039;)  # 解析文件\n3. 解析文本节点（连续的 characters 调用）\nimport xml.sax\n \nclass TextCollector(xml.sax.ContentHandler):\n    def __init__(self):\n        super().__init__()\n        self.current_data = None\n        self.buffer = &quot;&quot;  # 缓存连续的文本片段\n    def startElement(self, name, attrs):\n        self.current_data = name\n        self.buffer = &quot;&quot;\n    def characters(self, content):\n        # content 可能被分段传入，需拼接\n        if self.current_data:\n            self.buffer += content\n    def endElement(self, name):\n        if name == self.current_data:\n            text = self.buffer.strip()\n            if text:\n                print(f&quot;{name} 内部文本：{text}&quot;)\n        self.current_data = None\n \nif __name__ == &#039;__main__&#039;:\n    parser = xml.sax.make_parser()\n    handler = TextCollector()\n    parser.setContentHandler(handler)\n    parser.parse(&#039;example.xml&#039;)\n4. 处理属性与命名空间\n\n属性\n\n\nattrs 参数实现了 AttributesImpl，可通过 attrs.getNames() 或 attrs.items() 获取全部 (name, value)。\n对于命名空间属性，SAX 默认不会将其分成 {uri}name，需要在创建解析器时设置命名空间支持：\n\nimport xml.sax\n \nclass NSHandler(xml.sax.ContentHandler):\n    def startElementNS(self, name, qname, attrs):\n        # name 是一个 (uri, localname) 元组\n        uri, localname = name\n        print(&quot;元素：&quot;, localname, &quot;命名空间：&quot;, uri)\n        # attrs 也是字典格式，但键为 (uri, localname)\n        for attr_name, attr_val in attrs.items():\n            print(&quot;  属性：&quot;, attr_name, &quot;=&quot;, attr_val)\n \nif __name__ == &#039;__main__&#039;:\n    parser = xml.sax.make_parser()\n    # 启用命名空间处理\n    parser.setFeature(xml.sax.handler.feature_namespaces, True)\n    handler = NSHandler()\n    parser.setContentHandler(handler)\n    parser.parse(&#039;ns_example.xml&#039;)\n\n命名空间映射\n\n\n如果想在 startElement 中仍然按 {uri}tag 获取标签名，可不开启 feature_namespaces，此时标签类型保留 {uri}localname 形式，但不分离 prefix 与 URI。\n\n5. 错误处理与调试\n\n自定义错误处理器（ErrorHandler）\n\n\n继承 xml.sax.handler.ErrorHandler，实现 error(exception)、fatalError(exception)、warning(exception) 等方法。\n注册给解析器：parser.setErrorHandler(your_error_handler)。\n\nimport xml.sax\nfrom xml.sax.handler import ErrorHandler\n \nclass MyErrorHandler(ErrorHandler):\n    def warning(self, exception):\n        print(&quot;Warning：&quot;, exception)\n    def error(self, exception):\n        print(&quot;Error：&quot;, exception)\n    def fatalError(self, exception):\n        print(&quot;FatalError：&quot;, exception)\n        raise exception  # 停止解析\n \nif __name__ == &#039;__main__&#039;:\n    parser = xml.sax.make_parser()\n    parser.setErrorHandler(MyErrorHandler())\n    parser.parse(&#039;malformed.xml&#039;)\n\n常见异常\n\n\nxml.sax.SAXParseException：语法错误，包含行号、列号和错误信息。\n通过 exception.getLineNumber()、exception.getColumnNumber()、exception.getMessage() 等获取更详细信息。\n\n\n五、xml.parsers.expat（Expat 解析）详解\n1. 模块简介\n\nxml.parsers.expat 提供了对 C 语言编写的 Expat 库的 Python 绑定，是 Python 默认 xml.sax 和 xml.etree.ElementTree 在底层调用的解析引擎。\nExpat 本身就是一个基于回调的事件驱动解析器，其接口类似于 SAX，但比 Python 代码实现更高效。\n\n2. 基本 API\n\n创建解析器\n\nimport xml.parsers.expat\n \n# 创建一个解析器实例\nparser = xml.parsers.expat.ParserCreate(namespace_separator=&#039; &#039;)\n\nnamespace_separator：指定在标签名或属性名中，用于分隔 URI 与本地名的字符，默认为 None，不分离命名空间。若指定 &#039; &#039;，则在 StartElementHandler 的 name 参数中会返回 &#039;uri localname&#039;。\n\n\n注册回调函数\n\ndef start_element(name, attrs):\n    print(&quot;Start element:&quot;, name, attrs)\n \ndef end_element(name):\n    print(&quot;End element:&quot;, name)\n \ndef char_data(data):\n    print(&quot;Text data:&quot;, repr(data))\n \nparser.StartElementHandler = start_element\nparser.EndElementHandler = end_element\nparser.CharacterDataHandler = char_data\n\n\n常见回调：\n\n\nStartElementHandler(name, attrs)：遇到起始标签；name 是标签名（可能包含命名空间前缀），attrs 是一个字典。\n\n\nEndElementHandler(name)：遇到结束标签时触发。\n\n\nCharacterDataHandler(data)：遇到文本时触发（会分段）。\n\n\nProcessingInstructionHandler(target, data)：遇到处理指令（如 &lt;?xml-stylesheet ...?&gt;）。\n\n\nStartNamespaceDeclHandler(prefix, uri) / EndNamespaceDeclHandler(prefix)：命名空间声明开始/结束。\n\n\nDefaultHandler(data)：如果没有其他匹配时，会调用该回调。\n\n\n\n解析数据\n\n# 从文件读取并解析\nwith open(&#039;example.xml&#039;, &#039;rb&#039;) as f:\n    data = f.read()\nparser.Parse(data, True)   # 第二个参数指定是否是文档末尾（True 表示结束）\n\n也可使用分段解析：parser.Parse(buffer_chunk, False) 多次调用，最后一次传入 True 表示结束。\n\n\n捕获错误\n\n\n如果解析出错，会抛出 xml.parsers.expat.ExpatError，可捕获并获取错误信息：e.code, e.lineno, e.offset, e.msg。\n\ntry:\n    parser.Parse(data, True)\nexcept xml.parsers.expat.ExpatError as e:\n    print(f&quot;ExpatError: Line {e.lineno} Col {e.offset}: {e.code} {e.msg}&quot;)\n要点提示\n\n**xml.parsers.expat** 提供最底层的高性能回调接口，但编程更为复杂；若只需业务逻辑，可考虑上层的 **xml.sax** 或 **ElementTree**。\n在需要超大文件且对性能极为敏感的场景，可以直接面向 Expat 回调 API。\n\n\n六、xml.dom.pulldom（PullDOM）简介\n1. PullDOM 概念\n\nPullDOM 是在 SAX 解析基础上，结合 DOM 的创建机制，按需构建子 DOM 子树的一种“拉取式”解析方式。\n与纯 SAX 不同，PullDOM 在遇到某些指定元素时，会将该节点以及其子孙节点解析为一个完整的 DOM 子树，然后返回给用户，让用户对该子树进行操作；处理完成后可释放该子树，节省内存。\n\n2. 常用 API\nfrom xml.dom import pulldom\n \nfor event, node in pulldom.parse(&#039;large.xml&#039;):\n    if event == pulldom.START_ELEMENT and node.nodeName == &#039;item&#039;:\n        # 构造以 &lt;item&gt; 为根的 DOM 子树\n        item_dom = node.expandNode()   # 返回一个 DOM Element 节点\n        # 此时 item_dom 及其全部子树已构造，可照常使用 DOM API\n        title_nodes = item_dom.getElementsByTagName(&#039;title&#039;)\n        if title_nodes:\n            print(title_nodes[0].firstChild.nodeValue)\n        # 处理完后，该子树可被垃圾回收，节省内存\n\nparse(source) 返回一个可迭代的 (event, node) 对，其中 event 是常量（START_DOCUMENT, END_DOCUMENT, START_ELEMENT, END_ELEMENT, PROCESSING_INSTRUCTION, ...），node 是一个临时 DOM 节点或空。\n\n要点提示\n\nPullDOM 兼顾了 SAX 对大文件的低内存解析优势与 DOM 随机访问子树的方便，但实现复杂性略高。\n如果只需要传统的树形操作，优先考虑 ElementTree；若仅仅读取并搜索少量子节点，可考虑 PullDOM。\n\n\n七、字符转义与辅助工具（xml.sax.saxutils）\n1. escape() 与 unescape()\n\n在生成 XML 的过程中，需要对特殊字符（&amp; &lt; &gt; &#039; &quot;）进行转义，以免与 XML 语法冲突。xml.sax.saxutils 提供了：\n\nfrom xml.sax.saxutils import escape, unescape\n \ns = &#039;5 &lt; 10 &amp; 20 &gt; 15&#039;\nescaped = escape(s)  \n# 默认会把 &amp; → &amp;amp;, &lt; → &amp;lt;, &gt; → &amp;gt;, &quot; 与 &#039; 不会转义\nprint(escaped)  # &#039;5 &amp;lt; 10 &amp;amp; 20 &amp;gt; 15&#039;\n \n# 如果希望对双引号与单引号也做转义，可传入实体映射字典\nescaped2 = escape(s, entities={&#039;&quot;&#039;: &#039;&amp;quot;&#039;, &quot;&#039;&quot;: &#039;&amp;apos;&#039;})\nprint(escaped2)\n \n# 反向：把 &amp;amp; &amp;lt; 等实体转回原字符\nraw = unescape(&#039;Fish &amp;amp; Chips &amp;lt;3&#039;)\nprint(raw)  # &#039;Fish &amp; Chips &lt;3&#039;\n2. XMLGenerator\n\nXMLGenerator 是一个符合 SAX 的 ContentHandler，可用于将 SAX 事件流转换为字符串或写到文件中。常用于在代码中“模拟” SAX 事件生成 XML。\n\nfrom xml.sax.saxutils import XMLGenerator\n \n# 将事件流写到文件\nwith open(&#039;out.xml&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    handler = XMLGenerator(f, encoding=&#039;utf-8&#039;)\n    handler.startDocument()\n    handler.startElement(&#039;greeting&#039;, {&#039;lang&#039;: &#039;en&#039;})\n    handler.characters(&#039;Hello, World!&#039;)\n    handler.endElement(&#039;greeting&#039;)\n    handler.endDocument()\n \n# 生成输出：\n# &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n# &lt;greeting lang=&quot;en&quot;&gt;Hello, World!&lt;/greeting&gt;\n3. quoteattr()\n\n将属性值进行转义并加引号：\n\nfrom xml.sax.saxutils import quoteattr\n \nval = &#039;Tom &amp; Jerry &quot;Best&quot;&#039;\nprint(quoteattr(val))  \n# 输出 &#039;&quot;Tom &amp;amp; Jerry &amp;quot;Best&amp;quot;&quot;&#039;\n要点提示\n\n手动生成 XML 时，不要自己拼接 **&lt;tag&gt;{text}&lt;/tag&gt;**，而应先对 **text** 调用 **escape()**，对属性值用 **quoteattr()**。\n对于定制复杂文档格式、需要严格控制空白与换行的场景，可结合 **XMLGenerator** 模拟 SAX 事件，更精确地输出。\n\n\n八、XML 校验（DTD/XSD）\n1. Python 标准库不支持原生校验\n\n注意：Python 内置的 xml 包本身不提供 DTD（Document Type Definition）或 XSD（XML Schema Definition）的校验功能。即便在 minidom.parse() 时，若文档声明了 DTD，也只会解析，不会验证。\n如果文档具有 DTD 或 XSD 引用，解析时不会自动报“验证错误”，只能手动根据 DocumentType 节点或第三方接口进行验证。\n\n2. 使用第三方库进行校验（推荐）\n\nlxml\n\n\nlxml.etree 可以直接支持 DTD 与 XSD 验证。示例（需要安装 lxml）：\n\nfrom lxml import etree\n \n# DTD 验证\ndtd = etree.DTD(open(&#039;example.dtd&#039;))\nxml_doc = etree.parse(&#039;example.xml&#039;)\nif dtd.validate(xml_doc):\n    print(&quot;DTD 验证通过&quot;)\nelse:\n    print(&quot;DTD 验证失败：&quot;, dtd.error_log.filter_from_errors())\n \n# XSD 验证\nxmlschema_doc = etree.parse(&#039;example.xsd&#039;)\nxmlschema = etree.XMLSchema(xmlschema_doc)\nxml_doc = etree.parse(&#039;example.xml&#039;)\ntry:\n    xmlschema.assertValid(xml_doc)\n    print(&quot;XSD 验证通过&quot;)\nexcept etree.DocumentInvalid as e:\n    print(&quot;XSD 验证失败：&quot;, e)\n\nxmlschema（第三方纯 Python 库）\n\n\n支持完整的 XSD 1.0 规范验证，也能转换为 Python 数据对象。安装：pip install xmlschema。示例：\n\nimport xmlschema\n \nschema = xmlschema.XMLSchema(&#039;example.xsd&#039;)\nif schema.is_valid(&#039;example.xml&#039;):\n    print(&quot;XML 符合 XSD 规范&quot;)\nelse:\n    print(&quot;不符合：&quot;, schema.validate(&#039;example.xml&#039;))\n要点提示\n\n如果项目对 XML 文档的格式与内容有严格约束需求，请务必引入第三方库（如 **lxml** 或 **xmlschema**），因为标准库本身仅能解析、不能验证。\n在读写 XML 过程中，可先使用验证库检查文档合法性，再进行进一步处理。\n\n\n九、性能与最佳实践\n\n选择合适的 API\n\n\n小型、简单文档或配置文件：使用 xml.etree.ElementTree。\n需要严格 DOM 操作或 W3C 兼容：少量时可选用 xml.dom.minidom；但若文档较大，建议使用 lxml（第三方）。\n超大或流式处理：使用 xml.sax（或底层的 xml.parsers.expat），结合 iterparse。\n\n\n避免重复转换与多次解析\n\n\n如果需要多次访问同一个子树，先保留引用，避免重复调用 find()、findall()。\n若需要查找多次，可将元素列表缓存到 Python 数据结构（dict 或 list）中，以加速后续查找。\n\n\n及时释放资源（大文档）\n\n\n在 iterparse 场景下，对已经处理完的节点调用 elem.clear() 并删除对父节点的引用 del elem，以便 Python 垃圾回收。\n对使用 DOM (minidom) 构建的节点，处理完后可用 node.unlink() 断开父子引用，释放内存。\n\n\n使用 **encoding** 与 **errors** 参数\n\n\n当 XML 声明了字符编码（如 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;），Python 解析时一般会自动检测。但如果文件实际编码与声明不符，可先以二进制方式读取，手动 decode() 后再用 fromstring()。\n在读取文件时，可用 open(&#039;f.xml&#039;, encoding=&#039;utf-8&#039;, errors=&#039;replace&#039;)，避免出现编码错误导致解析失败。\n\n\n遵循“先验证、后解析”原则\n\n\n如果输入来自外部、且需要严格符合特定结构，请先使用第三方验证库在解析前检查，保障后续逻辑不会因格式不符而出错。\n\n\nXML 注入与安全考虑\n\n\n避免信任来自用户的 XML 文档，防止所谓“XML 外部实体注入攻击”（XXE）。Python 中的 xml.etree.ElementTree 以及 xml.dom.minidom 在默认情况下不解析外部实体，但 xml.sax 可能会。\n可通过配置禁用外部实体解析：\n\nimport xml.sax\nparser = xml.sax.make_parser()\n# 禁用 DTD/外部实体\nparser.setFeature(xml.sax.handler.feature_external_ges, False)\nparser.setFeature(xml.sax.handler.feature_external_pes, False)\n\n或者使用 defusedxml（第三方库）替换标准库中容易被 XXE 攻击的解析方法：\n\nfrom defusedxml.ElementTree import parse, fromstring\nfrom defusedxml.minidom import parseString\n\n十、综合示例：从多种方式解析并转换 XML\n下面举例演示如何结合 ElementTree、minidom 和 SAX，对同一份 XML 文档做不同需求的处理。\n&lt;!-- orders.xml --&gt;\n&lt;orders xmlns=&quot;example.com/orders&quot; xmlns:prod=&quot;example.com/products&quot;&gt;\n  &lt;order id=&quot;1001&quot; date=&quot;2025-06-01&quot;&gt;\n    &lt;customer&gt;\n      &lt;name&gt;Alice&lt;/name&gt;\n      &lt;email&gt;alice@example.com&lt;/email&gt;\n    &lt;/customer&gt;\n    &lt;items&gt;\n      &lt;prod:item prod:sku=&quot;SKU123&quot; quantity=&quot;2&quot;/&gt;\n      &lt;prod:item prod:sku=&quot;SKU456&quot; quantity=&quot;1&quot;/&gt;\n    &lt;/items&gt;\n  &lt;/order&gt;\n  &lt;order id=&quot;1002&quot; date=&quot;2025-06-02&quot;&gt;\n    &lt;customer&gt;\n      &lt;name&gt;Bob&lt;/name&gt;\n      &lt;email&gt;bob@example.com&lt;/email&gt;\n    &lt;/customer&gt;\n    &lt;items&gt;\n      &lt;prod:item prod:sku=&quot;SKU789&quot; quantity=&quot;5&quot;/&gt;\n    &lt;/items&gt;\n  &lt;/order&gt;\n&lt;/orders&gt;\n1. 使用 ElementTree 解析并输出订单摘要\nimport xml.etree.ElementTree as ET\n \nns = {\n    &#039;o&#039;: &#039;example.com/orders&#039;,\n    &#039;p&#039;: &#039;example.com/products&#039;\n}\n \ntree = ET.parse(&#039;orders.xml&#039;)\nroot = tree.getroot()\n \nfor order in root.findall(&#039;o:order&#039;, namespaces=ns):\n    oid = order.get(&#039;id&#039;)\n    date = order.get(&#039;date&#039;)\n    cust = order.find(&#039;o:customer/o:name&#039;, namespaces=ns).text\n    print(f&quot;Order {oid} on {date}, Customer: {cust}&quot;)\n    total_items = 0\n    for item in order.findall(&#039;o:items/p:item&#039;, namespaces=ns):\n        qty = int(item.get(&#039;quantity&#039;))\n        sku = item.get(&#039;{example.com/products}sku&#039;)  # 另一种写法\n        print(f&quot;  Item SKU={sku}, Quantity={qty}&quot;)\n        total_items += qty\n    print(f&quot;  Total items: {total_items}&quot;)\n2. 使用 minidom 格式化输出（Pretty Print）\nfrom xml.dom import minidom\n \n# 读取并格式化\ndom = minidom.parse(&#039;orders.xml&#039;)\nprint(dom.toprettyxml(indent=&#039;  &#039;))\n3. 使用 SAX 事件抽取所有 SKU 值\nimport xml.sax\n \nclass SKUHandler(xml.sax.ContentHandler):\n    def __init__(self):\n        super().__init__()\n        self.skus = []\n \n    def startElementNS(self, name, qname, attrs):\n        uri, localname = name\n        # 判断是否是 prod:item\n        if uri == &#039;example.com/products&#039; and localname == &#039;item&#039;:\n            sku = attrs.get((uri, &#039;sku&#039;))  # 元组 (uri, localname)\n            self.skus.append(sku)\n \nif __name__ == &#039;__main__&#039;:\n    parser = xml.sax.make_parser()\n    parser.setFeature(xml.sax.handler.feature_namespaces, True)\n    handler = SKUHandler()\n    parser.setContentHandler(handler)\n    parser.parse(&#039;orders.xml&#039;)\n    print(&quot;所有 SKU：&quot;, handler.skus)\n要点提示\n\nElementTree 是对大多数 XML 业务需求的首选，结合 **namespaces** 参数可轻松处理带命名空间的文档。\nminidom 适合做“快速格式化”或需要操作 DOM 特殊节点（如 **ProcessingInstruction**、**CDATASection**）时使用，但不适合大数据量。\nSAX 事件驱动方式可非常高效地从文档中抽取关键信息（如 SKU 列表），且内存占用极低。\n\n\n十一、总结\n\nPython 标准库的 xml 包提供了多种方式来解析、创建、操作与序列化 XML：\n\n\n**xml.etree.ElementTree**：轻量级树形 API，适合绝大多数中小型 XML 文档的读写与修改；支持简单的 XPath 片段查询与增量（iterparse）处理；命名空间需手动管理。\n**xml.dom.minidom** / **xml.dom**：W3C DOM 兼容接口，面向完整的节点对象模型，可进行任意节点类型的操作，但性能与内存开销较高。\n**xml.sax**：事件驱动解析，适合处理超大文档或流式读取；需要自行维护解析状态，编程稍繁琐。\n**xml.parsers.expat**：底层高性能解析器，提供比 SAX 更原始的回调接口，一般在对性能有极致要求的场景下使用。\n**xml.dom.pulldom**：结合 SAX 与 DOM 优势的拉取式解析，可按需将子树构造为 DOM，但使用场景有限。\n**xml.sax.saxutils**：辅助工具，提供常用的字符转义、XML 生成器、属性转义等函数。\n\n\n\n命名空间（Namespaces）\n\n\nElementTree 通过 {uri}tag 语法管理命名空间，且可注册前缀以简化输出；SAX 可以通过 feature_namespaces 获取 (uri, localname)。\n\n\n在复杂文档中，务必先定义好命名空间映射，确保查找与创建节点时不会出现错配。\n\n\n错误处理与安全\n\n\n标准库本身不提供 DTD/XSD 验证；若需要验证请使用第三方库（如 lxml、xmlschema）。\n\n\n避免 XXE 攻击：在处理来自不可信来源的 XML 时，可禁用外部实体解析，或直接使用 defusedxml 等安全替代方案。\n\n\n性能优化\n\n\n\n对于大文件，优先考虑 iterparse 或 xml.sax，并在处理后及时清理内存。\n如果常规树形操作过于缓慢，可考虑引入 lxml.etree（第三方），其 API 与 ElementTree 类似，但性能更优、功能更强。\n手写 XML 时，务必对文本与属性做转义，或使用 XMLGenerator。\n\n\n最佳实践要点\n\n\n日常使用：以 xml.etree.ElementTree 为主；只在极少数需要 DOM 复杂操作或严格验证时，才考虑其他方式，避免过度设计。\n命名空间：在读写前先明确命名空间 URI 与前缀映射；创建时用 {uri}tag，解析时用 namespaces={}。\n安全与验证：若文档来自用户或外部系统，务必做好验证与实体过滤，避免安全漏洞。\n错误定位：在解析时捕获并打印 ParseError（或 SAXParseException），提供准确的行号和错误信息以便快速定位。\n测试与调试：对于复杂 XML，先用小样本测试解析逻辑；可结合 minidom 的 toprettyxml() 输出格式化结果，直观查看结构。\n"},"python/2.常用库与工具/标准库与内置模块/文件操作/fileinput":{"slug":"python/2.常用库与工具/标准库与内置模块/文件操作/fileinput","filePath":"python/2.常用库与工具/标准库与内置模块/文件操作/fileinput.md","title":"fileinput","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/文件操作/tempfile":{"slug":"python/2.常用库与工具/标准库与内置模块/文件操作/tempfile","filePath":"python/2.常用库与工具/标准库与内置模块/文件操作/tempfile.md","title":"tempfile","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/argparse":{"slug":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/argparse","filePath":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/argparse.md","title":"argparse","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/configparser":{"slug":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/configparser","filePath":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/configparser.md","title":"configparser","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/logging":{"slug":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/logging","filePath":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/logging.md","title":"logging","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/pdb":{"slug":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/pdb","filePath":"python/2.常用库与工具/标准库与内置模块/日志、配置与调试/pdb.md","title":"pdb","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/时间与日期/calendar":{"slug":"python/2.常用库与工具/标准库与内置模块/时间与日期/calendar","filePath":"python/2.常用库与工具/标准库与内置模块/时间与日期/calendar.md","title":"calendar","links":[],"tags":[],"content":"概述\nPython 内置的 calendar 模块提供了一系列与日历计算、格式化和显示相关的工具函数与类。相比于更底层的 time 或 datetime，calendar 专注于“日历视图”——以星期排列的月份、年份以及与闰年、月份长度相关的算法。使用 calendar 模块，可以方便地：\n\n判断某年是否为闰年、计算闰年之间的天数差\n生成某个月或某年的“月视图”，即一个以嵌套列表或字符串表示的表格\n支持不同的星期起始日（如周一或周日）\n输出文本（日历）或 HTML 格式的日历\n根据区域设置（locale）输出本地化的星期和月份名称\n\n下面我们从模块的常量、函数、主要类与用法示例等方面，逐步展开讲解。\n\n一、常量与数据结构\n1.1 星期与月份常量\n\n\n星期相关常量（均为整数，范围 0–6）：\n\n\ncalendar.MONDAY == 0\n\n\ncalendar.TUESDAY == 1\n\n\ncalendar.WEDNESDAY == 2\n\n\ncalendar.THURSDAY == 3\n\n\ncalendar.FRIDAY == 4\n\n\ncalendar.SATURDAY == 5\n\n\ncalendar.SUNDAY == 6\n\n\n用于指定“每周从哪一天开始”，例如在生成日历时，是从 “周一” 还是 “周日” 开始。\n\n\n月份相关常量（均为 1–12）：\n\n\ncalendar.JANUARY == 1\n\n\ncalendar.FEBRUARY == 2\n\n\n…\n\n\ncalendar.DECEMBER == 12\n\n\n虽然在大多数函数中直接用整数代表月份即可，但使用这些常量能让代码可读性更高。\n1.2 本地化名称\n\ncalendar.month_name：长度为 13 的序列，索引从 1 到 12 分别是各个月份的全称，第 0 项为空字符串。例如：\n\nimport calendar\nprint(calendar.month_name[6])  # 输出 &quot;June&quot;（在默认英语环境中）\n\ncalendar.month_abbr：长度为 13 的序列，索引 0 为空，1–12 为各月缩写（“Jan”, “Feb”, …）。\ncalendar.day_name：长度为 7 的序列，0–6 分别对应星期一到星期日的全称，例如 “Monday”, “Tuesday” …\ncalendar.day_abbr：长度为 7 的序列，索引为星期的缩写（“Mon”, “Tue”, …）。\n\n这些名称会随操作系统或 Python 本地化设置（locale）而变化，便于生成本地化日历。\n\n二、闰年相关函数\n2.1 calendar.isleap(year)：判断是否为闰年\nimport calendar\n \nprint(calendar.isleap(2024))  # True（2024 年是闰年）\nprint(calendar.isleap(2100))  # False（2100 虽可被 4 整除，但为世纪年且不可被 400 整除，不是闰年）\n闰年规则：\n\n年份能被 4 整除且不能被 100 整除 ⇒ 闰年\n或能被 400 整除 ⇒ 闰年\n其他情况均非闰年。\n\n2.2 calendar.leapdays(y1, y2)：计算两年之间闰年数\n\n签名：leapdays(y1, y2) 返回从 y1（含）到 y2（不含）之间的闰年个数。\n\nimport calendar\n \n# 计算从 2000 年（含）到 2025 年（不含）之间有多少个闰年\nprint(calendar.leapdays(2000, 2025))  # 输出 6，分别是 2000、2004、2008、2012、2016、2020\n注意：参数区间是 左闭右开，y1 ≤ year &lt; y2。\n\n三、基本函数\n3.1 calendar.monthrange(year, month)：获取某年某月第一天是星期几，以及该月共有多少天\n\n\n签名：monthrange(year, month) 返回一个二元组 (first_weekday, days_in_month)\n\n\nfirst_weekday：0–6 的整数，表示该月的第一天在一周中的索引。默认一周以周一为索引 0，周日为索引 6。\n\n\ndays_in_month：该月总共包含的天数（28–31）。\n\n\nimport calendar\n \n# 例如 2025 年 6 月\nfirst_weekday, days = calendar.monthrange(2025, 6)\nprint(first_weekday, days)\n# 输出 (6, 30)，表示 2025-06-01 是星期日（索引 6），该月有 30 天\n3.2 calendar.monthcalendar(year, month)：生成月视图的矩阵（嵌套列表）\n\n签名：monthcalendar(year, month) 返回一个由周列表组成的列表。每个子列表长度为 7，代表该周从周一到周日对应的日期数字，若该格不属于当月则填 0。\n\n例如，我们查看 2025 年 6 月的“月视图”：\nimport calendar\n \nmc = calendar.monthcalendar(2025, 6)\nfor week in mc:\n    print(week)\n输出：\n[0, 0, 0, 0, 0, 0, 1]\n[2, 3, 4, 5, 6, 7, 8]\n[9, 10, 11, 12, 13, 14, 15]\n[16, 17, 18, 19, 20, 21, 22]\n[23, 24, 25, 26, 27, 28, 29]\n[30, 0, 0, 0, 0, 0, 0]\n\n第一行 0–5 都是 0，表示 6 月的前几天不属于本月；最后一个元素是 1（2025-06-01 是星期日）。\n最后一行只有第一个元素 30 表示 6 月 30 日，后面是 0 填充。\n\n这种结构非常适合用于文本或图形化地绘制“月历表”。\n3.3 calendar.weekday(year, month, day)：获取某个日期对应的星期索引\n\n签名：weekday(year, month, day) 返回 0–6 的整数，表示该日期是周几（周一=0，…，周日=6）。\n\nimport calendar\n \nprint(calendar.weekday(2025, 6, 2))  # 输出 0，表示 2025-06-02 是星期一\n3.4 calendar.calendar(year, w=2, l=1, c=6, m=3)：生成整年日历的文本表示\n\n签名：\n\ncalendar.calendar(year, w=2, l=1, c=6, m=3)\n\n\nyear：年份\n\n\nw：每个日期字段的宽度（最少字符数，默认 2）\n\n\nl：每个月日历的行距（行与行之间的空行数，默认 1）\n\n\nc：每个月日历之间的列间距（默认 6 个空格）\n\n\nm：每行展示的月份数量（默认 3，即一年分为 4 行，每行 3 个月）\n\n\n返回值：一个多行的字符串，每行包含若干个月份并排的“文本日历”。\n\n\n示例打印 2025 年整年日历（文本形式）：\nimport calendar\n \nprint(calendar.calendar(2025))\n输出示例（节选）：\n                              2025\n \n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                        1  2      1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n...\n3.5 calendar.prmonth(year, month, w=2, l=1) 和 calendar.prcal(year)：直接打印而非返回字符串\n\nprmonth(year, month, w=2, l=1)：与 month(year, month) 类似，但直接向标准输出打印格式化后的当月日历（无返回值）。\nprcal(year)：向标准输出打印整年日历（无返回值）。\n\n示例：\nimport calendar\n \n# 打印 2025 年 6 月的文本日历\ncalendar.prmonth(2025, 6)\n输出：\n     June 2025\nMo Tu We Th Fr Sa Su\n                   1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30\n\n四、高级类：Calendar、TextCalendar、HTMLCalendar\n要对日历做更灵活的处理，比如自定义星期起始日、按某种顺序迭代日期、生成 HTML 格式日历等，可以使用以下类。\n4.1 calendar.Calendar：基础日历迭代器\n\n\n签名：Calendar(firstweekday=0)\n\n\nfirstweekday：一周从哪天开始，默认为 0（周一）。可用上述常量如 calendar.SUNDAY、calendar.MONDAY 等。\n\n\n4.1.1 方法\n\n**itermonthdays(year, month)**\n\n\n返回一个迭代器，依次产生当月日历格子中的“日期数字”或 0。与 monthcalendar() 类似，但不会分行，只会输出一维序列。\n例如：\n\nfrom calendar import Calendar\n \ncal = Calendar(firstweekday=calendar.SUNDAY)\ndays = list(cal.itermonthdays(2025, 6))\nprint(days)\n如果 firstweekday=SUNDAY，则 2025 年 6 月第一个格子是周日，序列可能类似：\n[1, 2, 3, 4, 5, 6, 7,    # 从第一个周日开始\n 8, 9, 10, ... 30,\n 0, 0, 0, 0, 0, 0]\n末尾的 0 补足了完整的六周日历格。\n\n**itermonthdays2(year, month)**\n\n\n类似于 itermonthdays，但每个元素都是 (day, weekday_index) 的二元组。如果该格不属于当月，则 day = 0。\n示例：\n\nfor day, wd in Calendar().itermonthdays2(2025, 6):\n    print(day, wd)\n# 例如 (0, 0) 表示某行的第一个格（周一）不属于当月；(1, 6) 表示 1 日是周日。\n\n**itermonthdates(year, month)**\n\n\n返回一个迭代器，依次产生当月网格中每一格对应的完整 datetime.date 对象。注意：如果格子不属于当月，date().month 可能是前一个月或下一个月。\n示例：\n\nfrom datetime import date\nfor d in Calendar().itermonthdates(2025, 6):\n    print(d, d.month)\n# 一旦 d.month != 6，就表示该格属于临近的上一月或下一月。\n\n**itermonthweeks(year, month)**\n\n\n生成 6 个子列表（每周一个列表），每个列表包含 7 个 (day, weekday_index) 元组，与 monthdays2calendar 相似，适合分行处理。\n\n\n**monthdayscalendar(year, month)**、**monthdays2calendar(year, month)**、**monthdatescalendar(year, month)**\n\n\n\n这三个方法分别返回：\n\n\nmonthdayscalendar：与 monthcalendar() 等价，返回嵌套列表，每项是 0 或日期数字。\n\n\nmonthdays2calendar：返回分行的列表，每个子列表元素为 (day, weekday_index)。\n\n\nmonthdatescalendar：返回分行的列表，每个子列表元素为对应的 date 对象。\n\n\n4.1.2 示例\nfrom calendar import Calendar\nfrom datetime import date\n \ncal = Calendar(firstweekday=calendar.MONDAY)\n \n# itermonthdays2 示例：打印 6 月各格日期与星期索引\nfor day, wd in cal.itermonthdays2(2025, 6):\n    if day == 0:\n        continue  # 跳过非当月格子\n    print(f&quot;2025-06-{day:02d} 是星期 {wd}（周一=0）&quot;)\n \n# itermonthdates 示例：打印 6 月完整网格日期\nfor d in cal.itermonthdates(2025, 6):\n    print(d, end=&quot; &quot;)\n# 输出样例：2025-05-26 2025-05-27 ... 2025-06-30 2025-07-01 ...\n4.2 calendar.TextCalendar：生成纯文本格式的月历或年历\n\n\n签名：TextCalendar(firstweekday=0)\n\n\n同样可指定 firstweekday，但方法返回的是已格式化的字符串。\n\n\n4.2.1 方法\n\n**formatmonth(year, month, w=0, l=0)**\n\n\n返回一个字符串，表示该年该月的纯文本日历，行宽 w（数字字段宽度，默认与系统当前宽度匹配）和行间距 l（月份标题与日期表之间的空行数，默认 0）。\n示例：\n\nfrom calendar import TextCalendar\n \ntc = TextCalendar()\ns = tc.formatmonth(2025, 6)\nprint(s)\n输出（默认 w=2, l=1）：\n   June 2025\nMo Tu We Th Fr Sa Su\n              1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30\n\n**formatyear(year, w=2, l=1, c=6, m=3)**\n\n\n返回一个字符串，表示整年日历的纯文本表示，与 calendar(year, w, l, c, m) 类似，但由类方法生成。\n示例：\n\nfrom calendar import TextCalendar\nyc = TextCalendar(firstweekday=calendar.SUNDAY)\nprint(yc.formatyear(2025))\n会展示从周日开始的一年 12 个月分布。\n\n**prmonth(year, month, w=0, l=0)**、**pryear(year, w=2, l=1, c=6, m=3)**\n\n\n与 formatmonth、formatyear 类似，但直接打印到标准输出，无返回值。\n\n4.3 calendar.HTMLCalendar：生成 HTML 格式的日历\n\n\n签名：HTMLCalendar(firstweekday=0)\n\n\n用于生成网页中可嵌入的 HTML &lt;table&gt; 结构日历。\n\n\n4.3.1 方法\n\n**formatmonth(year, month, withyear=True)**\n\n\n返回一个字符串，即完整的 HTML &lt;table&gt; 标签，包含当月日历。\n例子：\n\nfrom calendar import HTMLCalendar\nhc = HTMLCalendar()\nhtml = hc.formatmonth(2025, 6)\nprint(html)\n输出类似：\n&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; class=&quot;month&quot;&gt;\n&lt;tr&gt;&lt;th colspan=&quot;7&quot; class=&quot;month&quot;&gt;June 2025&lt;/th&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th class=&quot;mon&quot;&gt;Mon&lt;/th&gt;&lt;th class=&quot;tue&quot;&gt;Tue&lt;/th&gt; ... &lt;th class=&quot;sun&quot;&gt;Sun&lt;/th&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td class=&quot;noday&quot;&gt;&amp;nbsp;&lt;/td&gt; ... &lt;td class=&quot;day&quot;&gt;1&lt;/td&gt;&lt;/tr&gt;\n...\n&lt;/table&gt;\n\n可以通过 CSS 为类名（如 .month, .day, .noday）添加样式，实现网页日历的定制外观。\n\n\n**formatyear(year, width=3)**\n\n\n返回完整 HTML 表格，将一年的 12 个月按 width 列排列，每个月用一个小表格。\n例如 hc.formatyear(2025, width=4) 会按四列三行排列各个月。\n\n\n**formatweekday(i)**、**formatweekheader()**、**formatweek(week)** 等底层方法，用于自定义单个星期格的 HTML 结构。如果要扩展，覆写这些方法即可。\n\n4.4 calendar.LocaleTextCalendar 与 calendar.LocaleHTMLCalendar：本地化日历\n\n签名：\n\nLocaleTextCalendar(firstweekday=0, locale=None)\nLocaleHTMLCalendar(firstweekday=0, locale=None)\n\nlocale 参数为字符串，如 &#039;zh_CN.UTF-8&#039;、&#039;de_DE&#039; 或 None。\n当指定 locale，会使用相应的本地化设置，自动输出相应语言的月份名称与星期名称。\n\n示例（假设系统支持中文）：\nimport locale\nfrom calendar import LocaleTextCalendar\n \n# 切换到中文环境（需要系统安装相应 locale）\nlocale.setlocale(locale.LC_TIME, &#039;zh_CN.UTF-8&#039;)\n \nctc = LocaleTextCalendar(firstweekday=calendar.MONDAY, locale=&#039;zh_CN.UTF-8&#039;)\nprint(ctc.formatmonth(2025, 6))\n输出示例：\n      2025年6月\n周一 周二 周三 周四 周五 周六 周日\n                   1\n 2   3   4   5   6   7   8\n 9  10  11  12  13  14  15\n16  17  18  19  20  21  22\n23  24  25  26  27  28  29\n30\n\n五、区域设置（Locale）与本地化\ncalendar 模块的本地化主要依赖于 Python 的 locale 模块。通过修改进程级别的区域设置，可以让 calendar 输出符合本地语言和文化习惯的月份、星期名称。\n5.1 使用 locale 模块\nimport locale\nfrom calendar import TextCalendar, LocaleTextCalendar\n \n# 查询当前区域设置\nprint(locale.getdefaultlocale())  # e.g., (&#039;en_US&#039;, &#039;UTF-8&#039;)\n \n# 设置为中文（简体，UTF-8 编码）\nlocale.setlocale(locale.LC_TIME, &#039;zh_CN.UTF-8&#039;)\n \n# 直接用 TextCalendar 也会受到 SYSTEM LOCALE 的影响\ntc = TextCalendar(firstweekday=calendar.MONDAY)\nprint(tc.formatmonth(2025, 6))\n \n# 或者显式指定 LocaleTextCalendar\nctc = LocaleTextCalendar(firstweekday=calendar.SUNDAY, locale=&#039;zh_CN.UTF-8&#039;)\nprint(ctc.formatyear(2025))\n注意事项：\n\n在不同操作系统上，可用的 locale 名称不同。Linux/Unix 系统通常有完整的 xx_XX.UTF-8 列表；Windows 可能需要 &#039;Chinese_People&#039;s Republic of China.936&#039; 等形式。\n切换 locale 会影响整个 Python 进程对日期、时间、数字的格式化行为，务必谨慎。\n\n\n六、常见示例与应用场景\n6.1 判断当月天数与第一天星期\nimport calendar\n \ndef get_month_info(year, month):\n    first_wd, days = calendar.monthrange(year, month)\n    # 将 weekday 索引转换成字符串\n    weekday_name = calendar.day_name[first_wd]\n    return first_wd, weekday_name, days\n \nfw, wname, d = get_month_info(2025, 6)\nprint(f&quot;2025年6月第一天是星期 {fw}（{wname}），本月共有 {d} 天。&quot;)\n输出：\n2025年6月第一天是星期 6（Sunday），本月共有 30 天。\n6.2 以嵌套列表形式获取某月日期布局\nimport calendar\n \nyear, month = 2025, 6\nmc = calendar.monthcalendar(year, month)\nprint(f&quot;{year}年{month}月的月视图（0 表示空格）：&quot;)\nfor week in mc:\n    print(week)\n输出：\n2025年6月的月视图（0 表示空格）：\n[0, 0, 0, 0, 0, 0, 1]\n[2, 3, 4, 5, 6, 7, 8]\n[9, 10, 11, 12, 13, 14, 15]\n[16, 17, 18, 19, 20, 21, 22]\n[23, 24, 25, 26, 27, 28, 29]\n[30, 0, 0, 0, 0, 0, 0]\n6.3 生成 HTML 日历并嵌入网页\n假设需要将 2025 年 6 月的日历以 HTML 表格形式嵌入网页，可使用 HTMLCalendar：\nfrom calendar import HTMLCalendar\n \nhc = HTMLCalendar(firstweekday=calendar.MONDAY)\nhtml_calendar = hc.formatmonth(2025, 6)\n \n# 将 html_calendar 写入文件，或嵌入到 Web 框架模板中\nwith open(&#039;jun_2025_calendar.html&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    f.write(f&quot;&quot;&quot;\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=&quot;zh-CN&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n      &lt;title&gt;2025年6月日历&lt;/title&gt;\n      &lt;style&gt;\n        table {{ border-collapse: collapse; }}\n        .month {{ background-color: #f2f2f2; font-weight: bold; }}\n        .day {{ text-align: center; padding: 5px; border: 1px solid #ddd; }}\n        .noday {{ text-align: center; padding: 5px; border: 1px solid #ddd; background-color: #eaeaea; }}\n      &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      {html_calendar}\n    &lt;/body&gt;\n    &lt;/html&gt;\n    &quot;&quot;&quot;)\nprint(&quot;HTML 日历已生成：jun_2025_calendar.html&quot;)\n打开生成的文件即可看到美化后的月历。\n6.4 计算两日期之间的工作日数量\ncalendar 模块并没有直接提供计算两个日期之间工作日数量的函数，但可以利用 Calendar.itermonthdates() 或 monthcalendar() 再结合 datetime 来实现。示例：\nimport calendar\nfrom datetime import date\n \ndef workday_count(start_date, end_date, weekdays=(0,1,2,3,4)):\n    &quot;&quot;&quot;\n    计算从 start_date（含）到 end_date（含）之间，星期一(0)到星期五(4)这几个工作日的总数。\n    &quot;&quot;&quot;\n    if start_date &gt; end_date:\n        start_date, end_date = end_date, start_date\n \n    total = 0\n    curr = start_date\n    while curr &lt;= end_date:\n        if curr.weekday() in weekdays:\n            total += 1\n        curr = curr.fromordinal(curr.toordinal() + 1)\n    return total\n \n# 示例：2025-06-01 至 2025-06-30 之间的工作日数\ncnt = workday_count(date(2025, 6, 1), date(2025, 6, 30))\nprint(f&quot;2025-06-01 到 2025-06-30 之间共有 {cnt} 个工作日。&quot;)\n当然，如果要跨越多个月或更灵活，可以按月分批调用 monthcalendar()，根据每一周的列表判断哪些格子属于当月且 weekday_index&lt;5。\n\n七、常见注意事项与最佳实践\n\n**monthcalendar()** 的零填充\n\n\nmonthcalendar(year, month) 返回的列表中，若某个格子不属于当月会以 0 表示。使用时需过滤掉 0，否则在与实际日期做运算、显示时需判断。\n\n\n**firstweekday** 的选择\n\n\n默认一周从“星期一”开始（索引 0），但很多国家更习惯从“星期日”。可通过 calendar.setfirstweekday(calendar.SUNDAY) 改变全局设置，或在类实例化时显式指定。\n\n\n**LocaleTextCalendar** 依赖系统 **locale**\n\n\n如果你的系统没有安装对应的语言或区域设置，初始化会失败。可以先通过 locale.setlocale(locale.LC_TIME, &#039;zh_CN.UTF-8&#039;) 等在代码中切换，或者安装相应的 locale。\n\n\nHTML 日历的定制\n\n\nHTMLCalendar 生成的 HTML &lt;table&gt; 中使用了默认的 CSS 类名（.month, .day, .noday, .weekday 等）。如果要定制样式，只需在外部 CSS 中针对这些类名进行定义即可。\n\n\n跨年和多月计算时要注意年/月边界\n\n\n例如，用 itermonthdates() 会把前一月或下一月的日期也包含进来，需要用 date.month == target_month 来过滤。\n\n\n八、小结\n\n\n模块核心：主要包含与“闰年判断”（isleap、leapdays）和“日历生成/格式化”相关的函数与类。\n\n\n重要函数：\n\n\nisleap(year)、leapdays(y1, y2) → 闰年计算\n\n\nmonthrange(year, month) → 当月的第一天是周几、共多少天\n\n\nmonthcalendar(year, month) → 嵌套列表表示当月的日历布局\n\n\nweekday(year, month, day) → 返回某日对应星期索引\n\n\ncalendar(year, w, l, c, m) / prmonth / prcal → 文本日历输出\n\n\n主要类：\n\n\nCalendar, TextCalendar, HTMLCalendar → 可按需自定义一周起始日、得到结构化数据或生成文本/HTML 格式\n\n\nLocaleTextCalendar, LocaleHTMLCalendar → 本地化日历输出\n\n\n常见场景：\n\n\n需要在命令行或日志中打印一个月/一年的“图形化”日历\n\n\n在网页中嵌入日历控件或展示\n\n\n做报表时生成包含日期网格的表格\n\n\n判断闰年、计算跨年跨度的天数\n\n"},"python/2.常用库与工具/标准库与内置模块/时间与日期/datetime":{"slug":"python/2.常用库与工具/标准库与内置模块/时间与日期/datetime","filePath":"python/2.常用库与工具/标准库与内置模块/时间与日期/datetime.md","title":"datetime","links":[],"tags":[],"content":"概述\nPython 中的 datetime 模块是用于处理日期（date）和时间（time）的标准库，提供了一系列类和函数，帮助我们方便地进行日期和时间的表示、计算、解析、格式化以及时区（timezone）管理。与早期的 time 模块相比，datetime 模块更为面向对象、易于阅读和维护，并且统一了日期与时间的概念，使得相关操作更加直观。\n下面我们按照模块的组成部分、核心类及常用功能，逐步进行详细讲解，并配合示例代码以加深理解。\n\n模块结构概览\ndatetime 模块的核心类主要包括：\n\ndate：表示年月日（年、月、日）的类。\ntime：表示时分秒微秒（时、分、秒、微秒）的类，不含日期部分。\ndatetime：结合了 date 和 time，可以完整地表示某个时刻（年月日时分秒微秒）。\ntimedelta：表示两个日期/时间之间的时差（duration），可以进行加减运算。\ntzinfo（抽象基类）和 timezone（实现类）：用于处理时区信息，timezone 是 tzinfo 的子类，表示固定偏移的时区。\nstrptime() 与 strftime()：提供将字符串 ↔ 日期/时间对象之间相互转换的函数。\n\n除此以外，还有一些辅助的常量和函数，如 MINYEAR、MAXYEAR（支持的最小/最大年份），以及 date.today()、datetime.now() 等方便调用的类方法/函数。\n\n1. date 类\n1.1 定义与初始化\nfrom datetime import date\n \n# 创建一个 date 对象\nd = date(2025, 6, 2)   # 年：2025，月：6，日：2\n\ndate(year, month, day)：构造一个日期对象，年必须在 MINYEAR（1）和 MAXYEAR（9999）之间，月为 1–12，日根据对应月份决定（1–28/29/30/31）。\n\n1.2 常用属性\n假设有 d = date(2025, 6, 2)，则：\n\nd.year：年份（2025）\nd.month：月份（6）\nd.day：日（2）\nd.weekday()：返回星期几，Monday=0, …, Sunday=6。示例：date(2025, 6, 2).weekday() → 0（星期一）。\nd.isoweekday()：返回 ISO 标准下的星期几，Monday=1, …, Sunday=7。示例：date(2025, 6, 2).isoweekday() → 1。\nd.isoformat()：以字符串 &quot;YYYY-MM-DD&quot; 形式输出，比如 &quot;2025-06-02&quot;。\n\n1.3 类方法\n\ndate.today()：获取当前本地日期（不含时间部分）。\n\ntoday = date.today()\n\ndate.fromtimestamp(timestamp)：通过 Unix 时间戳（秒数）构造对应本地时间的日期部分。\n\nimport time\nts = time.time()             # 当前时间戳\nd = date.fromtimestamp(ts)   # 对应的本地日期\n\ndate.fromordinal(ordinal)：将格里高利历（Gregorian calendar）的序数（从 1 年 1 月 1 日算起的天数编号）转换为对应的 date 对象。\n\nd = date.fromordinal(737052)  # 对应 2025-06-02\n1.4 实例方法\n\nreplace(year=?, month=?, day=?)：返回一个修改了指定年月日后的新 date 对象。\n\nd = date(2025, 6, 2)\nd2 = d.replace(year=2024, month=12)  # 2024-12-02\n\ntimetuple()：将 date 转为类似 time.struct_time 的对象，常用于与老式的 time 模块配合。\ntoordinal()：将 date 转成序数（从 1 年 1 月 1 日起的天数），方便与 fromordinal() 互转。\nctime()：返回类似 &quot;Mon Jun 2 00:00:00 2025&quot; 的简易字符串，时间部分全部为 0。\n\n1.5 示例\nfrom datetime import date\n \n# 创建\nd = date(2025, 6, 2)\nprint(d.year, d.month, d.day)         # 2025 6 2\nprint(d.weekday(), d.isoweekday())     # 0 1\n \n# 今天的日期\ntoday = date.today()\nprint(today)                           # 例如 2025-06-02\n \n# 日期替换\nd2 = d.replace(day=15)\nprint(d2)                              # 2025-06-15\n \n# 与 timedelta 相加\nfrom datetime import timedelta\nd3 = d + timedelta(days=10)\nprint(d3)                              # 2025-06-12\n \n# 序数与 ordinal\nord_val = d.toordinal()\nprint(ord_val)                         # 737052\nd_from_ord = date.fromordinal(ord_val)\nprint(d_from_ord)                      # 2025-06-02\n\n2. time 类\ntime 类用于表示一天当中的时间，不包含日期部分。常见场景是需要单独存储时、分、秒、微秒，或与 datetime 组合。\n2.1 定义与初始化\nfrom datetime import time\n \n# 创建 time 对象\nt = time(14, 30, 15, 123456)  # 14:30:15.123456\n\n构造函数签名：time(hour, minute, second, microsecond, tzinfo=None, fold=0)。\nhour：0–23，minute：0–59，second：0–59，microsecond：0–999999。\n可选 tzinfo 用于指定时区信息（参见后文时区部分），fold 用于处理夏令时切换等歧义时刻。\n\n2.2 常用属性\n假设 t = time(14, 30, 15, 123456)：\n\nt.hour：获取小时（14）\nt.minute：获取分钟（30）\nt.second：获取秒（15）\nt.microsecond：获取微秒（123456）\nt.tzinfo：与之关联的时区信息，若未指定则为 None。\nt.isoformat()：字符串形式 &quot;HH:MM:SS.mmmmmm&quot;，例如 &quot;14:30:15.123456&quot;。\nt.replace(hour=?, minute=?, second=?, microsecond=? ...)：返回新的 time 对象，替换指定字段。\n\n2.3 注意事项\n\n由于 time 对象不含日期，因此不能直接与 timedelta 相加。若需要在某个日期基础上加减时间，需要先组合为 datetime 对象。\n\n2.4 示例\nfrom datetime import time\n \nt1 = time(9, 0)           # 09:00:00\nt2 = time(18, 45, 30)     # 18:45:30\nprint(t1, t2)             # 09:00:00 18:45:30\n \n# 带微秒\nt3 = time(23, 59, 59, 999999)\nprint(t3.isoformat())     # &quot;23:59:59.999999&quot;\n \n# 替换部分字段\nt4 = t2.replace(hour=19, minute=0)\nprint(t4)                 # 19:00:30\n\n3. datetime 类\ndatetime 类同时包含日期和时间，是日常开发中最常用的类。它支持完整的“年-月-日 时:分:秒.微秒”表示，并且可与 timedelta、时区结合使用。\n3.1 定义与初始化\nfrom datetime import datetime\n \ndt = datetime(2025, 6, 2, 14, 30, 15, 123456)\n\n构造函数签名：datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0)。\n如果只传前三个参数，则时间部分默认都是 0，对应某天的“0 点 0 分 0 秒”。\n\n3.2 获取当前时间\n\ndatetime.now(tz=None)：获取当前本地日期与时间（若提供 tz，则为对应时区下的当前时间）。\n\ndt1 = datetime.now()               # 本地时区，含年月日时分秒\ndt2 = datetime.now(tz=timezone.utc)  # UTC 时间\n\ndatetime.utcnow()：获取当前 UTC 时间的 datetime 对象（相当于 now(timezone.utc)，但 tzinfo 为 None，需注意时区歧义）。\ndatetime.today()：等价于 datetime.now()，但更侧重于返回“本地时间”的语义。\n\n3.3 常用属性\n假设有 dt = datetime(2025, 6, 2, 14, 30, 15, 123456)：\n\n\n与 date 共享属性：\n\n\ndt.year、dt.month、dt.day\n\n\ndt.weekday()、dt.isoweekday()、dt.isoformat()\n\n\n与 time 共享属性：\n\n\ndt.hour、dt.minute、dt.second、dt.microsecond\n\n\ndt.time()：返回对应的 time 对象（即 time(14, 30, 15, 123456)）。\n\n\ndt.date()：返回对应的 date 对象（即 date(2025, 6, 2)）。\n\n\ndt.tzinfo：关联的时区信息，若为 None 表示“天真时间”（naive datetime）。\n\n\ndt.fold：用于解决重叠时段（如夏令时倒退时刻）的问题，一般情况下不需要手动设置。\n\n\ndt.utcoffset() / dt.dst() / dt.tzname()：与时区相关的方法，返回与 UTC 的偏移（timedelta）、夏令时偏移以及时区名称。\n\n\n3.4 类方法\n\ndatetime.fromtimestamp(timestamp, tz=None)：通过 Unix 时间戳（秒）创建 datetime 对象。若指定 tz，则返回该时区下对应的本地时间；否则返回本地时区对应的“天真时间”。\n\nimport time\nts = time.time()\ndt_local = datetime.fromtimestamp(ts)                   # 本地时区\ndt_utc = datetime.fromtimestamp(ts, tz=timezone.utc)    # UTC\n\ndatetime.fromordinal(ordinal)：与 date.fromordinal 类似，但返回的时间部分默认为 0。\ndatetime.strptime(date_string, format)：将字符串解析为 datetime 对象，常用于将文本日期转换成可操作的对象。\n\ndt = datetime.strptime(&quot;2025-06-02 14:30:15&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)\n\ndatetime.combine(date_obj, time_obj, tzinfo=None)：由已存在的 date 与 time 组合成一个 datetime 对象。\n\nfrom datetime import date, time, datetime\nd = date(2025, 6, 2)\nt = time(8, 0, 0)\ndt = datetime.combine(d, t)   # 2025-06-02 08:00:00\n3.5 实例方法\n\nreplace(...)：类似于 date.replace，可替换其中的任意字段，返回新对象。\n\ndt = datetime(2025, 6, 2, 14, 30)\ndt2 = dt.replace(hour=9, minute=0)  # 2025-06-02 09:00:00\n\nastimezone(tz)：将该 datetime（必须是带 tzinfo 的“智慧”时间）转换到另一个时区下。\n\nfrom datetime import datetime, timezone, timedelta\ndt_utc = datetime(2025, 6, 2, 12, 0, tzinfo=timezone.utc)\ntz_shanghai = timezone(timedelta(hours=8))\ndt_sh = dt_utc.astimezone(tz_shanghai)  # 2025-06-02 20:00:00+08:00\n\ntimestamp()：返回一个浮点数，表示从 Unix 纪元（1970-01-01 00:00:00 UTC）到该时间点的秒数（可用于与 fromtimestamp 互转）。注意：若 datetime 是“天真”时间，则会先假设它是本地时间再换算到 UTC。\ntimetuple()、utctimetuple()：类似于 date.timetuple()，生成 time.struct_time 可与老式 time 模块结合。\n\n3.6 格式化与解析\n\n格式化（**strftime****）**将 datetime 对象转换为字符串，常用格式符号：\n\n%Y  四位数年份\n%m  两位数月份（01–12）\n%d  两位数日期（01–31）\n%H  24 小时制小时（00–23）\n%I  12 小时制小时（01–12）\n%M  两位数分钟（00–59）\n%S  两位数秒（00–59）\n%f  微秒（000000–999999）\n%a  本地化后的星期缩写（如 Mon）\n%A  本地化后的星期全称（如 Monday）\n%b  本地化后的月份缩写（如 Jun）\n%B  本地化后的月份全称（如 June）\n%p  AM/PM 标识\n%z  时区偏移（如 +0800）\n%Z  时区名称（如 CST）\n%j  年内第几天（001–366）\n%U  年内第几个星期（周日作为一周开始）（00–53）\n%W  年内第几个星期（周一作为一周开始）（00–53）\n例如：\nfrom datetime import datetime\ndt = datetime(2025, 6, 2, 14, 30, 15)\nformatted = dt.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)\n# formatted == &quot;2025-06-02 14:30:15&quot;\n\n解析（**strptime****）**将满足给定格式的字符串解析回 datetime 对象，需要保证字符串与格式完全匹配，否则会抛出 ValueError。\n\nfrom datetime import datetime\ns = &quot;2025-06-02 14:30:15&quot;\ndt = datetime.strptime(s, &quot;%Y-%m-%d %H:%M:%S&quot;)\n\n注意：strptime 会产生“天真”时间，若需要解析带时区标识（如 +08:00），在 Python 3.7+ 可以使用格式符 %z。例如：\n\ns2 = &quot;2025-06-02 14:30:15+0800&quot;\ndt2 = datetime.strptime(s2, &quot;%Y-%m-%d %H:%M:%S%z&quot;)\n# dt2.tzinfo == datetime.timezone(timedelta(hours=8))\n\n4. timedelta 类\n4.1 定义与初始化\ntimedelta 表示两个日期/时间之间的“持续时长”。可用于与 date、datetime 做加减运算。\nfrom datetime import timedelta\n \n# 创建一个时长对象\ntd1 = timedelta(days=5, hours=3, minutes=30, seconds=10)\n\n构造函数签名：timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)，各参数可叠加，最终内部会统一转换为天数、秒数和微秒数等表示。\n\n4.2 基本运算\n假设有 d = date(2025, 6, 2)，则：\n\nd + timedelta(days=10) → date(2025, 6, 12)\nd - timedelta(weeks=1) → date(2025, 5, 26)\n\n对于 datetime 对象：\nfrom datetime import datetime, timedelta\n \ndt = datetime(2025, 6, 2, 14, 30)\ndt2 = dt + timedelta(hours=2, minutes=15)\n# dt2 == datetime(2025, 6, 2, 16, 45)\n\n两个 datetime 相减，得到一个 timedelta：\n\ndt1 = datetime(2025, 6, 10, 0, 0)\ndt2 = datetime(2025, 6, 2, 12, 0)\ndiff = dt1 - dt2   # diff 是 timedelta(days=7, hours=12)\n4.3 属性与方法\n对于一个 timedelta 对象 td = timedelta(days=2, hours=5, minutes=10)：\n\ntd.days：天数部分（2）\ntd.seconds：剩余的秒数（5 小时 + 10 分钟 = 5_3600 + 10_60 = 18600 秒）\ntd.microseconds：微秒部分\ntd.total_seconds()：将整个 timedelta 转换为以秒为单位的浮点数（2 天 + 5 小时 + 10 分钟 → (2_86400 + 5_3600 + 10*60) = 189,000 秒）。\n\n4.4 注意事项\n\ntimedelta 不支持“月”或“年”的概念，因为它们并非固定时长（闰年、闰月等）。如需加减“一个月”或“一年”，需要结合业务逻辑手动处理，比如用 date.replace 或第三方库（如 dateutil.relativedelta）。\n\n\n5. 时区相关：tzinfo 与 timezone\n默认情况下，date、time、datetime 对象都属于“天真时间”（naive），即不含任何时区信息。若涉及时区（如从一个时区转换到另一个时区，或者表示 UTC 时间），就要添加 tzinfo。\n5.1 tzinfo 抽象基类\ntzinfo 是一个抽象基类，用于自定义时区。一般情况下，不需要直接继承它，而是使用内置的 timezone 或第三方库（如 pytz、dateutil）来获得更强大的时区支持。\n5.2 内置 timezone\n从 Python 3.2 开始，标准库提供了 datetime.timezone 类，用于表示固定偏移的时区（例如 UTC+8、UTC-5）。它继承自 tzinfo，主要用法如下：\nfrom datetime import datetime, timezone, timedelta\n \n# 定义一个 UTC+8 的时区\ntz_shanghai = timezone(timedelta(hours=8))\n \n# 创建一个带时区的 datetime\ndt = datetime(2025, 6, 2, 14, 30, tzinfo=tz_shanghai)\n \n# 打印\nprint(dt)                  # 2025-06-02 14:30:00+08:00\n \n# 将带时区的时间转换到另一个时区（如 UTC）\ndt_utc = dt.astimezone(timezone.utc)\nprint(dt_utc)             # 2025-06-02 06:30:00+00:00\n\ntimezone.utc：相当于 timezone(timedelta(0))，表示 UTC 时区。\nastimezone()：将“智慧时间”（aware datetime）从当前时区转换到目标时区。注意，只有带时区信息的 datetime 才能调用，否则会抛错。\n\n5.3 生成带时区的当前时间\n\ndatetime.now(timezone.utc)：获取当前 UTC 时间，tzinfo 为 UTC。\ndatetime.now(tz=timezone(timedelta(hours=8)))：获取当前 UTC+8 时间（比如北京时间/上海时间）。\ndatetime.utcnow()：仅获取当前 UTC 时间，但不带 tzinfo（天真时间），需小心使用；若想要带 tzinfo，应该使用 now(timezone.utc)。\n\n5.4 时区夏令时与第三方库\ndatetime.timezone 只能表示固定偏移，不会自动处理夏令时（DST）切换。如果需要处理复杂的时区（如美国各州的夏令时规则），建议使用第三方库：\n\n**pytz**（需单独安装）：提供了全量 IANA 时区数据库，且有 .localize()、.normalize() 等方法来处理 DST。\n**dateutil**（python-dateutil，需安装）：通过 dateutil.tz 提供的 gettz() 来获取本地或指定时区，也能自动调整夏令时。\n\n示例（以 dateutil 为例）：\nfrom datetime import datetime\nfrom dateutil import tz\n \n# 获取“America/New_York”时区对象\ntz_ny = tz.gettz(&quot;America/New_York&quot;)\n \n# 生成带时区的 datetime\ndt_ny = datetime(2025, 3, 9, 2, 30, tzinfo=tz_ny)\n# 2025 年 3 月 9 日凌晨 2:30 是美国开始夏令时的时刻，dateutil 会自动调整为 3:30\n \nprint(dt_ny)\n\n6. 常用操作与示例\n下面以一些具体场景示例来巩固对 datetime 模块的理解。\n6.1 获取当前日期和时间\nfrom datetime import date, datetime, timezone\n \n# 当前本地日期\ntoday = date.today()\nprint(&quot;Today:&quot;, today)               # 2025-06-02\n \n# 当前本地时间（天真时间）\nnow_local = datetime.now()\nprint(&quot;Now Local:&quot;, now_local)       # 2025-06-02 14:30:15.123456\n \n# 当前 UTC 时间（带 tzinfo）\nnow_utc = datetime.now(timezone.utc)\nprint(&quot;Now UTC:&quot;, now_utc)           # 2025-06-02 08:30:15.123456+00:00\n6.2 日期/时间算术\nfrom datetime import datetime, timedelta\n \ndt = datetime(2025, 6, 2, 14, 30)\n \n# 加 3 天 5 小时\ndelta = timedelta(days=3, hours=5)\ndt_new = dt + delta\nprint(dt_new)    # 2025-06-05 19:30\n \n# 计算两个 datetime 之间的差值\ndt1 = datetime(2025, 7, 1, 0, 0)\ndt2 = datetime(2025, 6, 2, 14, 30)\ndiff = dt1 - dt2\nprint(diff)      # e.g., 28 days, 9:30:00  （具体视时差而定）\nprint(&quot;Days:&quot;, diff.days)            # 28\nprint(&quot;Seconds:&quot;, diff.seconds)      # 34200  (9*3600 + 30*60)\n6.3 格式化（输出为字符串）\nfrom datetime import datetime\n \ndt = datetime(2025, 12, 31, 23, 59, 59)\n \n# 标准格式\ns1 = dt.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)\nprint(s1)       # &quot;2025-12-31 23:59:59&quot;\n \n# 自定义格式\ns2 = dt.strftime(&quot;今天是 %Y 年 %m 月 %d 日，时间：%I:%M %p&quot;)\n# 例如 “今天是 2025 年 12 月 31 日，时间：11:59 PM”\nprint(s2)\n6.4 解析（将字符串转成 datetime）\nfrom datetime import datetime\n \ns = &quot;2025/06/02 14-30-15&quot;\n# 注意格式要与字符串完全匹配\ndt_parsed = datetime.strptime(s, &quot;%Y/%m/%d %H-%M-%S&quot;)\nprint(dt_parsed)  # 2025-06-02 14:30:15\n6.5 时区转换示例\nfrom datetime import datetime, timedelta, timezone\n \n# 定义时区：UTC+8\ntz_sh = timezone(timedelta(hours=8))\n# 定义时区：UTC-4\ntz_ny = timezone(timedelta(hours=-4))\n \n# 本地化：创建一个带时区的 datetime（假定时间即为对应时区时间）\ndt_sh = datetime(2025, 6, 2, 12, 0, tzinfo=tz_sh)\nprint(&quot;Shanghai time:&quot;, dt_sh)  # 2025-06-02 12:00:00+08:00\n \n# 转换到纽约时间\ndt_ny = dt_sh.astimezone(tz_ny)\nprint(&quot;New York time:&quot;, dt_ny) # 2025-06-02 00:00:00-04:00\n \n# 将纽约时间转换回 UTC\ndt_utc = dt_ny.astimezone(timezone.utc)\nprint(&quot;UTC time:&quot;, dt_utc)     # 2025-06-02 04:00:00+00:00\n6.6 结合 dateutil 处理夏令时\n如果不想手动维护各地时区、夏令时切换规则，可使用 python-dateutil：\nfrom datetime import datetime\nfrom dateutil import tz\n \n# 指定时区\ntz_ny = tz.gettz(&quot;America/New_York&quot;)\n \n# 创建一个“天真时间”并赋予 tzinfo\ndt_ny = datetime(2025, 11, 2, 1, 30)  # 注意：11 月初有可能正是夏令时切换的时段\ndt_ny = dt_ny.replace(tzinfo=tz_ny)\n \nprint(dt_ny)  \n# 如果 2025-11-02 1:30 对应的时间是夏令时向标准时切换时，dateutil 会自动判断 fold=1 或 fold=0。\n\n7. 常见注意事项与最佳实践\n\n天真时间（Naive） vs. 智慧时间（Aware）\n\n\n天真时间（naive datetime）：没有 tzinfo，只能做本地（或假定统一）时间计算，无法安全地进行跨时区运算。\n智慧时间（aware datetime）：包含 tzinfo，可进行不同时区之间的准确转换。\n建议：在涉及时区或跨时区业务时，尽量使用“智慧时间”；若只是本地简单应用，也可保留“天真时间”。\n\n\n不要直接手动构造夏令时切换时刻\n\n\n当构造某个处于夏令时切换边界的时间时，若只用 timezone(timedelta(...))，无法检测夏令时；如需准确转换，使用 pytz 或 dateutil。\n\n\n避免随意使用 **datetime.utcnow()**\n\n\ndatetime.utcnow() 返回“天真”的 UTC 时间，如果随后与本地时间做比较，容易引起混淆。推荐使用 datetime.now(timezone.utc)，返回带 tzinfo 的 UTC 时间。\n\n\n在解析/格式化时，保证格式字符串与实际字符串完全匹配\n\n\nstrptime 对格式十分严格，一旦有多余空格或符号不同，就会报错。\n\n\n留意 **timedelta** 的范围\n\n\ntimedelta 支持的最大天数是 999999999（即大约 2.7 亿年），但在业务中更常见的“年”和“月”概念，需要自行处理或依赖第三方库。\n\n\n8. 小结与示例演练\n下面给出一个综合示例：\n需求：读取一个用户输入的本地时间字符串，格式为 &quot;YYYY-MM-DD HH:MM&quot;，假定它是中国上海时间，然后将其转换为对应的 UTC 时间，并输出两种格式：&quot;YYYY/MM/DD HH:MM:SS UTC&quot; 以及 ISO 8601（带时区偏移）。\nfrom datetime import datetime, timezone, timedelta\n \n# 1. 用户输入的字符串\ninput_str = &quot;2025-06-02 20:45&quot;\n \n# 2. 解析为天真时间\ndt_naive = datetime.strptime(input_str, &quot;%Y-%m-%d %H:%M&quot;)\n# 3. 假设这是上海时间（UTC+8），将 tzinfo 设为 UTC+8\ntz_sh = timezone(timedelta(hours=8))\ndt_sh = dt_naive.replace(tzinfo=tz_sh)\n# 4. 转换为 UTC\ndt_utc = dt_sh.astimezone(timezone.utc)\n \n# 5. 格式化输出\n# 5.1 格式一： &quot;YYYY/MM/DD HH:MM:SS UTC&quot;\ns1 = dt_utc.strftime(&quot;%Y/%m/%d %H:%M:%S UTC&quot;)\nprint(s1)  # 如 &quot;2025/06/02 12:45:00 UTC&quot;\n \n# 5.2 ISO 8601 格式（datetime.isoformat() 会自动加上时区偏移）\ns2 = dt_sh.isoformat()  # e.g. &quot;2025-06-02T20:45:00+08:00&quot;\nprint(s2)\n运行效果示例：\n2025/06/02 12:45:00 UTC\n2025-06-02T20:45:00+08:00\n这个示例展示了从字符串解析到时区标记、再到 UTC 转换、最后格式化输出的完整流程。在实际应用中，类似的操作非常常见，比如日志文件时间统一、跨时区事件调度等。\n\n9. 额外扩展：与老式 time 模块的区别\n\ntime.time() 返回自 Unix 纪元（1970-01-01 00:00:00 UTC）以来的秒数（浮点数）；而对应的 datetime.fromtimestamp() 则可将其转为更易读的 datetime 对象。\ntime.localtime()、time.gmtime() 返回 struct_time，而 datetime 能直接提供面向对象的操作方式。\n若需要高性能计算时间戳，常保留 time 模块做底层调用；但对于日常业务逻辑，推荐使用 datetime 的方法。\n\n\n10. 小结\n\n核心类：date、time、datetime、timedelta、tzinfo/timezone。\n常见算术：使用 timedelta 来加减 date/datetime。\n格式化与解析：strftime 输出为字符串，strptime 将字符串解析为对象，格式符号需严格匹配。\n时区管理：内置 timezone 可处理固定偏移；对复杂时区需求，建议借助 pytz 或 dateutil。\n注意：区分“天真时间”（naive）与“智慧时间”（aware），尽量避免混用，尤其在跨时区场景下。\n"},"python/2.常用库与工具/标准库与内置模块/时间与日期/time":{"slug":"python/2.常用库与工具/标准库与内置模块/时间与日期/time","filePath":"python/2.常用库与工具/标准库与内置模块/时间与日期/time.md","title":"time","links":[],"tags":[],"content":"概述\nPython 的 time 模块是与操作系统交互的底层时间接口，提供了访问系统时钟、时间戳、休眠、格式化/解析时间字符串等功能。相比于更高级的 datetime 模块，time 更接近操作系统层面，主要以 UNIX 时间戳（自 1970 年 1 月 1 日 00:00:00 UTC 起的秒数）和 struct_time 结构为基础，适合进行更原始、轻量级的时间测量与转换。下面将从模块结构、核心常量与函数、struct_time 结构、系统时钟、格式化与解析、休眠与性能计时等方面，进行详细讲解，并辅以示例代码。\n\n1. 模块常量与数据结构\n1.1 常量\n\ntime.timezone：表示本地时区与 UTC 时区之间的偏移（以秒为单位）。如果在夏令时期间，需结合 time.altzone 使用。\ntime.altzone：夏令时（DST）时，本地时区与 UTC 之间的偏移（以秒）。\ntime.daylight：如果系统支持夏令时，并且当前日期属于夏令时，则值为 1，否则为 0。\ntime.tzname：长度为 2 的元组，分别表示非夏令时和夏令时下的时区名称，例如 (&#039;CST&#039;, &#039;CDT&#039;)。\ntime.CLOCK_REALTIME、time.CLOCK_MONOTONIC、time.CLOCK_PROCESS_CPUTIME_ID、time.CLOCK_THREAD_CPUTIME_ID 等：在支持的系统上，可用于调用更底层的 time.clock_gettime() 函数，获取不同类型的时钟。并非所有平台都支持所有钟源，要根据实际环境查看。\n\n1.2 struct_time 结构\n许多 time 函数会返回或接收一个 struct_time 对象，这是一个类似命名元组的结构，包含 9 个字段，分别表示：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n索引属性名含义取值范围0tm_year年份≥ 19001tm_mon月（1–12）1–122tm_mday今日在月份中的天数1–313tm_hour小时（0–23）0–234tm_min分（0–59）0–595tm_sec秒（0–61）0–61（包括闰秒）6tm_wday星期几（周一–周日）0–6（其中 0 代表周一）7tm_yday年内第几天1–3668tm_isdst是否为夏令时（Daylight Saving Time）0（否）、1（是）、-1（未知）\nstruct_time 在打印时会以类似如下形式呈现：\ntime.struct_time(tm_year=2025, tm_mon=6, tm_mday=2, tm_hour=14, tm_min=30, tm_sec=15, tm_wday=0, tm_yday=153, tm_isdst=0)\n\n2. 时间戳与系统时钟\n2.1 time.time()\n\n功能：返回当前系统时间的“Unix 时间戳”（浮点数），从 1970-01-01 00:00:00 UTC 起所经过的秒数。\n精度：根据系统不同，通常精度到微秒（浮点数的小数部分），但底层调用可能因平台而异。\n\nimport time\n \nts = time.time()\nprint(&quot;当前时间戳：&quot;, ts)   # 类似 173,056,3415.123456\n\n\n常用场景：\n\n\n计算代码执行时间：记录前后时间戳之差。\n\n\n生成代表当前时间的唯一 ID（结合毫秒、随机数等）。\n\n\n与其他系统（如 Unix）交换时间数据。\n\n\n2.2 time.perf_counter()\n\n功能：返回一个高精度、低延迟的计时器值，适合测量短时间内的时间间隔。它包括了系统睡眠时间，但不一定以 UTC 为基准。\n特点：时钟单调上升（monotonic），不会因系统时间调整（如 NTP 校准）而倒退。\n典型用法：\n\nimport time\n \nstart = time.perf_counter()\n# 执行某段耗时操作\ntime.sleep(1.5)\nend = time.perf_counter()\nprint(&quot;耗时：&quot;, end - start, &quot;秒&quot;)  # 接近 1.5\n2.3 time.process_time()\n\n功能：返回当前进程在 CPU 上所消耗的时间，精度高，适合测量 CPU 计算消耗，而不包括进程睡眠或等待 I/O 的时间。\n特点：同样单调递增，但只计入进程运行的 CPU 时间，不受系统时钟调整影响。\n场景：当你只关心代码对 CPU 的占用，比如在性能分析时，用来衡量算法的纯计算开销。\n\nimport time\n \nstart_cpu = time.process_time()\n# 执行纯计算任务\nfor _ in range(10**6):\n    pass\nend_cpu = time.process_time()\nprint(&quot;CPU 消耗时间：&quot;, end_cpu - start_cpu, &quot;秒&quot;)\n2.4 time.monotonic()\n\n功能：返回操作系统提供的单调递增的时钟值，用于测量绝对时间间隔。与 perf_counter() 类似，但不一定包含睡眠时间。这两者可根据平台差异选择。\n特点：同样保证单调性，不会因系统时间回拨而影响，非常适合做超时判断或测量间隔。\n\nimport time\n \nstart = time.monotonic()\ntime.sleep(0.2)\nend = time.monotonic()\nprint(&quot;单调时钟间隔：&quot;, end - start)\n2.5 time.clock_gettime() / time.clock_settime()\n\n这两个函数允许你以指定时钟源读取或设置系统时钟。典型用法（Linux/Unix 系统）：\n\nimport time\n \n# 读取 CLOCK_REALTIME（系统实时时钟）\nnow_realtime = time.clock_gettime(time.CLOCK_REALTIME)\nprint(&quot;系统实时时钟：&quot;, now_realtime)\n \n# 读取 CLOCK_MONOTONIC（单调时钟）\nnow_mono = time.clock_gettime(time.CLOCK_MONOTONIC)\nprint(&quot;单调时钟：&quot;, now_mono)\n\n注意：并非所有操作系统都支持所有时钟源，需要捕获 AttributeError 或查阅平台说明。\n\n\n3. 时间转换与格式化\ntime 模块提供了一组将“时间戳 ↔ struct_time ↔ 字符串”相互转换的函数。主要包括以下几类：\n3.1 时间戳 ↔ struct_time\n\ntime.gmtime([secs])：将以秒数表示的时间戳（默认当前时间）转换为 UTC（格林尼治标准时间）的 struct_time。\ntime.localtime([secs])：将时间戳转换为本地时区下的 struct_time。\ntime.mktime(t)：将本地时区下的 struct_time（或元组）转换回时间戳。\n\n示例：\nimport time\n \n# 获取当前时间的 UTC struct_time\nutc_tm = time.gmtime()\nprint(&quot;UTC struct_time:&quot;, utc_tm)\n \n# 获取当前时间的本地 struct_time\nloc_tm = time.localtime()\nprint(&quot;Local struct_time:&quot;, loc_tm)\n \n# 将自定义的 struct_time 转回时间戳\ncustom = time.struct_time((2025, 6, 2, 14, 30, 0, 0, 0, -1))\nts = time.mktime(custom)  # 注意 mktime 默认认为 t 为本地时间\nprint(&quot;自定义 struct_time 对应的本地时间戳：&quot;, ts)\n\n注意：time.mktime() 期望输入的 struct_time 是本地时区下的时间，如果输入一个在 DST 状态改变时刻的 struct_time，会导致 tm_isdst 冲突，此时 mktime 会根据 tm_isdst 决定输出。\n\n3.2 strftime(format, t)：格式化\n\n\n功能：将一个 struct_time（或当前时间）格式化为字符串，格式由 format 参数指定，常用格式化符号与 datetime.strftime 相同。\n\n\n签名：time.strftime(format[, t])\n\n\n如果不提供 t 参数，则默认使用当前本地时间（等同于 time.localtime()）。\n\n\nimport time\n \n# 当前本地时间格式化\ns1 = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())\nprint(&quot;当前本地时间：&quot;, s1)\n \n# 指定 GMT 时间格式化\ns2 = time.strftime(&quot;%a, %d %b %Y %H:%M:%S +0000&quot;, time.gmtime())\n# 类似 &quot;Mon, 02 Jun 2025 14:30:00 +0000&quot;\nprint(&quot;当前 UTC 时间：&quot;, s2)\n常用格式化符号（与 datetime 基本一致）：\n\n%Y：四位数年份（例如 2025）\n%m：两位数月份（01–12）\n%d：两位数日（01–31）\n%H：24 小时小时（00–23）\n%I：12 小时制小时（01–12）\n%M：分钟（00–59）\n%S：秒（00–59）\n%f：微秒（仅 Python 3.6+，需要使用 datetime 模块来获取微秒部分）\n%a / %A：本地化星期缩写 / 全称\n%b / %B：本地化月份缩写 / 全称\n%p：本地化的 AM/PM 标识\n%z / %Z：时区偏移 / 时区名称\n%j：年内第几天（001–366）\n%U / %W：年内第几周（分别以周日 / 周一 作为一周的第一天）\n\n3.3 strptime(string, format)：解析\n\n功能：将符合指定格式的时间字符串解析为 struct_time。\n签名：time.strptime(string, format)\n\nimport time\n \ns = &quot;2025-06-02 14:30:15&quot;\ntm = time.strptime(s, &quot;%Y-%m-%d %H:%M:%S&quot;)\nprint(&quot;解析后的 struct_time：&quot;, tm)\n# 若需转换为时间戳：\nts = time.mktime(tm)\nprint(&quot;对应本地时间戳：&quot;, ts)\n\n\n注意事项：\n\n\n如果字符串与格式不完全匹配，会抛出 ValueError。\n\n\nstrptime 仅解析到秒级别，不能直接得到微秒。\n\n\n解析后的 tm_isdst 字段会根据当前时区与日期自动填充（0/1/-1）；如果要强制指定，可在字符串中加入 %z 来解析时区偏移（如 +0800），但在某些平台上可能有限制。\n\n\n\n4. 休眠与暂停\n4.1 time.sleep(secs)\n\n功能：让当前线程/进程暂停运行至少 secs 秒（可以是浮点数），秒数作为睡眠时长。\n签名：time.sleep(secs)\n\nimport time\n \nprint(&quot;开始休眠&quot;)\ntime.sleep(2.5)   # 暂停 2.5 秒\nprint(&quot;休眠结束&quot;)\n\n\n注意：\n\n\n如果在多线程环境下，sleep 只会暂停当前线程，不会影响其他线程运行。\n\n\n如果在子进程中使用，会暂停该子进程对应的线程。\n\n\nsleep 的精度受操作系统调度和 Python GIL 影响，实际可能略大于指定的秒数。\n\n\n\n5. 时区与本地化\n虽然 time 模块没有像 datetime 那样提供完整的时区类，但也可以通过以下属性与函数来查询系统时区信息并进行简单转换。\n5.1 时区常量\n\ntime.timezone：在非夏令时（tm_isdst == 0）情况下，本地时间与 UTC 时间之间的偏移秒数（通常为负值，表示 UTC 落后本地）。\ntime.altzone：在夏令时（tm_isdst == 1）情况下，本地时间与 UTC 之间的偏移秒数。\ntime.daylight：系统是否支持夏令时（1 表示支持，0 表示不支持）。\ntime.tzname：一个包含两个字符串的元组，分别对应非夏令时和夏令时下的本地时区名称，如 (&#039;CST&#039;, &#039;CDT&#039;)。\n\nimport time\n \nprint(&quot;time.timezone:&quot;, time.timezone)   # 例如  -21600，表示 UTC-6 小时（美国中部标准时）\nprint(&quot;time.altzone:&quot;, time.altzone)     # 例如  -18000，表示夏令时 UTC-5\nprint(&quot;time.daylight:&quot;, time.daylight)   # 1 表示支持夏令时\nprint(&quot;time.tzname:&quot;, time.tzname)       # (&#039;CST&#039;, &#039;CDT&#039;)\n\n\n理解偏移值：\n\n\n如果本地时区是 UTC-6（北美中部标准时，CST），则 time.timezone == 6 * 3600 = 21600。在 Python 中返回的是“与 UTC 的差值”，即 -21600（因为本地时间 = UTC 时间 − 6 小时）。\n\n\n当进入夏令时时段，偏移会变为 -18000（UTC-5），对应 time.altzone。\n\n\n5.2 time.tzset()\n\n功能：仅在 Unix/Linux 系统上可用。根据环境变量 TZ（时区）重新初始化时区设置，使得 time.localtime()、time.gmtime()、time.timezone 等常量依据新的 TZ 生效。\n示例：\n\nimport os, time\n \n# 假设系统默认为本地时区，美国中部时区\nprint(&quot;原始时区名称：&quot;, time.tzname)\n \n# 临时切换到东京时区（UTC+9）\nos.environ[&#039;TZ&#039;] = &#039;Asia/Tokyo&#039;\ntime.tzset()\nprint(&quot;切换后时区名称：&quot;, time.tzname)\nprint(&quot;当地时间：&quot;, time.localtime())\n \n# 恢复原时区\nos.environ.pop(&#039;TZ&#039;, None)\ntime.tzset()\nprint(&quot;恢复时区名称：&quot;, time.tzname)\n\n\n注意：\n\n\nWindows 平台没有 tzset()，在 Windows 上修改时区需通过系统设置或使用其他库（如 dateutil、pytz）。\n\n\n\n6. 进程/线程 CPU 时间与用户/系统 CPU 时间\n6.1 time.process_time()\n（已在 2.3 节介绍）衡量当前进程在 CPU 上消耗的时间。分为用户态和内核态总和，不包括睡眠与 I/O 等等待时间，无法单独获取用户态与内核态。\n6.2 time.thread_time()（Python 3.7+）\n\n功能：返回当前线程占用的 CPU 时间，仅包括本线程使用的 CPU 资源，不包括其他线程。与 process_time() 类似，但细粒度到线程。\n示例：\n\nimport time\n \nstart_thread = time.thread_time()\n# 在当前线程内运行一些逻辑\nfor _ in range(10**6):\n    pass\nend_thread = time.thread_time()\nprint(&quot;当前线程 CPU 时间：&quot;, end_thread - start_thread, &quot;秒&quot;)\n\n注意：只有在支持的操作系统与 Python 版本中可用，否则会抛出 AttributeError。\n\n\n7. 其他实用函数\n7.1 time.ctime([secs])\n\n功能：将给定的时间戳（秒）转换成一个可读的字符串形式，格式类似 &quot;Mon Jun 2 14:30:15 2025&quot;。如果不提供参数 secs，则使用当前时间戳。\n示例：\n\nimport time\n \nprint(time.ctime())            # 当前时间的可读字符串\nprint(time.ctime(0))           # &quot;Thu Jan  1 00:00:00 1970&quot;（UTC/GMT）\n7.2 time.asctime([t])\n\n功能：将给定的 struct_time 转换成易读字符串，等效于 ctime(mktime(t))，如果不传 t 则使用 localtime()。\n示例：\n\nimport time\n \nt = time.localtime()\nprint(time.asctime(t))  # &quot;Mon Jun  2 14:30:15 2025&quot;\n7.3 time.tzname、time.daylight、time.timezone、time.altzone\n（已在 5.1 节详细说明）\n\n8. 综合示例\n下面展示一个小示例，集成多个 time 模块功能，演示如何获取当前时间、格式化、休眠、以及测量函数执行时间。\nimport time\n \ndef demo_time_module():\n    # 1. 获取当前本地时间戳与 UTC 时间戳\n    ts_local = time.time()\n    print(&quot;当前本地时间戳：&quot;, ts_local)\n \n    # 2. 将时间戳转换为 struct_time（本地与 UTC）\n    local_tm = time.localtime(ts_local)\n    utc_tm = time.gmtime(ts_local)\n    print(&quot;本地 struct_time：&quot;, local_tm)\n    print(&quot;UTC struct_time：&quot;, utc_tm)\n \n    # 3. 格式化为易读字符串\n    s1 = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, local_tm)\n    s2 = time.strftime(&quot;%a, %d %b %Y %H:%M:%S +0000&quot;, utc_tm)\n    print(&quot;本地格式化时间：&quot;, s1)\n    print(&quot;UTC 格式化时间：&quot;, s2)\n \n    # 4. 计算某段函数执行时间（使用 perf_counter）\n    start = time.perf_counter()\n    time.sleep(1.2)  # 模拟耗时操作\n    elapsed = time.perf_counter() - start\n    print(f&quot;模拟操作耗时：{elapsed:.5f} 秒&quot;)\n \n    # 5. 测量当前进程 CPU 占用（非常短，主要演示用法）\n    start_cpu = time.process_time()\n    # 一些 CPU 计算\n    _ = sum(i*i for i in range(1000000))\n    cpu_used = time.process_time() - start_cpu\n    print(f&quot;CPU 占用时间：{cpu_used:.5f} 秒&quot;)\n \n    # 6. 演示 struct_time ↔ 时间戳 ↔ 字符串 ↔ mktime\n    t_str = &quot;2025-06-02 18:45:00&quot;\n    # 6.1 解析字符串到 struct_time\n    tm_parsed = time.strptime(t_str, &quot;%Y-%m-%d %H:%M:%S&quot;)\n    # 6.2 struct_time 转 时间戳（本地时区）\n    ts_parsed = time.mktime(tm_parsed)\n    print(f&quot;字符串“{t_str}”对应本地时间戳：{ts_parsed}&quot;)\n \n    # 6.3 再转回 struct_time（本地）\n    tm_back = time.localtime(ts_parsed)\n    print(&quot;转回 struct_time：&quot;, tm_back)\n \n    # 6.4 asctime / ctime 演示\n    print(&quot;asctime：&quot;, time.asctime(tm_back))\n    print(&quot;ctime：&quot;, time.ctime(ts_parsed))\n \n    # 7. 时区信息\n    print(&quot;当前时区名称：&quot;, time.tzname)\n    print(&quot;是否启用夏令时：&quot;, bool(time.daylight))\n    offset = -time.timezone if time.localtime().tm_isdst == 0 else -time.altzone\n    # 计算当前偏移小时数\n    print(&quot;当前与 UTC 偏移：&quot;, offset / 3600, &quot;小时&quot;)\n \nif __name__ == &quot;__main__&quot;:\n    demo_time_module()\n说明：\n\n通过 time.time() 获取当前时间戳。\n使用 localtime() 和 gmtime() 分别获得本地和 UTC 对应的 struct_time。\nstrftime 用于将 struct_time 格式化成字符串。\nperf_counter() 测量真实经过时间，包括 sleep 等休眠时长，适合作精准的代码段耗时统计。\nprocess_time() 测量 CPU 时间，仅关注代码在 CPU 上实际运行的时间。\n解析字符串 time.strptime()，再用 time.mktime() 得到本地时间戳，最后验证转换无误。\ntime.tzname、time.daylight、time.timezone/time.altzone 用于查询当前系统时区信息，并计算与 UTC 的偏移小时数。\n\n\n9. 注意事项与最佳实践\n\n秒级 vs. 高精度计时\n\n\n如果只需获取当前时间戳或进行基本转换，使用 time.time() 即可。\n若要做性能测试或计算耗时，建议使用 time.perf_counter() 或 time.monotonic()，避免系统时钟调整造成干扰。\n如果关心的是当前进程或线程的 CPU 占用时间，使用 time.process_time() 或 time.thread_time()。\n\n\n**sleep()** 精度\n\n\ntime.sleep() 会让当前线程暂停至少指定时长，实际精度受操作系统调度影响，有可能比指定时长稍长。对于高精度定时任务，可以结合 monotonic() 循环判断。\n\n\n**struct_time** 与时区\n\n\ntime.localtime() 返回的 struct_time 带有 tm_isdst 字段，可以反映当前是否处于夏令时；但如果自己手动构造 struct_time，应合理设置 tm_isdst，否则在 mktime() 转换时可能得到意外结果。\nWindows 平台不支持 time.tzset()，若需要跨平台的时区转换，建议使用 datetime 和第三方库 pytz/dateutil。\n\n\n**strptime** 性能\n\n\ntime.strptime 每次都会重新编译格式化字符串，在需要大量解析的场景下会较慢。可以考虑先用 datetime.strptime 然后转换，或缓存编译好的格式化对象，或使用第三方库（如 ciso8601）加速。\n\n\n跨平台兼容\n\n\n并非所有 Python 版本或操作系统都支持 clock_gettime、thread_time 等函数，编写可移植代码时应先 hasattr(time, &#039;XXX&#039;) 判断可用性，再使用。\nPython 3.10+ 对 time 模块功能进行了进一步强化和优化，若使用旧版本，请参阅对应版本文档。\n\n\n小结\n\n\n核心用途：\n\n\n获取当前时间戳：time.time()\n\n\n将时间戳转换为可读结构或字符串：localtime()、gmtime()、strftime()、asctime()、ctime()\n\n\n将字符串解析或结构转换为时间戳：strptime()、mktime()\n\n\n线程暂停：sleep()\n\n\n精准计时：perf_counter()、monotonic()、process_time()、thread_time()\n\n\n查询时区与夏令时信息：timezone、altzone、daylight、tzname、tzset()（Unix）\n\n\n适用场景：\n\n\n需要与操作系统底层时钟交互、生成 UNIX 时间戳、在多线程环境下短暂暂停、对代码性能做微秒级或毫秒级测量时，使用 time 模块更为直接高效。\n\n\n对于更高级的日期与时间处理（如日期算术、时区转换、格式化大量日期、微秒级别操作），则推荐使用 datetime 模块结合第三方库。\n\n"},"python/2.常用库与工具/标准库与内置模块/时间与日期/zoneinfo":{"slug":"python/2.常用库与工具/标准库与内置模块/时间与日期/zoneinfo","filePath":"python/2.常用库与工具/标准库与内置模块/时间与日期/zoneinfo.md","title":"zoneinfo","links":[],"tags":[],"content":"一、模块背景与设计\n1. 为什么需要 zoneinfo\n在 Python 引入 zoneinfo 之前，最常见的时区处理方式往往依赖于第三方库 pytz 或 dateutil.tz：\n\n**pytz**：要求用 localize()/normalize() 建立“感知时区”（aware）datetime，语法相对冗杂，并且容易出错。\n**dateutil.tz**：虽然比 pytz 简洁，但依赖外部 dateutil 包，且其时区数据库更新依赖包本身更新。\n\nPython 3.9+ 的 zoneinfo 将时区功能纳入标准库，带来的好处包括：\n\n零依赖：不需要额外安装第三方包。\n实时更新：只要系统或 Python 环境中安装了最新 tzdata，zoneinfo 就可以直接使用最新的时区变化。\n与 **datetime** API 设计一致：不需要像 pytz 那样调用 localize()，而是通过给 datetime 传递带时区信息的 ZoneInfo 对象即可。\n\n2. 时区数据来源\nzoneinfo 依赖 IANA 时区数据库（tzdata），具体来源有两种途径：\n\n系统自带的 tzdata：在 Linux、macOS 等系统中，往往会预装 /usr/share/zoneinfo，Python 在创建 ZoneInfo(&quot;Asia/Shanghai&quot;) 时会从这里读取对应的二进制时区规则。\n纯 Python 包 tzdata：对于某些不自带 tzdata 的发行版（比如 Windows），Python 也可以通过安装官方的 tzdata 包（同名纯数据包），将数据放在 Lib/zoneinfo 下，让 zoneinfo 能正常使用。这种场景下，先 pip install tzdata，即可在 Windows 下使用任何 IANA 时区。\n\n\n二、核心类和 API\n1. ZoneInfo 类\nzoneinfo.ZoneInfo 是模块的核心类，表示一个时区，内部封装了该时区历年的转换规则。构造方法如下：\nfrom zoneinfo import ZoneInfo\n \n# 示例：创建一个表示“上海”时区的 ZoneInfo 对象\nzi = ZoneInfo(&quot;Asia/Shanghai&quot;)\n\n参数：时区名称，必须符合 IANA tzdata 标准格式，比如 &quot;Europe/London&quot;、&quot;America/New_York&quot;、&quot;UTC&quot;、&quot;Asia/Shanghai&quot; 等等。\n返回值：一个 “tzinfo” 类的实例，满足 datetime 的 tzinfo 接口，用于赋给 datetime 对象。\n\n如果传入的时区名称在本地 tzdata 中不存在，则会抛出一个 zoneinfo.ZoneInfoNotFoundError 异常，需要根据需求进行捕获并作备用处理。\n2. ZoneInfoNotFoundError\n当指定的时区名称无法在本地数据源中找到时会抛出该异常。例如，系统没有安装相应时区数据，或者拼写错误，都可能触发此错误。可以通过捕获并作降级，例如使用 &quot;UTC&quot; 或 &quot;GMT&quot; 作为兜底：\nfrom zoneinfo import ZoneInfo, ZoneInfoNotFoundError\n \ntry:\n    tz_tokyo = ZoneInfo(&quot;Asia/Tokyo&quot;)\nexcept ZoneInfoNotFoundError:\n    tz_tokyo = ZoneInfo(&quot;UTC&quot;)  # 降级为 UTC\n3. zoneinfo.available_timezones()\n从 Python 3.11 开始，zoneinfo 模块提供了一个函数 available_timezones()，它会返回当前环境下可用的所有时区名称集合（类型为 frozenset[str]）。你可以用它来验证某个时区名称是否存在：\nfrom zoneinfo import available_timezones\n \nall_zones = available_timezones()\nprint(&quot;Asia/Shanghai&quot; in all_zones)  # True 或 False\n在 Python 3.10 及更早版本，这个函数并不存在，可通过尝试 ZoneInfo(name) 捕获异常来检查时区有效性。\n\n三、与 datetime 的结合使用\nzoneinfo 的最终目的是给 datetime 对象赋予正确的时区信息，以便进行时区感知的运算和转换。下面介绍常见的几种用法。\n1. 创建带时区信息的 datetime\n1.1 直接构造\n如果你知道某个时间点以及它所属的时区，可以像这样直接创建一个“感知”（aware）的 datetime：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 例如，创建一个 2025-06-02 12:00 上海时间的 datetime\ndt_sh = datetime(2025, 6, 2, 12, 0, tzinfo=ZoneInfo(&quot;Asia/Shanghai&quot;))\nprint(dt_sh)  \n# 输出示例：2025-06-02 12:00:00+08:00\n这里，tzinfo=ZoneInfo(&quot;Asia/Shanghai&quot;) 表示该 datetime 属于“Asia/Shanghai”时区，它内部会将 UTC 偏移 +08:00 加到该时间上。\n1.2 由“天真时间”本地化\n有时候，我们从数据库或用户输入中得到一个“天真时间”（naive datetime），本质上并不包含时区信息，但我们“知道”它应该对应某个时区。这时可以使用 datetime.replace() 或直接附加 tzinfo，但更推荐的方式是使用 datetime.astimezone() 或 datetime.replace(tzinfo=...)。两种方法区别在于：\n\n\nreplace(tzinfo=...)：原封不动地把 tzinfo 改成指定时区，不做任何时区转换。用于表示“原本就是这个时区，只是少了 tzinfo 信息”。\n\n\nastimezone(ZoneInfo)：先把“天真时间”当作本地时区时间，转换为 UTC，再转换到目标时区，会对实际时刻做调整。\n\n\n注意：如果要用 astimezone()，原来的 datetime 必须是一个“aware”对象（带有 tzinfo）。否则会先默认用本地系统时区做转换，容易出错。\n\n\n举例说明这两种情况：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 假设我们有一个用户输入的“天真时间”：\ndt_input = datetime(2025, 6, 2, 9, 30)  # 但其实是上海时间，不含时区\n \n# 方法一：直接附加 tzinfo，表示“这个 9:30 本来就是上海时间”\ndt1 = dt_input.replace(tzinfo=ZoneInfo(&quot;Asia/Shanghai&quot;))\nprint(dt1)  # 2025-06-02 09:30:00+08:00\n \n# 方法二：先告诉 Python 这个时间是本地时区（假设本地是 CET UTC+1），\n# 然后转换到上海时区\n# 先给 dt_input 附加本地时区（假设 Local 为 UTC+1）\nfrom zoneinfo import ZoneInfo\ndt_local = dt_input.replace(tzinfo=ZoneInfo(&quot;Europe/Berlin&quot;))  # 比如本机在柏林\ndt_sh_via_convert = dt_local.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\n# 如果 dt_local 表示 2025-06-02 09:30+01:00，那么转换后会变成 2025-06-02 16:30+08:00\nprint(dt_sh_via_convert)\n通常，如果你“知道”某个原始时间在某个时区下，只需要 replace(tzinfo=目标时区) 即可；如果你有一个已知时区的 datetime，要转换到另一个时区，就用 astimezone()。\n2. 时区间转换\n一旦有一个“aware” 的 datetime（即 tzinfo 不为 None），就可以用 astimezone() 转到另一个时区：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 假设有一个纽约时区的 2025-06-02 08:00\ndt_ny = datetime(2025, 6, 2, 8, 0, tzinfo=ZoneInfo(&quot;America/New_York&quot;))\nprint(&quot;纽约时间：&quot;, dt_ny)  \n# 由于纽约夏令时为 UTC-4，实际 UTC 为 12:00\n \n# 转换到 UTC\ndt_utc = dt_ny.astimezone(ZoneInfo(&quot;UTC&quot;))\nprint(&quot;UTC 时间：&quot;, dt_utc)  # 2025-06-02 12:00:00+00:00\n \n# 转换到上海时间\ndt_sh = dt_ny.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\nprint(&quot;上海时间：&quot;, dt_sh)  # 2025-06-02 20:00:00+08:00\nastimezone() 会自动根据时区规则（包括夏令时、历史变更规则）来计算正确的时间差。\n3. 获取当前带时区的时间\n如果需要获取某个时区下的“当前时间”（包含日期与时分秒），有两种常见做法：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 方法一：先获取 UTC，再转换\nnow_utc = datetime.now(ZoneInfo(&quot;UTC&quot;))\nnow_sh_via_utc = now_utc.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\n \n# 方法二：用 utcnow() 然后 replace tzinfo\nfrom datetime import datetime, timezone\nnow_utc2 = datetime.now(timezone.utc)                 # 带 tzinfo=UTC\nnow_sh_via_utc2 = now_utc2.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\n \n# 方法三（不完全推荐）：把本地时间当成某个时区，然后覆盖 tzinfo\n#       不要用 datetime.now().replace(tzinfo=...)，因为那样会错误地认为现在就是本地时区的时间\n推荐方式是先获得带 tzinfo=UTC 的 UTC 时间，再用 astimezone() 转到目标时区。这样能确保获取到的实际“当前时刻”是准确的。\n\n四、示例演示\n下面通过几个完整示例，演示 zoneinfo 在常见场景中的应用。\n1. 计算跨不同时区的会议时间\n场景：某跨国团队要在 2025-07-01 10:00（伦敦时间）召开会议，需要计算上海、纽约和悉尼对应的当地时间。\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 1. 伦敦时间 2025-07-01 10:00 (假设伦敦使用夏令时，UTC+1)\ndt_london = datetime(2025, 7, 1, 10, 0, tzinfo=ZoneInfo(&quot;Europe/London&quot;))\nprint(&quot;伦敦时间：&quot;, dt_london)\n \n# 2. 转换到上海（UTC+8）\ndt_shanghai = dt_london.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\nprint(&quot;上海时间：&quot;, dt_shanghai)  # 2025-07-01 17:00+08:00\n \n# 3. 转换到纽约（UTC-4 夏令时）\ndt_newyork = dt_london.astimezone(ZoneInfo(&quot;America/New_York&quot;))\nprint(&quot;纽约时间：&quot;, dt_newyork)    # 2025-07-01 05:00-04:00\n \n# 4. 转换到悉尼（UTC+10，但若处于夏令时则可能 +11）\ndt_sydney = dt_london.astimezone(ZoneInfo(&quot;Australia/Sydney&quot;))\nprint(&quot;悉尼时间：&quot;, dt_sydney)    # 2025-07-01 19:00+10:00（示例）\n输出示例（假设各地夏令时规则）：\n伦敦时间： 2025-07-01 10:00:00+01:00\n上海时间： 2025-07-01 17:00:00+08:00\n纽约时间： 2025-07-01 05:00:00-04:00\n悉尼时间： 2025-07-01 19:00:00+10:00\n这个例子展示了跨时区转换的典型用法：先构造一个已知时区（tzinfo=ZoneInfo(&quot;Europe/London&quot;)）的 “aware” datetime，再对其他时区调用 astimezone()，自动计算夏令时偏移、历史规则等。\n2. 解析带时区标识的 ISO8601 字符串并转换\n场景：收到一个 ISO 8601 格式的字符串 &quot;2025-12-15T14:30:00+05:30&quot;，这是印度标准时间（IST），想把它转换成纽约时间。\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 1. 解析字符串（Python 3.11+ 支持 %z 解析）\niso_str = &quot;2025-12-15T14:30:00+05:30&quot;\ndt_ist = datetime.strptime(iso_str, &quot;%Y-%m-%dT%H:%M:%S%z&quot;)\nprint(&quot;解析得到 IST 时间：&quot;, dt_ist)  \n# 输出示例：2025-12-15 14:30:00+05:30\n \n# 或者使用 fromisoformat（Python 3.7+）\ndt_ist2 = datetime.fromisoformat(iso_str)\nprint(&quot;解析得到 IST 时间 (fromisoformat)：&quot;, dt_ist2)\n \n# 2. 转换到纽约时区（America/New_York）\ndt_ny = dt_ist.astimezone(ZoneInfo(&quot;America/New_York&quot;))\nprint(&quot;纽约时间：&quot;, dt_ny)  \n# 假设 2025-12-15 印度偏移 +5:30，纽约标准时为 -5:00，不考虑夏令时\n# 14:30 IST ⇒ 09:00 UTC ⇒ 04:00 EST（纽约）\n输出示例：\n解析得到 IST 时间： 2025-12-15 14:30:00+05:30\n解析得到 IST 时间 (fromisoformat)： 2025-12-15 14:30:00+05:30\n纽约时间： 2025-12-15 04:00:00-05:00\n这展示了如何把一个带 ±HH:MM 时区偏移的 ISO8601 字符串解析成一个有 tzinfo 的 datetime，再用 astimezone() 转换到指定 ZoneInfo 对象。\n3. 比较不同时区的两个时间点先后顺序\n场景：分别得到两个时区的 “本地时间”，想比较哪个时间点早：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 北京时间 2025-08-01 10:00\ndt_bj = datetime(2025, 8, 1, 10, 0, tzinfo=ZoneInfo(&quot;Asia/Shanghai&quot;))\n \n# 伦敦时间 2025-08-01 03:00\ndt_ldn = datetime(2025, 8, 1, 3, 0, tzinfo=ZoneInfo(&quot;Europe/London&quot;))\n \n# 直接比较时区“感知”后的 datetime\nprint(&quot;北京时间是否晚于伦敦时间？&quot;, dt_bj &gt; dt_ldn)\n \n# 如果要以 UTC 统一基准，可先 astimezone(UTC)\ndt_bj_utc = dt_bj.astimezone(ZoneInfo(&quot;UTC&quot;))\ndt_ldn_utc = dt_ldn.astimezone(ZoneInfo(&quot;UTC&quot;))\nprint(&quot;北京 UTC:&quot;, dt_bj_utc)\nprint(&quot;伦敦 UTC:&quot;, dt_ldn_utc)\n解释：\n\n2025-08-01 10:00 CST（UTC+8）对应 UTC 时间为 2025-08-01 02:00 UTC\n2025-08-01 03:00 BST（UTC+1）对应 UTC 时间为 2025-08-01 02:00 UTC\n\n因此，两个时间点在 UTC 下是相等的。用 &gt;、&lt; 运算符直接比较 datetime 对象时会先将它们转换到 UTC 再比较，从而得到准确结果。\n\n五、时区数据库管理\n1. 系统 tzdata\n\n\nLinux/macOS：在大多数发行版上，IANA tzdata 通常预装在系统目录（如 /usr/share/zoneinfo）。Python 的 zoneinfo 会自动去这些目录查找对应的二进制时区文件（.tz 文件格式，glibc zoneinfo）。如果你的系统已及时更新了时区数据库（比如通过 apt-get update tzdata），Python 也能读取最新规则。\n\n\n确认系统时区目录：\nPython 会自动搜索几个常见路径，关键路径包括：\n\n\n/usr/share/zoneinfo\n\n\n/usr/lib/zoneinfo\n\n\nWindows 下常见路径：C:\\Windows\\System32\\zoneinfo 或通过 tzdata 包安装后在 Lib 目录下\n\n\n2. 在 Windows 上使用 tzdata 包\nWindows 默认没有安装 IANA tzdata，因此直接调用 ZoneInfo(&quot;Asia/Shanghai&quot;) 会报 ZoneInfoNotFoundError。解决办法是安装纯 Python 的 tzdata 包：\npip install tzdata\n安装后，Python 会把 tzdata 数据自动放在类似 Lib\\site-packages\\tzdata 的路径下，同时会把 zoneinfo 数据复制到 Lib\\zoneinfo。这样以来，无论在 Windows 还是 macOS、Linux，都能确保 zoneinfo 模块可以正常读取时区数据。\n3. 可用时区列表\n从 Python 3.11 起，你可以通过 zoneinfo.available_timezones() 获取当前环境下可查询的所有时区名称集合。示例如下：\nfrom zoneinfo import available_timezones\n \nzones = available_timezones()\n# zones 是一个 frozenset，包含如 &quot;Asia/Shanghai&quot;, &quot;Europe/Paris&quot; 等字符串\nprint(len(zones), &quot;个可用时区，例如：&quot;)\nprint(sorted(zones)[:10])\n在 Python 3.10 及更早版本，没有该函数时需要用 try/except 捕获来判断名称有效性：\nfrom zoneinfo import ZoneInfo, ZoneInfoNotFoundError\n \ndef is_valid_zone(zone_name: str) -&gt; bool:\n    try:\n        ZoneInfo(zone_name)\n        return True\n    except ZoneInfoNotFoundError:\n        return False\n \nprint(is_valid_zone(&quot;Asia/Shanghai&quot;))  # True\nprint(is_valid_zone(&quot;Mars/Phobos&quot;))    # False\n\n六、与 pytz、dateutil.tz 的区别\n1. 与 pytz 的对比\n\n\n构造和使用方式\n\n\npytz 要求通过 timezone.localize() 方法来给“天真时间”附加时区，否则会有夏令时问题。\n\n\nimport pytz\nfrom datetime import datetime\n \nnaive = datetime(2025, 6, 2, 9, 0)\ntz = pytz.timezone(&quot;Asia/Shanghai&quot;)\ndt_pytz = tz.localize(naive)  # 正确获取 9:00+08:00\n\nzoneinfo 则简洁直接，使用 replace(tzinfo=...) 即可：\n\nfrom zoneinfo import ZoneInfo\nfrom datetime import datetime\n \ndt_zi = datetime(2025, 6, 2, 9, 0, tzinfo=ZoneInfo(&quot;Asia/Shanghai&quot;))\n\n\n夏令时转换\n\n\n在 pytz 中，从一个时区转换到另一个时区，需要使用 normalize()：\n\n\ndt_us = dt_pytz.astimezone(pytz.timezone(&quot;America/New_York&quot;))\ndt_us = tz_ny.normalize(dt_us)\n\n\nzoneinfo 则无需手动调用 normalize，直接调用 astimezone() 会自动处理夏令时切换，语法更直观。\n\n\n更新机制\n\n\npytz 时区数据随 pytz 包的版本更新；如果要拿到最新规则，需要升级 pytz。\n\n\nzoneinfo 可直接依赖系统 tzdata 或者 tzdata 包，保持与操作系统一致。无需再额外升级 Python 包。\n\n\n2. 与 dateutil.tz 的对比\n\ndateutil.tz.gettz(&quot;Asia/Shanghai&quot;) 也可以返回一个时区对象，语法上与 zoneinfo.ZoneInfo(&quot;Asia/Shanghai&quot;) 类似。但 dateutil 是第三方包，需要额外安装：\n\nfrom dateutil import tz\ntz_sh = tz.gettz(&quot;Asia/Shanghai&quot;)\n\nzoneinfo 属于标准库的一部分，无需额外依赖，且其对象属性更精简、只做时区定义，不带额外的解析逻辑。\n\n\n七、常见使用场景与技巧\n1. 判断某地区当前时间是否处于夏令时\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \ntz_ny = ZoneInfo(&quot;America/New_York&quot;)\nnow_ny = datetime.now(tz_ny)\n# tzinfo.dst() 返回一个 timedelta 表示夏令时偏移；若为 0 则表示不在夏令时\nif now_ny.dst() != (now_ny.replace(tzinfo=ZoneInfo(&quot;UTC&quot;)).dst()):\n    print(&quot;当前在夏令时&quot;)\nelse:\n    print(&quot;当前不在夏令时&quot;)\n更简单地，你可以检查 now_ny.dst() != timedelta(0)，若不为零则说明当前处于夏令时。\n2. 计算两个时区之间的时间差\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \ndt_tokyo = datetime(2025, 6, 2, 15, 0, tzinfo=ZoneInfo(&quot;Asia/Tokyo&quot;))\ndt_paris = datetime(2025, 6, 2, 8, 0, tzinfo=ZoneInfo(&quot;Europe/Paris&quot;))\n \n# 转换到 UTC，然后算差值\nutc_tokyo = dt_tokyo.astimezone(ZoneInfo(&quot;UTC&quot;))\nutc_paris = dt_paris.astimezone(ZoneInfo(&quot;UTC&quot;))\ndelta = utc_tokyo - utc_paris\nprint(&quot;东京与巴黎时间差：&quot;, delta)  # timedelta(hours=7)\n当然，也可以直接比较 dt_tokyo - dt_paris，结果也是同样的 timedelta。\n3. 批量转换：将一个含有不同时区字段的列表统一转换到指定时区\n假设有一个列表，里面存储了若干个带不同时区的 ISO8601 时间字符串，想统一转换到 UTC：\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \niso_list = [\n    &quot;2025-05-01T12:00:00+08:00&quot;,\n    &quot;2025-05-01T03:00:00-04:00&quot;,\n    &quot;2025-05-01T17:30:00+01:00&quot;,\n]\n \ndt_list = [datetime.fromisoformat(s) for s in iso_list]  # 都是 aware datetime\ndt_utc_list = [dt.astimezone(ZoneInfo(&quot;UTC&quot;)) for dt in dt_list]\n \nfor dt in dt_utc_list:\n    print(dt.isoformat())\n输出示例：\n2025-05-01T04:00:00+00:00\n2025-05-01T07:00:00+00:00\n2025-05-01T16:30:00+00:00\n4. 在 Web 应用中，将日志时间标准化到 UTC 并按当地时区展示\n在 Web 日志中，为了方便跨地域协作，后端往往将所有时间都存储为 UTC，然后在前端按照用户本地时区再格式化展示。流程示例：\n\n后端（Django/Flask 等）：将 datetime.utcnow() 记录到数据库（建议存为带时区的 UTC）。\n\nfrom datetime import datetime, timezone\nnow_utc = datetime.now(timezone.utc)\n# 存进数据库\n\n前端：假设后端返回一个 ISO8601 格式的 UTC 字符串 2025-06-02T10:00:00+00:00。\n前端 JavaScript：\n\nconst utc_str = &quot;2025-06-02T10:00:00+00:00&quot;;\nconst local_dt = new Date(utc_str);\nconsole.log(local_dt.toString());  // 浏览器会自动转换为用户本地时区显示\n如果在 Python 后端直接想将 UTC 转换到某个用户时区，也可以用 zoneinfo：\nfrom datetime import datetime, timezone\nfrom zoneinfo import ZoneInfo\n \n# 后端获取业务逻辑——已知 UTC 时间\nnow_utc = datetime.now(timezone.utc)\n \n# 用户偏好时区（假设用户时区字符串存储在 profile 中）\nuser_tzname = &quot;Europe/Paris&quot;\nnow_user = now_utc.astimezone(ZoneInfo(user_tzname))\nprint(&quot;用户当地时间：&quot;, now_user.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))\n\n八、注意事项与常见坑\n\n“天真”**datetime** 转换\n\n\n如果对一个“天真”（naive）datetime 直接调用 astimezone(ZoneInfo)，Python 会假设这个时间是本地系统时区下的时间，先将它转换到 UTC，然后再转换到目标时区。通常这并不是你想要的，容易导致误差。正确做法是先通过 replace(tzinfo=source_zone) 将其标记为某个时区，然后再调用 astimezone()。\n\n\n非标准 tzdata 路径\n\n\n如果你的系统 tzdata 路径不是常见的 /usr/share/zoneinfo、/usr/lib/zoneinfo 等，你可以通过设置环境变量 ZONEINFO，让 Python 去自定义路径加载 tz 数据。例如：\n\nexport ZONEINFO=/opt/my_tzdata_directory\n这样 Python 在初始化 ZoneInfo 时会优先读取该路径下的时区数据。\n\nWindows 平台必须安装 tzdata\n\n\nWindows 自身不带 IANA 时区数据库，因此在 Windows 下使用 zoneinfo 前，一定要通过 pip install tzdata 安装，否则 ZoneInfo(&quot;Asia/Shanghai&quot;) 会报错 ZoneInfoNotFoundError。\n\n\nPython 版本兼容\n\n\nzoneinfo 仅在 Python 3.9 及更高版本才可用。如果需要在更早版本（如 3.6、3.7、3.8）使用类似功能，可以安装第三方 backport 包 backports.zoneinfo：\n\npip install backports.zoneinfo\n然后在代码中这样导入：\ntry:\n    from zoneinfo import ZoneInfo\nexcept ImportError:\n    from backports.zoneinfo import ZoneInfo\n同时需要配合 tzdata 包来保证时区数据库可用。\n\n时区名称拼写\n\n\n一定要使用正确的 IANA 时区名称，如 &quot;America/Los_Angeles&quot;、&quot;Europe/Berlin&quot;、&quot;Asia/Tokyo&quot; 等。不要使用缩写（如 &quot;CST&quot;、&quot;EST&quot;），因为这些缩写往往在不同地区有歧义。\n在不确定名称时，可先调用 available_timezones()（Python 3.11+）查看当前环境支持哪些时区名称，或者查阅 IANA 官方列表（tzdata 上的 zone.tab 文件）。\n\n\n夏令时变化\n\n\n对于处于夏令时与标准时切换当日的某些 “歧义时刻”（比如美国每年三月第二个星期日 2:00 – 3:00 会跳到 3:00），zoneinfo 会将这段时刻视为无效或重复。一般 Python 会自动选择最合适的偏移。如果需要明确指定 fold=1 或 0，可以在构造 datetime 时传入 fold 参数（Python 3.6+）：\n\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n \n# 2025-03-09 02:30 在纽约夏令时跳转中是“无效”或“重复”的时刻\ndt_naive = datetime(2025, 3, 9, 2, 30)\n \n# 在 Python 3.9+, 你可以这样：\ndt1 = dt_naive.replace(tzinfo=ZoneInfo(&quot;America/New_York&quot;), fold=0)\ndt2 = dt_naive.replace(tzinfo=ZoneInfo(&quot;America/New_York&quot;), fold=1)\n \n# fold=0/1 用来区分夏令时开始前后同样的本地时间\n\n但通常情况下，一般应用不会去主动构造那段歧义时刻；若只是用 zoneinfo 的 astimezone() 进行自动转换，Python 会根据 tzdata 规则选一个最常用的时刻偏移。\n\n\n九、小结与最佳实践\n\n尽量使用标准库\n\n\n在 Python 3.9+ 环境中，推荐使用 zoneinfo 而非第三方库来处理时区问题。这样能简化依赖并保持与操作系统 tzdata 一致。\n\n\n解析与构造“感知” datetime\n\n\n如果你从字符串或数据库中得到一个“天真”时间，一定要在明确它所属时区之后，用 replace(tzinfo=ZoneInfo(...)) 或先解析为 “含偏移的 ISO8601”，再转换到 ZoneInfo。\n不要直接对天真时间调用 astimezone()，因为这样会默认把它当作本地时区进行转换，很容易出错。\n\n\n保持 tzdata 与系统同步\n\n\n如果在 Linux/macOS 下，系统自带的 tzdata 会定期更新；只要你在操作系统层面更新了时区数据，zoneinfo 就能自动使用最新规则。\n在 Windows 下，需要手动安装/升级 tzdata Python 包，才能保持与 IANA 官方 tzdata 更新一致。\n\n\n使用 **available_timezones()** 或捕获异常来验证时区合法性\n\n\n在 Python 3.11+，调用 zoneinfo.available_timezones() 可以获取可用名称列表。对于老版本，可通过 try/except ZoneInfoNotFoundError 检查。\n\n\n夏令时与 fold 参数\n\n\n只有在特定场景下，需要区分某个本地时刻在夏令时切换前后属于哪段时间，才需要使用 fold=0/1。大多数业务场景中，直接调用 astimezone() 足以应对。\n\n\n代码示例汇总\n# -*- coding: utf-8 -*-\n&quot;&quot;&quot;\nzoneinfo 模块使用示例汇总\n&quot;&quot;&quot;\n \nfrom datetime import datetime, timedelta, timezone\nfrom zoneinfo import ZoneInfo, ZoneInfoNotFoundError, available_timezones\n \ndef example_basic():\n    # 1. 基本构造和转换\n    dt_ny = datetime(2025, 6, 2, 8, 0, tzinfo=ZoneInfo(&quot;America/New_York&quot;))\n    print(&quot;纽约时间：&quot;, dt_ny)\n \n    dt_utc = dt_ny.astimezone(ZoneInfo(&quot;UTC&quot;))\n    print(&quot;对应 UTC：&quot;, dt_utc)\n \n    dt_sh = dt_ny.astimezone(ZoneInfo(&quot;Asia/Shanghai&quot;))\n    print(&quot;对应上海：&quot;, dt_sh)\n \ndef example_parse_iso():\n    # 2. 解析带时区的 ISO8601 字符串并转换\n    iso_str = &quot;2025-12-15T14:30:00+05:30&quot;\n    dt_ist = datetime.fromisoformat(iso_str)  # 直接解析带偏移的字符串\n    print(&quot;解析 IST：&quot;, dt_ist)\n \n    dt_ny = dt_ist.astimezone(ZoneInfo(&quot;America/New_York&quot;))\n    print(&quot;转换到纽约：&quot;, dt_ny)\n \ndef example_available():\n    # 3. 列出可用时区（Python 3.11+）\n    try:\n        zones = available_timezones()\n        print(&quot;可用时区数量：&quot;, len(zones))\n        print(&quot;前 10 个：&quot;, sorted(zones)[:10])\n    except AttributeError:\n        print(&quot;当前 Python 版本不支持 available_timezones()，请通过 try/except 捕获 ZoneInfoNotFoundError 验证时区。&quot;)\n \ndef example_check_zone(name):\n    # 4. 验证时区合法性（兼容早期版本）\n    try:\n        ZoneInfo(name)\n        print(f&quot;{name} 是合法时区。&quot;)\n    except ZoneInfoNotFoundError:\n        print(f&quot;{name} 不存在于当前时区数据库。&quot;)\n \ndef example_fold():\n    # 5. 处理夏令时切换时的歧义时刻\n    # 2025-03-09 02:30 在美国夏令时起始时是跳过时刻，意义有争议\n    dt_ambiguous = datetime(2025, 3, 9, 2, 30)\n \n    # fold=0 (DST 开始前的那一刻；实际上在此刻时区偏移不存在，会被自动调整)\n    dt1 = dt_ambiguous.replace(tzinfo=ZoneInfo(&quot;America/New_York&quot;), fold=0)\n    # fold=1 (DST 开始后的那一刻)\n    dt2 = dt_ambiguous.replace(tzinfo=ZoneInfo(&quot;America/New_York&quot;), fold=1)\n \n    print(&quot;fold=0:&quot;, dt1, &quot;offset:&quot;, dt1.utcoffset())\n    print(&quot;fold=1:&quot;, dt2, &quot;offset:&quot;, dt2.utcoffset())\n \ndef example_system_tzdata():\n    # 6. 系统 tzdata 与自定义路径\n    # 如果发现 ZoneInfo 无法找到某个时区，可检查环境变量 ZONEINFO\n    # 或在导入前设置：\n    # import os\n    # os.environ[&quot;ZONEINFO&quot;] = &quot;/custom/path/to/zoneinfo&quot;\n    pass\n \nif __name__ == &quot;__main__&quot;:\n    print(&quot;=== 基本构造与转换 ===&quot;)\n    example_basic()\n    print(&quot;\\n=== 解析 ISO 字符串 ===&quot;)\n    example_parse_iso()\n    print(&quot;\\n=== available_timezones ===&quot;)\n    example_available()\n    print(&quot;\\n=== 验证时区合法性 ===&quot;)\n    example_check_zone(&quot;Asia/Shanghai&quot;)\n    example_check_zone(&quot;Mars/Phobos&quot;)\n    print(&quot;\\n=== 处理夏令时歧义 fold ===&quot;)\n    example_fold()\n\n十、小结\n\n引入与定位：zoneinfo 是 Python 3.9+ 的标准库模块，提供 IANA tzdata 的访问与查询功能，无需再依赖 pytz。\n核心功能：通过 ZoneInfo(&quot;Region/City&quot;) 获得一个时区对象，将其赋给 datetime.tzinfo 后即可进行正确的时区转换与夏令时运算。\n数据来源：优先使用系统自带的 tzdata；在 Windows 或无系统 tzdata 的环境下，可 pip install tzdata 来保证时区数据库可用。\n与 **datetime** 结合：使用 replace(tzinfo=...) 将“天真时间”指定为某个时区；使用 astimezone(...) 将已知时区的时间转换到另一个时区。\n注意事项：\n\n\n避免对天真时间直接调用 astimezone()，要先赋予正确时区再转换；\n处理夏令时切换时的歧义可通过 fold 参数；\nWindows 平台一定要安装 tzdata，且可用 available_timezones() 或捕获异常来验证时区名称；\nPython 3.9–3.10 版本需要对早期兼容做 try/except，或安装 backports.zoneinfo。\n"},"python/2.常用库与工具/标准库与内置模块/编码与加密/base64":{"slug":"python/2.常用库与工具/标准库与内置模块/编码与加密/base64","filePath":"python/2.常用库与工具/标准库与内置模块/编码与加密/base64.md","title":"base64","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/编码与加密/codecs":{"slug":"python/2.常用库与工具/标准库与内置模块/编码与加密/codecs","filePath":"python/2.常用库与工具/标准库与内置模块/编码与加密/codecs.md","title":"codecs","links":[],"tags":[],"content":"一、模块概述\n\n什么是 **codecs** 模块\n\n\ncodecs 是 Python 标准库中用于统一处理字符编码与转换的模块。它提供了对各种字符编码（如 UTF-8、GBK、ISO-8859-1 等）的读取、写入、编解码操作接口。\n其设计目标是：让用户在读写文本时，不必直接操作底层的二进制数据，而只需关注“字符（Unicode） ↔ 字节（bytes）”之间的转换。\n\n\n为什么要使用 **codecs**\n\n\n跨 Python 2/3：在 Python 2 中，字符串有 “bytes” 和 “unicode” 两种类型；在 Python 3 中，默认字符串是 Unicode，二进制数据是 bytes。codecs 在两个版本中都能用来统一管理编码。\n丰富的编码支持：内置对绝大多数常用编码的支持，并允许注册自定义的编码/解码器。\n自动 BOM 处理：部分编码（如 UTF-16、UTF-32）在文件头会有 BOM（Byte Order Mark）字节序标记，使用 codecs 打开文件时会自动处理这些 BOM。\n逐块/增量编解码：对于需要边读边解码、边写边编码的场景（比如网络流或大型文件），codecs 提供了增量编解码接口（IncrementalEncoder/Decoder）。\n\n\n二、常用函数与类\n1. codecs.open\n\n功能：类似内置的 open 函数，但可以直接指定文件编码，返回一个以Unicode 字符串为接口的文件对象。\n函数原型：\n\ncodecs.open(filename, mode=&#039;r&#039;, encoding=None, errors=&#039;strict&#039;, buffering=1)\n\n\nfilename：文件路径（字符串）。\n\n\nmode：文件打开模式，支持 ‘r’, ‘w’, ‘a’，可附加二进制标记 ‘b’，但一般不需要加 ‘b’，因为 codecs.open 本身返回的是文本接口。\n\n\nencoding：要使用的字符编码名称（如 &#039;utf-8&#039;、&#039;gbk&#039;、&#039;latin-1&#039; 等）。\n\n\nerrors：遇到无法解码/编码字符时的处理方式，常见值包括 &#039;strict&#039;, &#039;ignore&#039;, &#039;replace&#039;, &#039;xmlcharrefreplace&#039; 等。\n\n\nbuffering：缓冲策略，与内置 open 类似，一般使用默认值即可。\n\n\n示例：\n\n\nimport codecs\n \n# 以 UTF-8 编码写入\nwith codecs.open(&#039;example.txt&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as f:\n    f.write(&#039;这是一些中文文本。\\nSecond line in English.&#039;)\n \n# 以 GBK 编码读取\nwith codecs.open(&#039;example.txt&#039;, &#039;r&#039;, encoding=&#039;gbk&#039;, errors=&#039;ignore&#039;) as f:\n    content = f.read()\n    print(content)\n2. codecs.encode 与 codecs.decode\n\n\n功能：\n\n\nencode(obj, encoding=&#039;utf-8&#039;, errors=&#039;strict&#039;)：将对象（常见是 Unicode 字符串）使用指定编码转换为 bytes。\n\n\ndecode(obj, encoding=&#039;utf-8&#039;, errors=&#039;strict&#039;)：将对象（常见是 bytes）使用指定编码转换为 Unicode 字符串。\n\n\n示例：\n\n\nimport codecs\n \ns = &#039;Hello, 世界&#039;\n# 从 Unicode → bytes（UTF-8）\nb = codecs.encode(s, &#039;utf-8&#039;)\nprint(type(b), b)  # &lt;class &#039;bytes&#039;&gt; b&#039;Hello, \\xe4\\xb8\\x96\\xe7\\x95\\x8c&#039;\n \n# 从 bytes → Unicode\ns2 = codecs.decode(b, &#039;utf-8&#039;)\nprint(type(s2), s2)  # &lt;class &#039;str&#039;&gt; Hello, 世界\n \n# 使用其他编码：GBK\nb_gbk = codecs.encode(s, &#039;gbk&#039;, errors=&#039;replace&#039;)\nprint(b_gbk)  # 如果字符串中有某些编码不支持的字符，会以 &#039;?&#039; 或替代形式出现\n \ns3 = codecs.decode(b_gbk, &#039;gbk&#039;)\nprint(s3)\n3. 查找与注册编解码器\n\n**codecs.lookup(encoding)**\n根据编码名称（字符串）查找对应的编解码器（CodecInfo 对象）。返回類似：\n\n&lt;CodecInfo name=&#039;utf-8&#039; encode=&lt;_functools.partial object at 0x...&gt; decode=&lt;_functools.partial object at 0x...&gt;&gt;\n\n**codecs.register(search_function)**允许用户注册自定义的搜索函数，以便在 lookup() 时查找到自定义编解码器。search_function 接受一个编码名称字符串，返回一个符合协议的 CodecInfo 对象或 None。\n示例：注册一个简单的反转 UTF-8 编码（仅用于演示）\n\nimport codecs\n \n# 1. 定义 encode 和 decode 函数\ndef reverse_utf8_encode(input, errors=&#039;strict&#039;):\n    # 先正常用 utf-8 编码，再反转字节序\n    b = input.encode(&#039;utf-8&#039;, errors=errors)\n    return (b[::-1], len(input))\n \ndef reverse_utf8_decode(input, errors=&#039;strict&#039;):\n    # 先反转字节序，再按 utf-8 解码\n    b = input[::-1]\n    return (b.decode(&#039;utf-8&#039;, errors=errors), len(input))\n \n# 2. 定义搜索函数\ndef search_reverse_utf8(encoding_name):\n    if encoding_name.lower() == &#039;reverse-utf-8&#039;:\n        return codecs.CodecInfo(\n            name=&#039;reverse-utf-8&#039;,\n            encode=reverse_utf8_encode,\n            decode=reverse_utf8_decode,\n        )\n    return None\n \n# 3. 注册\ncodecs.register(search_reverse_utf8)\n \n# 4. 使用\ns = &#039;Hello&#039;\nb_rev = codecs.encode(s, &#039;reverse-utf-8&#039;)\nprint(b_rev)  # 反转后的字节\nprint(codecs.decode(b_rev, &#039;reverse-utf-8&#039;))\n\n三、文件操作示例\n1. 读取包含 BOM 的文件\n某些文本文件（尤其是 Windows 或某些工具生成的）在 UTF-16 或 UTF-32 文件开头会带 BOM。直接用内置 open 可能导致读取时出现 BOM 字符。使用 codecs.open 则能自动识别并跳过 BOM。\nimport codecs\n \n# 假设 example_utf16.txt 带有 BOM\nwith codecs.open(&#039;example_utf16.txt&#039;, &#039;r&#039;, encoding=&#039;utf-16&#039;) as f:\n    text = f.read()\n    # BOM 已经被自动剔除，text 中不会包含 &#039;\\ufeff&#039;\n    print(text)\n2. 同时以不同编码读取与写入\nimport codecs\n \n# 将 GBK 文件转换为 UTF-8 文件\nwith codecs.open(&#039;source_gbk.txt&#039;, &#039;r&#039;, encoding=&#039;gbk&#039;, errors=&#039;ignore&#039;) as fin:\n    with codecs.open(&#039;converted_utf8.txt&#039;, &#039;w&#039;, encoding=&#039;utf-8&#039;) as fout:\n        for line in fin:\n            fout.write(line)\n3. 处理大文件时的分块（分行）读写\n\n逐行读取\n\nimport codecs\n \nwith codecs.open(&#039;large_file.txt&#039;, &#039;r&#039;, encoding=&#039;utf-8&#039;) as f:\n    for line in f:\n        # line 已经是 Unicode 字符串\n        process(line)\n\n按固定字节数读取（若要在二进制层面手动分块再解码，可结合 IncrementalDecoder，详见增量编解码）\n\nimport codecs\n \ndecoder = codecs.getincrementaldecoder(&#039;utf-8&#039;)(errors=&#039;replace&#039;)\nwith open(&#039;large_file.txt&#039;, &#039;rb&#039;) as f:\n    while True:\n        chunk = f.read(1024)  # 按 1024 字节读取\n        if not chunk:\n            break\n        text = decoder.decode(chunk)\n        process(text)\n    # 最后 flush 未决缓冲\n    remaining = decoder.decode(b&#039;&#039;, final=True)\n    if remaining:\n        process(remaining)\n\n四、编解码原理与常用接口\n1. CodecInfo 对象\n通过 codecs.lookup(name) 返回的 CodecInfo 对象包括以下重要属性：\n\nname：编码名称（标准化、小写）。\nencode(input, errors=&#039;strict&#039;)：进行一次整体编码，返回 (output_bytes, length_consumed)。\ndecode(input, errors=&#039;strict&#039;)：进行一次整体解码，返回 (output_str, length_consumed)。\nincrementalencoder：返回相应的 IncrementalEncoder 类，用于逐步编码。\nincrementaldecoder：返回相应的 IncrementalDecoder 类，用于逐步解码。\nstreamwriter：返回相应的 StreamWriter 类，可用于封装在流（文件、socket）上的写入。\nstreamreader：返回相应的 StreamReader 类，可用于封装在流（文件、socket）上的读取。\n\n示例：查看 UTF-8 CodecInfo\nimport codecs\n \nci = codecs.lookup(&#039;utf-8&#039;)\nprint(ci.name)               # &#039;utf-8&#039;\nprint(ci.encode)             # &lt;built-in function pyencode&gt;\nprint(ci.decode)             # &lt;built-in function pydecode&gt;\nprint(ci.incrementalencoder) # &lt;class &#039;_codecs.IncrementalEncoder&#039;&gt;\nprint(ci.incrementaldecoder) # &lt;class &#039;_codecs.IncrementalDecoder&#039;&gt;\nprint(ci.streamwriter)       # &lt;class &#039;_codecs.StreamWriter&#039;&gt;\nprint(ci.streamreader)       # &lt;class &#039;_codecs.StreamReader&#039;&gt;\n2. StreamReader 与 StreamWriter\n\nStreamReader继承自 codecs.StreamReader 的类，用于从字节流中读取数据并解码为 Unicode。常见用法是与 StreamWriter 成对使用。\nStreamWriter继承自 codecs.StreamWriter 的类，用于将 Unicode 字符串编码后写入字节流。\n\n通常情况下，你无需直接操作这两个类，codecs.open 已经在内部封装了：\n# 等价于下面两句\nf = open(&#039;file.txt&#039;, &#039;rb&#039;)\nreader = codecs.getreader(&#039;utf-8&#039;)(f, errors=&#039;strict&#039;)  # 生成一个 StreamReader 实例\ntext = reader.read()\n \n# 或者\nf = open(&#039;file.txt&#039;, &#039;wb&#039;)\nwriter = codecs.getwriter(&#039;utf-8&#039;)(f, errors=&#039;strict&#039;)\nwriter.write(&#039;Some text&#039;)\n\n五、错误处理（Error Handling）\n当编码或解码过程中遇到无法处理的字符时，会触发错误。codecs 提供了多种错误模式，通过参数 errors 指定。常见取值及含义如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n错误模式描述strict严格模式：遇到非法字符时抛出 UnicodeError（默认）。ignore忽略：跳过无法编码/解码的字符，不插入任何替代。replace替换：将无法编码/解码的字符替换为“?” 或 相应编码的替代符（如 U+FFFD）。xmlcharrefreplace编码时可用，将无法编码字符替换为 XML/HTML 实体（例如 &amp;#12345;）。backslashreplace编码时可用，将无法编码字符以 Python 的反斜杠转义形式表示（例如 \\u1234）。namereplace编码时可用，将 Unicode 字符替换为 \\N{…}形式的名称。surrogateescapePython 3 特有，可将无法解码的原始字节保留在 U+DCXX范围内，便于后续无损写回。\n示例：**errors=&#039;replace&#039;**\nimport codecs\n \ns = &#039;汉字😊&#039;  # &#039;😊&#039;（U+1F60A）在 GBK 编码中无法表示\nb_gbk = codecs.encode(s, &#039;gbk&#039;, errors=&#039;replace&#039;)\nprint(b_gbk)            # b&#039;\\xba\\xba\\xd7\\xd6?&#039;  （将 U+1F60A 替换为 &#039;?&#039;）\n \ns2 = codecs.decode(b_gbk, &#039;gbk&#039;, errors=&#039;replace&#039;)\nprint(s2)               # &#039;汉字?&#039;\n\n六、增量编解码（Incremental Encoding/Decoding）\n对于“流式”数据或无法一次性装载到内存的超大文件，可采用增量编解码接口，逐块地对字节与字符进行转换。常见场景有：网络 socket 收发、分块读取文件、实时日志转换等。\n1. IncrementalEncoder\n\n获取方式：\n\nenc_cls = codecs.getincrementalencoder(&#039;utf-8&#039;)  # 返回 IncrementalEncoder 类\nenc = enc_cls(errors=&#039;replace&#039;)                 # 实例化\n\n\n常用方法：\n\n\nenc.encode(input_str, final=False)：将输入的部分 Unicode 字符串编码为 bytes；如果 final=True，表示这是最后一块，内部缓冲区要全部 flush。\n\n\nenc.reset()：重置内部状态。\n\n\n2. IncrementalDecoder\n\n获取方式：\n\ndec_cls = codecs.getincrementaldecoder(&#039;utf-8&#039;)\ndec = dec_cls(errors=&#039;replace&#039;)\n\n\n常用方法：\n\n\ndec.decode(input_bytes, final=False)：将输入的部分字节序列解码为 Unicode；若 final=True，表示最后一次输入，需要 flush 缓冲区。\n\n\ndec.reset()：重置内部状态。\n\n\n3. 示例：逐块从文件读取并解码\n假设有一个大文件，以 UTF-8 编码，需要逐块读取并解码为 Unicode，再处理文本行。\nimport codecs\n \n# 获取增量解码器\ndecoder = codecs.getincrementaldecoder(&#039;utf-8&#039;)(errors=&#039;strict&#039;)\n \nwith open(&#039;large_utf8.txt&#039;, &#039;rb&#039;) as f:\n    buffer = &#039;&#039;\n    while True:\n        chunk = f.read(4096)  # 每次读取 4096 字节\n        if not chunk:\n            # 最后一次 decode，并把所有剩余输出\n            text_part = decoder.decode(b&#039;&#039;, final=True)\n            buffer += text_part\n            break\n        text_part = decoder.decode(chunk, final=False)\n        buffer += text_part\n \n        # 处理行：避免行被拆分成半截\n        lines = buffer.split(&#039;\\n&#039;)\n        buffer = lines.pop()  # 最后一个可能是不完整的行，保留到下轮\n        for line in lines:\n            process(line)\n \n    # 如果末尾 buffer 不为空，则作最后处理\n    if buffer:\n        process(buffer)\n4. 示例：逐块将 Unicode 写入文件，并编码为 GBK\nimport codecs\n \n# 获取增量编码器\nencoder = codecs.getincrementalencoder(&#039;gbk&#039;)(errors=&#039;replace&#039;)\n \nwith open(&#039;output_gbk.txt&#039;, &#039;wb&#039;) as f:\n    unicode_text_generator = get_large_unicode_source()  # 假设这是一个生成器\n    for text_chunk in unicode_text_generator:\n        b = encoder.encode(text_chunk, final=False)\n        f.write(b)\n    # 最后一次 flush\n    f.write(encoder.encode(&#039;&#039;, final=True))\n\n七、注册与自定义编码\n在某些场景下，内置编码无法满足需求，需要自定义编解码逻辑。codecs 模块允许通过 register 接口动态注册自定义编解码器。\n1. 自定义编解码器的基本结构\n\n自定义编码器需要提供：\n\n\nencode(input, errors=&#039;strict&#039;)：接受 Unicode 字符串，返回 (bytes, length_consumed)。\ndecode(input, errors=&#039;strict&#039;)：接受 bytes，返回 (str, length_consumed)。\n可选地，提供增量编解码器类 IncrementalEncoder、IncrementalDecoder、流处理类 StreamWriter、StreamReader。\n\n\n将这些函数/类包装到一个 CodecInfo 对象中，再由注册函数对外公开。\n\n2. 简单示例：ROT13 编解码\nimport codecs\nimport codecs\n \n# 1. 定义 encode/decode 函数\ndef rot13_encode(input, errors=&#039;strict&#039;):\n    # input: Unicode 字符串\n    output = []\n    for ch in input:\n        o = ord(ch)\n        if &#039;A&#039; &lt;= ch &lt;= &#039;Z&#039;:\n            o = (o - ord(&#039;A&#039;) + 13) % 26 + ord(&#039;A&#039;)\n        elif &#039;a&#039; &lt;= ch &lt;= &#039;z&#039;:\n            o = (o - ord(&#039;a&#039;) + 13) % 26 + ord(&#039;a&#039;)\n        output.append(chr(o))\n    return (&#039;&#039;.join(output).encode(&#039;ascii&#039;), len(input))  # 返回 ASCII bytes\n \ndef rot13_decode(input, errors=&#039;strict&#039;):\n    # 对于 ROT13，encode 和 decode 相同\n    b = input.decode(&#039;ascii&#039;, errors=errors)\n    return rot13_encode(b, errors=errors)\n \n# 2. 定义搜索函数\ndef search_rot13(encoding_name):\n    if encoding_name.lower() == &#039;rot13&#039;:\n        return codecs.CodecInfo(\n            name=&#039;rot13&#039;,\n            encode=rot13_encode,\n            decode=rot13_decode,\n            # 因为只是 ASCII 范围内，增量编解码可以直接复用\n            incrementalencoder=None,\n            incrementaldecoder=None,\n            streamreader=None,\n            streamwriter=None,\n        )\n    return None\n \n# 3. 注册\ncodecs.register(search_rot13)\n \n# 4. 使用\ns = &#039;Hello, World!&#039;\nb_rot = codecs.encode(s, &#039;rot13&#039;)\nprint(b_rot)                   # b&#039;Uryyb, Jbeyq!&#039;\nprint(codecs.decode(b_rot, &#039;rot13&#039;))  # Hello, World!\n如果需要更复杂的增量/流式处理，可以进一步实现 IncrementalEncoder/StreamWriter 等类。\n\n八、常见编码简介\n虽然 codecs 支持众多编码，但以下几类最常见：\n\nUTF 系列\n\n\nutf-8: 最流行的网络与文件编码，变长（1~4 字节），兼容 ASCII。\nutf-16: 定长（2 或 4 字节），在文件头常带 BOM，分为 utf-16-le（小端）和 utf-16-be（大端）。\nutf-32: 定长 4 字节，也分 LE/BE。很少在普通文本文件中使用。\n\n\nASCII / Latin 系列\n\n\nascii: 最基础的 7 位编码，只支持 U+0000~U+007F。\nlatin-1（iso-8859-1）: 支持西欧语言的单字节编码，U+0000~U+00FF。\n\n\n中文相关\n\n\ngbk / cp936（GB2312 的扩展）：兼容简体中文，单字节或双字节混用。\ngb18030: 国家标准，几乎涵盖所有汉字，兼容 GBK。\nbig5: 繁体中文常用编码（台湾、香港）。\nhz: 用于电子邮件等场景，专门转义中文。\n\n\n其它常见\n\n\ncp1252: Windows 默认的西欧编码，与 latin-1 接近。\nshift_jis / euc-jp: 日文常用编码。\niso-2022-jp: 用于邮件等场景的日文编码。\n\n可以通过 codecs.aliases.aliases 查看所有别名映射，也可以在命令行中测试：\npython3 -c &quot;import codecs; print(sorted(codecs.aliases.aliases.keys()))&quot;\n\n九、实战示例与注意事项\n1. 示例：处理用户输入并保存到指定编码文件\nimport codecs\n \ndef save_user_text(text, filename, target_encoding=&#039;utf-8&#039;):\n    &quot;&quot;&quot;\n    将用户输入的 Unicode 文本保存到 filename，编码格式为 target_encoding。\n    遇到无法编码字符时以 &#039;?&#039; 代替。\n    &quot;&quot;&quot;\n    with codecs.open(filename, &#039;w&#039;, encoding=target_encoding, errors=&#039;replace&#039;) as f:\n        f.write(text)\n \nif __name__ == &#039;__main__&#039;:\n    user_input = input(&quot;请输入一段文本（可以包含任意 Unicode 字符）：\\n&quot;)\n    save_user_text(user_input, &#039;output.txt&#039;, target_encoding=&#039;gbk&#039;)\n    print(&quot;已保存到 output.txt（GBK 编码）。&quot;)\n\n\n要点：\n\n\n当用户输入中包含某些 GBK 无法表示的字符时，由于使用了 errors=&#039;replace&#039;，将自动用 &#039;?&#039; 替换，避免写文件报错。\n\n\n若希望保留原始二进制信息，可以考虑使用 errors=&#039;surrogateescape&#039;。\n\n\n2. 示例：网络通信中增量解码\n假设从网络 socket 中接收 UTF-8 编码数据，需要实时解码并处理行：\nimport socket\nimport codecs\n \ndef process(line):\n    print(&quot;收到一行：&quot;, line)\n \n# 假设已经连上服务器\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((&#039;example.com&#039;, 12345))\n \n# 用于增量解码\ndecoder = codecs.getincrementaldecoder(&#039;utf-8&#039;)(errors=&#039;replace&#039;)\nbuffer = &#039;&#039;\n \nwhile True:\n    chunk = s.recv(4096)  # bytes\n    if not chunk:\n        break\n    text_part = decoder.decode(chunk, final=False)\n    buffer += text_part\n    lines = buffer.split(&#039;\\n&#039;)\n    buffer = lines.pop()\n    for line in lines:\n        process(line)\n \n# 处理最后残余\nremaining = decoder.decode(b&#039;&#039;, final=True)\nif remaining:\n    process(remaining)\n \ns.close()\n\n要点：\n\n\n使用 incrementaldecoder 可以确保若某个字符被分在两个 TCP 包里，也能正确拼接再解码。\n分行处理时，保留最后一个不完整的行到下一次接收。\n\n3. 示例：批量转换目录下所有文件编码\n下面示例将某个目录下所有 .txt 文件从任意编码（假设为 GBK）转换成 UTF-8：\nimport os\nimport codecs\n \ndef convert_dir(src_dir, src_encoding=&#039;gbk&#039;, dst_encoding=&#039;utf-8&#039;):\n    for root, _, files in os.walk(src_dir):\n        for fname in files:\n            if not fname.lower().endswith(&#039;.txt&#039;):\n                continue\n            fullpath = os.path.join(root, fname)\n            try:\n                with codecs.open(fullpath, &#039;r&#039;, encoding=src_encoding, errors=&#039;ignore&#039;) as fin:\n                    content = fin.read()\n                # 备份原文件\n                os.rename(fullpath, fullpath + &#039;.bak&#039;)\n                # 写入新编码\n                with codecs.open(fullpath, &#039;w&#039;, encoding=dst_encoding) as fout:\n                    fout.write(content)\n                print(f&#039;转换成功: {fullpath}&#039;)\n            except Exception as e:\n                print(f&#039;转换失败 {fullpath}: {e}&#039;)\n \nif __name__ == &#039;__main__&#039;:\n    convert_dir(&#039;/path/to/your/folder&#039;)\n\n要点：\n\n\n使用 errors=&#039;ignore&#039; 或 errors=&#039;replace&#039; 来避免因无法解码字符而中断。\n转换前最好备份原文件，以免意外覆盖导致无法恢复。\n\n\n十、补充说明与最佳实践\n\n优先使用 Python 3 自带的 **open**\n\n\n在 Python 3 中，内置的 open(..., encoding=...) 已经将绝大部分场景覆盖。如果无需兼容 Python 2 或特殊需求，一般直接用：\n\nwith open(&#039;file.txt&#039;, &#039;r&#039;, encoding=&#039;utf-8&#039;, errors=&#039;ignore&#039;) as f:\n    ...\n\n只有在需要使用 codecs 提供的低层接口（如增量编解码器）时，才显式导入并使用 codecs。\n\n\n注意 BOM 处理\n\n\ncodecs.open(path, &#039;r&#039;, encoding=&#039;utf-8-sig&#039;)：若文件前有 UTF-8 BOM（0xEF,0xBB,0xBF），会自动跳过。\n类似地，utf-16、utf-32 都会自动识别 BOM 并相应地选择大端或小端解码。\n\n\n谨慎选择错误处理方式\n\n\n如果数据完整性非常重要，不要轻易使用 errors=&#039;ignore&#039;，因为会丢失无法识别的字符。\nerrors=&#039;replace&#039; 会用 “？” 或 “�” 等符号替代，也会造成原始数据丢失。\nerrors=&#039;surrogateescape&#039;（Python 3）可用于在无法解码时，将原始字节先存储在 \\uDCxx 的 “代理” 区间，以备写回或后续处理。\n\n\n查看可用编码\n\n\n使用 codecs.encodings.aliases.aliases 可以获取所有已注册编码别名。例如：\n\nimport codecs\nfrom pprint import pprint\n \npprint(codecs.aliases.aliases.keys())\n\n若某些编码名称不在列表中，需要先 import encodings.&lt;name&gt; 或其他方式注册后才可使用。\n\n\n性能考虑\n\n\n在处理大型文本文件时，如果不需要增量机制，可以直接用 open(..., encoding=..., errors=...)；Python 标准实现会在内部做缓冲并高效调用底层 C 解码器。\ncodecs.open 在 Python 3 中已经是对内置 open 的封装；但如果需要“逐行”或“逐块”处理，可以结合增量编解码，避免一次性将整个文件读入内存。\n\n\n十一、总结\n\ncodecs 模块在 Python 中主要负责 字符 ↔ 字节 之间的编码与解码，支持丰富的编码格式和可配置的错误处理策略。\n核心接口包括：\n\n\ncodecs.open：带编码的文件读写接口。\ncodecs.encode / codecs.decode：一次性编码/解码函数。\ncodecs.lookup / codecs.register：查找／注册编解码器。\nIncrementalEncoder / IncrementalDecoder：增量式编解码的基础。\nStreamReader / StreamWriter：以 IO 流为接口的编码读写类。\n\n\n在大多数 Python 3 的常规文本处理场景下，可直接使用内置 open(..., encoding=...)；只有在特殊需求（如需要自定义编解码器、增量处理、兼容 Python 2）时，才需显式导入并使用 codecs。\n本文通过示例演示了从基础读写、错误处理、增量编解码，到自定义注册编解码器的完整流程。希望你在掌握核心概念后，能够根据实际业务需求灵活选用或扩展 codecs 提供的功能。\n"},"python/2.常用库与工具/标准库与内置模块/编码与加密/hashlib":{"slug":"python/2.常用库与工具/标准库与内置模块/编码与加密/hashlib","filePath":"python/2.常用库与工具/标准库与内置模块/编码与加密/hashlib.md","title":"hashlib","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/网络编程/http.client--and--http.server":{"slug":"python/2.常用库与工具/标准库与内置模块/网络编程/http.client--and--http.server","filePath":"python/2.常用库与工具/标准库与内置模块/网络编程/http.client & http.server.md","title":"http.client & http.server","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/网络编程/socket":{"slug":"python/2.常用库与工具/标准库与内置模块/网络编程/socket","filePath":"python/2.常用库与工具/标准库与内置模块/网络编程/socket.md","title":"socket","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/网络编程/ssl":{"slug":"python/2.常用库与工具/标准库与内置模块/网络编程/ssl","filePath":"python/2.常用库与工具/标准库与内置模块/网络编程/ssl.md","title":"ssl","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/网络编程/urllib":{"slug":"python/2.常用库与工具/标准库与内置模块/网络编程/urllib","filePath":"python/2.常用库与工具/标准库与内置模块/网络编程/urllib.md","title":"urllib","links":[],"tags":[],"content":""},"python/2.常用库与工具/标准库与内置模块/网络编程/xmlrpc.client---and---xmlrpc.server":{"slug":"python/2.常用库与工具/标准库与内置模块/网络编程/xmlrpc.client---and---xmlrpc.server","filePath":"python/2.常用库与工具/标准库与内置模块/网络编程/xmlrpc.client  &  xmlrpc.server.md","title":"xmlrpc.client  &  xmlrpc.server","links":[],"tags":[],"content":""},"python/index":{"slug":"python/index","filePath":"python/index.md","title":"index","links":[],"tags":[],"content":"Python 知识概览\n1. 基础语法\n1.1 变量和数据类型\n\n\n数字类型\n\n\n整型（int）\n\n\n浮点型（float）\n\n\n复数（complex）\n\n\n字符串（str）\n\n\n单引号与双引号\n\n\n字符串格式化\n\n\n字符串操作方法（len(), strip(), find(), replace() 等）\n\n\n字符串转义（\\n, \\t, \\r 等）\n\n\n列表（list）\n\n\n创建与访问\n\n\n列表方法（append(), pop(), remove() 等）\n\n\n列表切片\n\n\n元组（tuple）\n\n\n集合（set）\n\n\n字典（dict）\n\n\n键值对（key-value）\n\n\n字典方法（get(), items(), keys(), values() 等）\n\n\n布尔类型（bool）\n\n\nTrue 与 False\n\n\n布尔运算（and, or, not）\n\n\n1.2 运算符\n\n算术运算符：+, -, *, /, //, %, **\n比较运算符：==, !=, &gt;, &lt;, &gt;=, &lt;=\n逻辑运算符：and, or, not\n位运算符：&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;\n成员运算符：in, not in\n身份运算符：is, is not\n\n1.3 控制结构\n\n\n条件语句\n\n\nif, else, elif\n\n\n条件表达式（三元运算符）\n\n\n循环语句\n\n\nfor 循环\n\n\nwhile 循环\n\n\nelse 在循环中的使用\n\n\n跳出控制\n\n\nbreak, continue, pass\n\n\n1.4 函数\n\n\n定义函数：def 语法\n\n\n参数\n\n\n位置参数\n\n\n默认参数\n\n\n可变参数（*args, **kwargs）\n\n\n关键字参数\n\n\n返回值\n\n\n匿名函数（lambda）\n\n\n高阶函数\n\n\n\n2. 高级语法\n2.1 列表解析（List Comprehensions）\n\n基本语法\n条件判断\n嵌套列表解析\n字典解析\n\n2.2 生成器（Generators）\n\n使用 yield 生成值\n生成器表达式\n使用 next() 和 for 循环\n\n2.3 装饰器（Decorators）\n\n函数装饰器\n类装饰器\n带参数的装饰器\n装饰器的应用\n\n2.4 上下文管理器（Context Managers）\n\n使用 with 语句\n自定义上下文管理器\n__enter__ 和 __exit__ 方法\n\n2.5 异常处理\n\ntry, except, finally\n捕获特定异常\n自定义异常\nraise 关键字\n\n2.6 模块与包\n\n导入模块\n模块作用域\n包的结构（__init__.py）\n第三方库安装与管理（pip, virtualenv）\n\n2.7 Lambda 表达式与高阶函数\n\nmap(), filter(), reduce()\n排序（sorted(), key）\n\n\n3. 面向对象编程（OOP）\n3.1 类与对象\n\n定义类\n类实例化与初始化（__init__）\n属性和方法\n类的继承与多态\n\n3.2 魔法方法\n\n__str__, __repr__\n__getitem__, __setitem__, __delitem__\n__iter__, __next__\n__call__\n__eq__, __lt__, __gt__\n__enter__, __exit__\n\n3.3 类的封装\n\n私有属性和方法（_ 和 __）\n类方法与静态方法（@classmethod, @staticmethod）\n访问器与修改器（@property）\n\n3.4 继承与多态\n\n单继承与多重继承\n方法重载与方法重写\n抽象类与接口（ABC）\n多态性\n\n\n4. 数据结构与算法\n4.1 数据结构\n\n数组与列表\n链表（单链表、双链表）\n队列（Queue）与栈（Stack）\n哈希表（Hash Table）\n树（Binary Tree, Binary Search Tree, AVL Tree）\n图（Graph）\n\n4.2 算法基础\n\n排序算法（冒泡、选择、插入、快速排序等）\n查找算法（顺序查找、二分查找）\n深度优先搜索（DFS）、广度优先搜索（BFS）\n动态规划（DP）\n贪心算法\n\n4.3 时间复杂度与空间复杂度\n\n大O符号\n时间复杂度分析\n空间复杂度分析\n\n\n5. 常用库与工具\n5.1 NumPy\n\n数组操作\n数学函数\n广播机制\n\n5.2 Pandas\n\nSeries 与 DataFrame\n数据清洗与处理\n数据可视化与分析\n\n5.3 Matplotlib\n\n绘图基础\n图表类型（线图、柱状图、散点图等）\n自定义图形样式\n\n5.4 Requests\n\n发送 GET 与 POST 请求\n处理响应\n文件上传与下载\n\n5.5 Web框架（Flask, Django）\n\nFlask 基础\nDjango 基础\n模板引擎\n数据库集成\n\n5.6 SQLite 与 SQLAlchemy\n\nSQLite 数据库基础\nSQLAlchemy 模型定义与查询\n关系型数据库操作\n\n5.7 多线程与多进程\n\nthreading 模块\nmultiprocessing 模块\n并发编程\nGIL（全局解释器锁）\n"},"python/web开发/Django/概要":{"slug":"python/web开发/Django/概要","filePath":"python/web开发/Django/概要.md","title":"概要","links":[],"tags":[],"content":"1. Django 概述与基本概念\n1.1 Django 是什么\n\nWeb 框架分类（MVC、MTV）\nDjango 在 Python Web 生态中的定位和优势\nDjango 的历史与版本演进\n\n1.2 开发环境与工具\n\nPython 版本选择及管理（推荐使用 Python 3.8+）\n虚拟环境管理（venv、virtualenv、poetry、pipenv）\n常用集成开发环境（IDE）/编辑器（VS Code、PyCharm、Sublime Text）\n版本管理工具（Git、GitHub/GitLab/Bitbucket）\n\n\n2. Django 安装与初始配置\n2.1 安装方式\n\npip 安装\npipenv/poetry 安装\n支持的操作系统（Windows、macOS、Linux）\n\n2.2 创建项目\n\n\ndjango-admin startproject 命令详解\n\n\n项目目录结构说明（manage.py、settings.py、urls.py、wsgi.py/asgi.py、init.py 等）\n\n\n配置 settings.py\n\n\nSECRET_KEY、DEBUG 模式\n\n\nALLOWED_HOSTS、INSTALLED_APPS\n\n\nMIDDLEWARE、TEMPLATES、DATABASES\n\n\nSTATIC_URL、MEDIA_URL、静态/媒体文件设置\n\n\n2.3 开发服务器\n\npython manage.py runserver 使用与常见参数\nDEBUG 模式下的自动重载原理\n\n\n3. Django 应用（App）与项目组织\n3.1 创建与注册 App\n\npython manage.py startapp &lt;app_name&gt; 命令\nINSTALLED_APPS 中注册应用\n应用内部目录结构（models.py、views.py、urls.py、admin.py 等）\n\n3.2 多应用项目结构最佳实践\n\n按功能划分 App\n公共模块与工具模块（utils、common 等）\n配置模块化（settings 目录化、将不同环境配置拆分为 dev/prod/test）\n\n3.3 App 与 Project 的关系\n\nmanage.py 的作用\nwsgi.py 与 asgi.py 区别\n统一路由配置 vs. 分散路由配置（在项目 urls.py 中 include 各 App 的 urls.py）\n\n\n4. URL 配置与路由\n4.1 URL Dispatcher 原理\n\n正则表达式 vs. path 转换器\nurlpatterns 列表与 path()、re_path() 函数\n视图函数、类视图（Class-Based Views）与路由绑定\n\n4.2 命名 URL\n\nname 参数与 {% url %} 模板标签\n反向解析（reverse）与 reverse_lazy\n\n4.3 URL 参数与捕获\n\n位置参数、关键字参数\n使用转换器（int、slug、uuid、path 等）\n可选参数与默认值\n\n4.4 路由组织与嵌套\n\n包含（include）其他 URLconf\n路由分组与命名空间（namespace）\n\n\n5. 视图（Views）\n5.1 视图函数（Function-Based Views，FBV）\n\n基本视图函数结构\nHttpRequest、HttpResponse 对象\n渲染模板：render(request, template_name, context)\n重定向：redirect()、HttpResponseRedirect\n\n5.2 类视图（Class-Based Views，CBV）\n\n通用视图基础：View、TemplateView、ListView、DetailView、CreateView、UpdateView、DeleteView\n动态重写 get()、post()、get_context_data()、form_valid() 等方法\n混合 (mixins)：LoginRequiredMixin、PermissionRequiredMixin、FormMixin 等\n自定义类视图的继承与复用\n\n5.3 视图的装饰器\n\n@login_required、@permission_required\n@csrf_exempt、@require_http_methods([&#039;GET&#039;, &#039;POST&#039;]) 等\n自定义装饰器（认证、限流、日志等场景）\n\n\n6. 模板系统（Templates）\n6.1 模板基础语法\n\n变量渲染：{{ variable }}\n控制逻辑：{% if %}、{% for %}、{% block %}、{% extends %}、{% include %}\n注释：{# 注释内容 #}\n\n6.2 模板继承与模块化\n\n基础模板（base.html）的设计与子模板继承\n块（block）与重写（override）\n片段模板（include）与可重用组件\n\n6.3 模板标签与过滤器\n\n内置标签：url、static、csrf_token、now、ifequal、forloop.counter 等\n常用过滤器：date、length、default、join、safe、slice 等\n自定义模板标签与过滤器（编写标签库、简单标签 vs. 赋值标签 vs. inclusion 标签）\n\n6.4 多语言与本地化（i18n、l10n）\n\ngettext、gettext_lazy 的使用\nLANGUAGE_CODE、USE_I18N、LOCALE_PATHS 配置\nmakemessages、compilemessages 命令\n模板中的翻译标签：{% trans %}、{% blocktrans %}\n\n\n7. 数据模型与 ORM\n7.1 模型基础\n\n定义模型类：models.Model\n字段类型：CharField、TextField、IntegerField、BooleanField、DateTimeField、ForeignKey、ManyToManyField、OneToOneField 等\n常用参数：verbose_name、help_text、choices、default、null、blank、unique、db_index、upload_to（对于 FileField/ImageField）\n\n7.2 数据库迁移\n\nmakemigrations vs. migrate\n迁移文件原理与工作流程\n迁移冲突处理（merge、squash、reset）\n\n7.3 查询集 (QuerySet) 与管理器 (Manager)\n\n基础查询：all()、filter()、exclude()、get()、order_by()、values()、values_list()、distinct()\n聚合与分组：annotate()、aggregate()、Count、Sum、Avg、Max、Min\n关联查询：select_related()、prefetch_related()、defer()、only()\nF、Q 对象与复杂查询：字段比较、条件组合（AND、OR）、子查询\n自定义 Manager 与 QuerySet 方法\n\n7.4 模型元选项（Meta）\n\ndb_table、ordering、unique_together、index_together、permissions 等\n抽象基类、代理模型、多表继承、代理模型的使用场景\n\n7.5 模型方法与信号\n\n自定义模型方法与属性（__str__()、自定义 manager 方法）\n预存回调：save()、delete() 方法重写\nDjango Signals：pre_save、post_save、pre_delete、post_delete、m2m_changed 等\n信号与业务逻辑解耦\n\n7.6 自定义字段与索引\n\n自定义字段类型（继承 models.Field、实现 get_prep_value、from_db_value 等）\n数据库索引优化：db_index=True、indexes（models.Index）\n全文搜索（PostgreSQL SearchVectorField、第三方库如 django-haystack、Elasticsearch 集成）\n\n\n8. Django Admin 管理后台\n8.1 Admin 基础\n\n启用 Admin：在 settings.py 中注册 django.contrib.admin\n创建超级用户：createsuperuser\n路由配置：path(&#039;admin/&#039;, admin.site.urls)\n\n8.2 自定义 Admin 界面\n\nModelAdmin 类常用属性：list_display、list_filter、search_fields、list_per_page、ordering\nfieldsets、readonly_fields、inlines（TabularInline 与 StackedInline）、filter_horizontal、filter_vertical\n自定义表单：form 属性与 ModelForm\n动作（Actions）与批量操作\n注册多对多字段（通过 filter_horizontal/filter_vertical、raw_id_fields）\n\n8.3 Admin 高级功能\n\n自定义模板与静态文件（重写 Admin 模板、添加 JS/CSS）\n自定义视图（额外页面、统计报表、仪表盘）\n多站点、多数据库支持\n权限细粒度控制：has_add_permission、has_change_permission、has_delete_permission\n\n\n9. 表单（Forms）与验证\n9.1 表单基础\n\n使用 forms.Form 定义表单字段：CharField、EmailField、IntegerField、DateField、ChoiceField、MultipleChoiceField、FileField、ImageField 等\n内置小部件（Widgets）及其属性：TextInput、Textarea、CheckboxInput、Select、DateInput、ClearableFileInput\n表单校验方式：clean_&lt;fieldname&gt;()、clean()、全局 vs. 单字段校验\n错误显示与错误消息定制\n\n9.2 ModelForm\n\n根据模型自动生成表单：forms.ModelForm\nMeta 类中的 model、fields、exclude、widgets、labels、help_texts\n保存ModelForm：form.save()、commit=False\n\n9.3 视图中处理表单\n\nGET/POST 请求逻辑：展示空表单、绑定数据、验证数据、处理成功/失败的流程\nform.is_valid()、form.cleaned_data、错误反馈\n文件上传：enctype=&quot;multipart/form-data&quot;、request.FILES、MEDIA_ROOT、MEDIA_URL 配置\n\n9.4 表单高级技巧\n\n自定义字段校验器（validators）\nFormsets 与 ModelFormsets：formset_factory、modelformset_factory、inlineformset_factory\n动态表单（根据用户权限或上下文动态添加字段）\n使用第三方库优化：django-crispy-forms、django-floppyforms 等\n\n\n10. 用户认证与授权\n10.1 内置认证系统\n\ndjango.contrib.auth 组件介绍\n用户模型：User 对象常用属性（username、email、is_staff、is_superuser、is_active 等）\n权限系统：Groups、Permissions（add、change、delete、view）\n用户与组关系：user.groups、group.permissions\n\n10.2 注册、登录、登出\n\n使用内置视图：LoginView、LogoutView、PasswordChangeView、PasswordResetView 等\n自定义认证视图（基于 Form 或 Class-Based Views）\n密码哈希与强度验证：AUTH_PASSWORD_VALIDATORS 设置\n\n10.3 自定义用户模型\n\nAbstractUser vs. AbstractBaseUser 区别\n继承 AbstractUser 扩展字段\n继承 AbstractBaseUser 完全自定义用户模型：USERNAME_FIELD、REQUIRED_FIELDS、自定义 Manager\n配置 AUTH_USER_MODEL 注意事项与数据迁移\n\n10.4 授权与权限控制\n\n视图装饰器：@login_required、@permission_required\nClass-Based Views 中的 Mixin：LoginRequiredMixin、PermissionRequiredMixin\n对象级权限（django-guardian 等第三方库）\n基于角色的访问控制（RBAC）设计思想\n\n\n11. 中间件（Middleware）\n11.1 中间件概念与作用\n\n请求与响应处理流程：process_request、process_view、process_template_response、process_response、process_exception\n常见内置中间件介绍：SecurityMiddleware、SessionMiddleware、AuthenticationMiddleware、CsrfViewMiddleware、CommonMiddleware、GZipMiddleware 等\n\n11.2 自定义中间件\n\n创建简单中间件类（新式中间件必须实现 __call__）\n在 MIDDLEWARE 中配置顺序与注意事项\n中间件的性能影响与调试技巧\n\n\n12. 静态文件（Static）与媒体文件（Media）\n12.1 静态文件处理\n\nSTATIC_URL、STATIC_ROOT、STATICFILES_DIRS 配置\ncollectstatic 原理及部署注意事项\n使用 Django 提供的静态文件服务器（开发环境） vs. 生产环境通过 Nginx/Apache/CND 提供静态资源\n\n12.2 媒体文件\n\nMEDIA_URL、MEDIA_ROOT 配置\n文件上传示例：FileField、ImageField 上传到服务器或第三方存储（腾讯 COS、阿里 OSS、Amazon S3 等）\n访问与保护上传资源（权限校验、签名 URL）\n\n12.3 前端资源管理\n\n与 CSS/JS 打包工具结合（Webpack、Parcel、gulp）\nDjango Pipeline、django-compressor 等第三方静态资源压缩/合并库\nWebpack + Django 模板集成参考方案（django-webpack-loader）\n\n\n13. 国际化（i18n）与本地化（l10n）\n13.1 国际化基本设置\n\nUSE_I18N、USE_L10N、USE_TZ、LANGUAGE_CODE、TIME_ZONE\nLocaleMiddleware 的作用与使用顺序\n\n13.2 翻译文件管理\n\ngettext、gettext_lazy、ugettext 差异\n提取翻译：makemessages -l &lt;language_code&gt;\n翻译文件结构：.po、.mo 文件\n编译翻译：compilemessages\n运行时语言切换：set_language 视图与中间件\n\n13.3 本地化格式\n\n日期/时间、货币、数字格式化\ndjango.utils.formats 及其配置\n\n\n14. 测试（Testing）\n14.1 测试基础\n\nDjango 测试框架概述：unittest 与 TestCase\n测试目录结构与文件命名规范（tests.py、tests/ 包）\n测试数据库自动创建与回滚机制\n\n14.2 单元测试（Unit Test）\n\n模型测试（Model Tests）：验证字段约束、方法逻辑\n视图函数/类视图测试：Client 对象模拟请求（GET/POST）、状态码、响应内容校验\n表单测试：验证表单校验逻辑、清洗数据\nURL 测试：reverse 的正确性、路由匹配测试\nAdmin 测试：管理员权限视图测试\n\n14.3 集成测试（Integration Test）\n\n测试中间件、上下文处理器\n测试静态文件响应、模板渲染\n复杂业务流程测试（多步表单、多模型联动）\n\n14.4 功能测试与前端测试\n\nSelenium、Playwright、Cypress 与 Django 的集成\nLiveServerTestCase 使用\n静态文件服务与前端资源测试\n\n14.5 性能测试与压力测试\n\n使用 locust、JMeter、wrk 等工具对 Django 应用进行压力测试\nProfiling 与分析：django-debug-toolbar、silk、django-silk、cProfile、line_profiler\n\n\n15. 部署与运维\n15.1 部署前准备\n\nDEBUG=False 生产模式注意事项\n配置 SECRET_KEY 与环境变量管理（django-environ、python-decouple）\nALLOWED_HOSTS、CSRF_TRUSTED_ORIGINS 设置\n数据库迁移与静态文件收集（manage.py migrate、collectstatic）\n\n15.2 WSGI 与 ASGI\n\nWSGI: gunicorn、uWSGI 基本配置与使用\nASGI: Django Channels、daphne、uvicorn 等\n\n15.3 Web 服务器与反向代理\n\nNginx 配置示例（反向代理、静态/媒体文件分发、HTTPS 配置）\nApache + mod_wsgi 配置示例\nLoad Balancer 与多实例部署（负载均衡、会话保持、粘性会话）\n\n15.4 数据库生产环境\n\nPostgreSQL、MySQL、MariaDB 的选择与配置\n数据库连接池（django-db-geventpool、django-postgrespool2）\n读写分离、主从复制架构（PGPool-II、MySQL Proxy 等）\n\n15.5 缓存与消息队列\n\n缓存策略：Django 缓存框架（内存缓存、Memcached、Redis）\n缓存使用场景：视图缓存（cache_page）、模板片段缓存、低级缓存 API\n消息队列：Celery 与 Django 集成（Broker 选择：Redis、RabbitMQ）\n定时任务：Celery Beat、Django-background-tasks\n\n15.6 日志与监控\n\nPython 日志框架与 Django 日志配置（LOGGING 字典配置）\n日志级别与输出格式（INFO、DEBUG、WARNING、ERROR、CRITICAL）\n日志收集：ELK（Elasticsearch、Logstash、Kibana）、Graylog、Sentry、Rollbar\n应用性能监控（APM）：NewRelic、Datadog、Prometheus + Grafana\n\n15.7 安全性与权限\n\nHTTPS/TLS 证书申请与自动化（Let’s Encrypt + Certbot）\n常见安全配置：SECURE_SSL_REDIRECT、SESSION_COOKIE_SECURE、CSRF_COOKIE_SECURE、SECURE_HSTS_SECONDS、SECURE_BROWSER_XSS_FILTER、X_FRAME_OPTIONS\n防御常见攻击：CSRF、XSS、SQL 注入、点击劫持\nHTTP 头安全：CSP（Content Security Policy）、Referrer-Policy、Feature-Policy\n\n\n16. 性能优化与扩展\n16.1 数据库优化\n\nSQL 查询优化：使用 EXPLAIN 分析、合理使用索引、避免 N+1 查询\n缓存层：视图级缓存、模板片段缓存、低级缓存\n数据库连接池、读写分离、分库分表\n\n16.2 请求响应优化\n\n压缩响应：GZipMiddleware、静态文件压缩\n减少中间件链长度、移除不必要的中间件\n连接池与长连接：PostgreSQL/Redis 持久连接设置\n\n16.3 静态资源优化\n\n前端资源打包与压缩（Webpack、django-compressor）\n图片优化与 CDN 加速\n利用浏览器缓存（Cache-Control、ETag、Last-Modified）\n\n16.4 进程与线程模型\n\ngunicorn 进程模型（sync、async、gevent 等模式）\nuWSGI 配置优化：processes、threads、harakiri、max-requests\nASGI 并发：uvicorn/daphne 与 asyncio、并发限制配置\n\n16.5 性能监控与调优\n\ndjango-debug-toolbar、silk、django-silk、django-querycount 等调试工具\nProfiling：cProfile、line_profiler、memory_profiler\n定期审查慢查询日志与瓶颈排查流程\n\n\n17. 安全性深入\n17.1 常见漏洞与防护\n\nSQL 注入：Django ORM 自动防护原理、手写原生 SQL 时的注意事项\n跨站脚本攻击（XSS）：模板自动转义、escape 与 mark_safe 风险\n跨站请求伪造（CSRF）：CsrfViewMiddleware、csrf_token、AJAX 请求中 CSRF Token 处理\n点击劫持（Clickjacking）：X_FRAME_OPTIONS 设置（DENY、SAMEORIGIN）\n文件上传安全：校验文件类型、大小、存储路径隔离、恶意脚本风险\n\n17.2 用户数据保护\n\n密码安全策略：密码哈希算法（PBKDF2、BCrypt、Argon2）、密码强度验证\n敏感信息加密：字段加密（django-fernet-fields、django-encrypted-model-fields）\nGDPR/CCPA 合规性：用户隐私保护、数据导出与删除\n日志审计与访问控制（RBAC、ABAC）\n\n17.3 安全测试与渗透\n\n自动化扫描工具：OWASP ZAP、Bandit、Sqlmap\n安全基线检测（Docker 镜像安全、依赖包安全扫描：Safety、Dependabot）\n渗透测试流程与报告撰写\n\n\n18. Django REST Framework（DRF）\n18.1 DRF 概览\n\nDRF 与 Django 的关系\n安装与初始化：djangorestframework、rest_framework in INSTALLED_APPS\n\n18.2 序列化与反序列化\n\nSerializer 类：serializers.Serializer vs. serializers.ModelSerializer\n字段类型：CharField、IntegerField、DateTimeField、PrimaryKeyRelatedField、SlugRelatedField 等\n验证与校验方法：validate_&lt;field&gt;、validate()、validators 参数\n嵌套序列化与关系字段\n\n18.3 视图集（ViewSet）与路由\n\nAPIView vs. GenericAPIView vs. ViewSet vs. GenericViewSet\n通用视图：ListAPIView、RetrieveAPIView、CreateAPIView、UpdateAPIView、DestroyAPIView\nViewSet + Router：DefaultRouter、SimpleRouter 自动生成 URL\n动态路由、自定义 action（@action 装饰器）\n\n18.4 权限与认证\n\nDRF 内置认证方案：TokenAuthentication、SessionAuthentication、BasicAuthentication、JWT（需第三方库 django-rest-framework-simplejwt）\n自定义认证类\n权限类：IsAuthenticated、IsAdminUser、AllowAny、DjangoModelPermissions、自定义权限类\n对象级权限：DjangoObjectPermissions、第三方包 django-guardian 集成\n\n18.5 分页、过滤与排序\n\n分页器（Pagination）：PageNumberPagination、LimitOffsetPagination、CursorPagination\n过滤：django-filter 集成，FilterSet、DjangoFilterBackend\n搜索与排序：SearchFilter、OrderingFilter\n\n18.6 版本控制与文档\n\nAPI 版本管理思路（URL 版本、请求头版本）\n自动化文档生成：BrowsableAPIRenderer、Swagger（drf-yasg）、Redoc、CoreAPI\nSchema 生成：AutoSchema、OpenAPI\n\n18.7 性能优化\n\n限制返回字段：Sparse Fieldsets、自定义序列化\n缓存 API：视图缓存、Low-level 缓存\n批量操作：Bulk Create/Update、批量删除\nThrottling：速率限制（ThrottleClasses）\n\n\n19. 异步支持与实时通信\n19.1 Django 异步视图（Async View）\n\n从 Django 3.1+ 支持异步视图\n编写 async def 视图函数与调用异步 ORM（目前仍有限制）\n使用 asgiref.sync.sync_to_async 将同步代码包装成异步\n\n19.2 Django Channels 基础\n\n安装与配置：channels、ASGI_APPLICATION、CHANNEL_LAYERS（Redis 作为后端）\nASGI vs. WSGI\n路由与消费者（Consumers）：WebsocketConsumer、AsyncWebsocketConsumer\nChannel Layer 原理：Group、Channel、Layer\n\n19.3 WebSocket 实现\n\n创建消费者（connect、receive、disconnect）\n前端与后端的 WebSocket 连接：JavaScript 示例\n聊天室、在线通知、实时更新场景实现\n\n19.4 后台任务与异步执行\n\nCelery 与 Django Channels 的结合（异步任务推送 WebSocket）\nAsync ORM（Django 4.1+ 部分 ORM 操作异步化）\n使用第三方库：Django-Q、Huey 等实现异步任务\n\n\n20. 第三方扩展与常用库\n20.1 表单与 UI\n\ndjango-crispy-forms：增强表单渲染能力\ndjango-widget-tweaks：模板中自定义表单字段渲染\ndjango-bootstrap4/5：与 Bootstrap 快速集成\ndjango-material：Material Design 风格组件\n\n20.2 管理后台优化\n\ndjango-grappelli、django-suit：Admin 界面主题替换\ndjango-admin-tools：提升 Admin 仪表盘可视化与定制\ndjango-import-export：Admin 扩展导入/导出功能\n\n20.3 富文本与文件管理\n\ndjango-ckeditor、django-tinymce：集成富文本编辑器\ndjango-filer：统一文件、图片管理\ndjango-storages：与 Amazon S3、腾讯 COS、阿里 OSS 等结合\n\n20.4 API 与文档\n\ndjango-rest-framework-simplejwt：JWT 认证\ndrf-yasg、drf-spectacular：Swagger/OpenAPI 文档\ndjango-filter：DRF 过滤扩展\n\n20.5 测试与调试\n\ndjango-debug-toolbar：开发环境调试工具\ncoverage.py：测试覆盖率分析\nFactory Boy：测试数据工厂\nModel Mommy / Model Bakery：测试模型快速生成\n\n20.6 性能与安全\n\ndjango-redis：Redis 缓存/Session 后端\ndjango-cacheops：自动缓存 ORM 查询结果\ndjango-axes：防暴力破解\ndjango-cors-headers：跨域资源共享（CORS）配置\n\n20.7 其他常用扩展\n\ndjango-allauth：综合用户认证（包括社交登录）\ndjango-guardian：对象级权限管理\ndjango-activity-stream：实现用户行为流\ndjango-haystack：全文搜索框架（与 Elasticsearch、Whoosh 等集成）\n\n\n21. 实战示例与项目练习\n21.1 博客系统示例\n\n基本 CRUD（文章、分类、标签）\n评论功能实现、分页、全文搜索\n用户注册、登录、权限控制\nMarkdown 编辑器集成、富文本存储\n\n21.2 电商网站示例\n\n商品展示、购物车、订单流程\n支付网关集成（支付宝、微信、Stripe）\n库存管理、优惠券系统、评价系统\n后台管理：订单管理、商品管理、用户管理\n\n21.3 社交网络示例\n\n用户关注、粉丝、点赞、评论功能\n实时通知与消息推送（Channels 实现 WebSocket 实时推送）\n多媒体文件上传、图片缩略图生成（Pillow、django-imagekit）\n\n21.4 RESTful API 服务示例\n\n基于 DRF 实现完整的 API：认证、权限、分页、过滤、文档\n前后端分离架构：Vue/React/Angular 与 Django 后端联调\nAPI 版本管理与限流策略\n\n21.5 微服务与跨服务通信\n\nDjango+Django REST Framework 构建微服务\n使用 gRPC 或 REST 接口进行微服务通信\n服务注册与发现、API 网关（Kong、Traefik）\nDocker 化与 Kubernetes 部署\n\n\n22. 进阶主题与最佳实践\n22.1 代码架构与设计模式\n\n“Fat Model, Thin View, Thin Template” 原则\n服务层（Service Layer）与领域驱动设计（DDD）\nRepository 模式、工厂模式、策略模式在 Django 中的应用\n\n22.2 多数据库支持\n\nDATABASES 配置多数据库\n路由数据库：DATABASE_ROUTERS 使用场景与示例\n跨库事务处理与一致性保障（使用 django-transaction-hooks 或手动管理事务）\n\n22.3 OAuth2 与单点登录（SSO）\n\ndjango-oauth-toolkit：搭建 OAuth2 授权服务器\n使用第三方身份提供商（Auth0、Okta、Keycloak）与 Django 集成\nSAML 或 CAS 单点登录实现思路\n\n22.4 GraphQL 接口\n\nGraphene-Django 快速入门\nSchema 设计、Mutations、Query\n前端集成：Apollo Client、Relay\n\n22.5 CI/CD 与自动化部署\n\nGitHub Actions/GitLab CI/CD 配置示例\n自动化测试、静态代码检查（flake8、black、isort）\nDocker 容器化、Docker Compose 示例\nKubernetes 部署示例（Deployment、Service、Ingress、ConfigMap、Secret）\n\n22.6 DevOps 与云原生\n\n在 AWS/GCP/Azure 上部署 Django（Elastic Beanstalk、GKE、App Engine、Azure App Service）\n使用 Terraform/Ansible 自动化部署与基础设施管理\nServerless 架构（Django Serverless Framework、Zappa）\n\n22.7 持续性能优化与运维\n\n灰度发布与蓝绿部署策略\nA/B 测试与实验功能\n监控告警体系设计（Prometheus+Grafana、ELK、Sentry）\n服务降级与限流策略\n\n\n附：学习建议与资源\n\n\n官方文档：\n\n\nDjango 官方文档（docs.djangoproject.com/zh-hans/）\n\n\nDjango REST Framework 文档（www.django-rest-framework.org/）\n\n\n书籍推荐：\n\n\n《Django for Professionals》\n\n\n《Django 3 By Example》\n\n\n《Two Scoops of Django》\n\n\n《Django 实战：开发与部署》\n\n\n在线教程与博客：\n\n\nMDN Web 文档中 Django 指南\n\n\nReal Python Django 系列教程\n\n\n简书/掘金/Django China 社区优质文章\n\n\n视频课程：\n\n\nYouTube/哔哩哔哩 上的 Django 系列教程（先系统后实战）\n\n\n各大在线学习平台（慕课网、极客时间、Coursera）的付费/免费课程\n\n\n开源项目参考：\n\n\nDjango 官方示例项目（Polls、Tutorial）\n\n\nMozilla 社区维基的 Django 示例项目\n\n\nGitHub 上的企业级开源项目（Wagtail、Django Oscar、Saleor 等）\n\n\n实践与社区：\n\n\n定期在 GitHub 上 Star、Fork、阅读优秀的开源 Django 项目\n\n\n参与 Django 中国社区、Stack Overflow 提问与回答\n\n\n参加本地/线上技术沙龙、DjangoCon 等线下/线上会议\n\n\n\n学习建议\n\n循序渐进：先打好基础，从 CRUD（模型、视图、模板）入手，理解 Django 的核心思想，再逐步深入到中间件、ORM 优化、缓存、异步等高级主题。\n多做项目：结合实际业务场景（博客、电商、社交等）进行练习，通过实战加深对各个模块的理解。\n阅读源码：在学习到高级概念（如 ORM 查询集缓存、信号机制）时，尝试阅读 Django 官方源码，理解底层设计。\n重视测试与部署：不要只关注开发，更要了解如何编写测试用例、部署到生产环境、监控与运维。\n持续关注社区动态：Django 不断更新新特性（如 async ORM、ASGI 支持）。关注官方博客、Django 发布日志，及时了解新版本变化。\n"},"python/爬虫/BeautifulSoup":{"slug":"python/爬虫/BeautifulSoup","filePath":"python/爬虫/BeautifulSoup.md","title":"BeautifulSoup","links":[],"tags":[],"content":"BeautifulSoup 是 Python 中广泛应用的 HTML/XML 解析库，主要用于从网页中提取结构化数据。其接口友好，语法简洁，特别适合爬虫新手与中小型项目使用。\n\n一、基本概念\n1. 安装方式\npip install beautifulsoup4\n为提升解析效率与兼容性，建议安装以下可选解析器：\npip install lxml html5lib\n\nlxml：性能较高，解析速度快，推荐优先使用。\nhtml5lib：兼容性更强，能够处理非标准 HTML，但解析速度较慢。\n\n2. 初始化使用\nfrom bs4 import BeautifulSoup\n \nhtml = &quot;&quot;&quot;\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;h1 class=&quot;title&quot;&gt;页面标题&lt;/h1&gt;\n    &lt;p id=&quot;desc&quot;&gt;这里是描述文字。&lt;/p&gt;\n    &lt;a href=&quot;example.com/page1&quot;&gt;链接1&lt;/a&gt;\n    &lt;a href=&quot;example.com/page2&quot; class=&quot;link&quot;&gt;链接2&lt;/a&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&quot;&quot;&quot;\n \nsoup = BeautifulSoup(html, &quot;lxml&quot;)  # 可替换为 &quot;html.parser&quot; 或 &quot;html5lib&quot;\n\n二、核心用法\n1. 标签查找方法\n基本查找\nsoup.find(&quot;a&quot;)                # 查找第一个 &lt;a&gt; 标签\nsoup.find_all(&quot;a&quot;)           # 查找所有 &lt;a&gt; 标签\nsoup.find(&quot;h1&quot;, class_=&quot;title&quot;)  # 根据 class 查找\nCSS 选择器查找（推荐使用 .select()）\nsoup.select(&quot;#desc&quot;)         # 查找 id 为 desc 的元素\nsoup.select(&quot;a.link&quot;)        # 查找 class 为 link 的 &lt;a&gt; 标签\nsoup.select(&quot;body a&quot;)        # 查找 body 下的所有 &lt;a&gt; 标签\n2. 标签内容与属性提取\ntag = soup.find(&quot;h1&quot;)\n \ntext = tag.get_text(strip=True)   # 获取纯文本\nname = tag.name                   # 获取标签名，例如 &#039;h1&#039;\ncls = tag[&quot;class&quot;]                # 获取属性值 [&#039;title&#039;]\ncls_alt = tag.get(&quot;class&quot;)        # 同上，更安全\n3. DOM 遍历与结构操作\n子节点与后代节点\nparent = soup.body\nchildren = list(parent.children)       # 直接子节点（含空白文本）\ndescendants = list(parent.descendants) # 所有嵌套后代节点\n父节点与兄弟节点\ntag = soup.find(&quot;h1&quot;)\nparent = tag.parent                 # 父节点\nnext_sib = tag.next_sibling         # 下一个兄弟节点（常是换行符）\nprev_sib = tag.previous_sibling     # 上一个兄弟节点\n4. 条件筛选与函数过滤\n按属性筛选\nsoup.find_all(&quot;a&quot;, class_=&quot;link&quot;)\nsoup.find_all(&quot;a&quot;, href=True)  # 带有 href 属性的 &lt;a&gt; 标签\n自定义筛选函数\ndef has_href(tag):\n    return tag.has_attr(&quot;href&quot;)\n \nsoup.find_all(has_href)\n综合示例：提取所有带 class 且 href 以 http 开头的链接\ndef valid_link(tag):\n    return tag.name == &quot;a&quot; and tag.has_attr(&quot;href&quot;) and tag[&quot;href&quot;].startswith(&quot;http&quot;) and tag.has_attr(&quot;class&quot;)\n \nsoup.find_all(valid_link)\n5. 标签的修改、删除与插入\ntag = soup.find(&quot;p&quot;)\n \ntag[&quot;id&quot;] = &quot;new_id&quot;     # 修改属性\ntag.string = &quot;新文本内容&quot;  # 修改文本内容\n \ntag.decompose()          # 完全删除该标签（包含其内容）\n \n# 插入新节点示例\nfrom bs4 import Tag\n \nnew_tag = soup.new_tag(&quot;div&quot;, id=&quot;inserted&quot;)\nnew_tag.string = &quot;这是新插入的内容&quot;\nsoup.body.append(new_tag)  # 添加为 body 的子节点\n\n三、实际示例：提取网页标题与链接\nimport requests\nfrom bs4 import BeautifulSoup\n \nurl = &quot;example.com&quot;\nheaders = {\n    &quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;\n}\n \nres = requests.get(url, headers=headers)\nsoup = BeautifulSoup(res.text, &quot;lxml&quot;)\n \n# 提取页面标题\ntitle = soup.title.get_text(strip=True) if soup.title else &quot;无标题&quot;\n \n# 提取所有链接及其文本\nfor a in soup.find_all(&quot;a&quot;, href=True):\n    text = a.get_text(strip=True)\n    href = a[&quot;href&quot;]\n    print(f&quot;{text} =&gt; {href}&quot;)\n\n四、补充说明\n1. 解析器选择建议\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n解析器速度容错能力安装需求html.parser中中无lxml快中需要安装html5lib慢强需要安装\n推荐优先使用 lxml，若页面结构不规范可考虑 html5lib。\n2. 常见问题排查\n\n使用 .string 时，若标签包含子标签将返回 None，应改用 .get_text()。\n使用 .next_sibling 和 .previous_sibling 可能返回换行符，应结合 strip() 或循环过滤。\n"},"python/爬虫/Selenium":{"slug":"python/爬虫/Selenium","filePath":"python/爬虫/Selenium.md","title":"Selenium","links":[],"tags":[],"content":"一、Selenium 简介与应用场景\n\n什么是 Selenium？\n\n\nSelenium 最初是由 Jason Huggins 在 2004 年发起的一个开源项目，主要用于模拟用户在浏览器上的操作，以实现自动化测试、网页抓取（自动登录、翻页抓取）、定时监控等功能。\n官方文档地址：www.selenium.dev/\n\n\nSelenium 在 Python 中的角色\n\n\nSelenium 为 Python 提供了 selenium 包，其中最核心的是 selenium.webdriver 模块。该模块封装了多种浏览器驱动（如 ChromeDriver、GeckoDriver/FirefoxDriver 等），让我们能够通过 Python 代码直接驱动浏览器，实现模拟点击、输入、执行 JS 脚本、获取页面内容等操作。\n\n\n主要应用场景\n\n\n自动化测试：借助 Selenium，QA 可以编写测试脚本，对 Web 应用进行功能测试、回归测试。\n自动化爬虫：遇到需要登录、验证码、动态加载（JavaScript 渲染）内容的页面时，常常使用 Selenium 实现更可靠的数据抓取。\n自动化运维/监控：定时监控某些页面状态、定时登录并获取数据、填写表单等。\n\n\n二、安装与环境配置\n2.1 安装 Selenium Python Package\n在命令行执行：\npip install selenium\n若国内网络较慢，可选择镜像源，例如：\npip install -i pypi.tuna.tsinghua.edu.cn/simple selenium\n2.2 安装并配置浏览器驱动（WebDriver）\nSelenium 通过浏览器对应的 WebDriver 进程与浏览器本身进行通信。常见浏览器及对应驱动：\n\nChrome + ChromeDriver\n\n\n下载地址（需与 Chrome 浏览器版本对应）：\nchromedriver.chromium.org/downloads\n解压后，将 chromedriver 可执行文件放到系统 PATH 中，或在代码中指定其路径。\n\n\nFirefox + GeckoDriver\n\n\n下载地址：github.com/mozilla/geckodriver/releases\n同样解压后放到 PATH 中或在代码里指定。\n\n\nEdge + EdgeDriver\n\n\n下载地址：developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n\n\n其他浏览器\n\n\nSafariDriver（macOS：可直接启用 Safari 的“开发者→允许远程自动化”选项）。\nOperaDriver 等。\n\nTip\n\nWindows 下可将 chromedriver.exe 放在 Python 可执行环境（如虚拟环境）对应的 Scripts 目录，或放到任意已加入 PATH 的目录。\n在代码中，也可通过参数 executable_path 或 Service 来指定驱动路径，后面示例会详述。\n\n2.3 验证环境是否配置成功\n以下示例以 ChromeDriver 为例，启动一个 Chrome 浏览器并打开百度首页。\nfrom selenium import webdriver\n \n# 1. 如果 chromedriver 在 PATH 中，可直接：\ndriver = webdriver.Chrome()\n \n# 2. 如果 chromedriver 不在 PATH，需要指定路径（假设放在 /path/to/chromedriver）\n# from selenium.webdriver.chrome.service import Service\n# service = Service(executable_path=&quot;/path/to/chromedriver&quot;)\n# driver = webdriver.Chrome(service=service)\n \ndriver.get(&quot;www.baidu.com&quot;)\nprint(driver.title)  # 应输出 “百度一下，你就知道”\ndriver.quit()\n如果能成功打开浏览器并打印网页标题，说明环境配置正常。\n\n三、Selenium 架构与核心概念\n3.1 核心模块说明\n\n**selenium.webdriver**\n\n\n\nwebdriver 是最常用的部分，提供了对浏览器的控制接口。常见子模块或类：\n\n\nChrome, Firefox, Edge, Safari 等：各自封装了对应浏览器的初始化与控制。\n\n\nChromeOptions, FirefoxOptions：用于配置浏览器启动选项（如无头模式、禁用通知等）。\n\n\nService：用于指定 WebDriver 可执行文件路径及一些启动参数。\n\n\n\n**selenium.webdriver.common.by**\n\n\n提供了一些查找元素时的“定位方式”，例如 By.ID, By.NAME, By.XPATH, By.CSS_SELECTOR 等。\n\n\n**selenium.webdriver.common.keys**\n\n\n枚举了常用键盘按键（例如 ENTER、TAB、CTRL、SHIFT 等），用于模拟键盘输入操作。\n\n\n**selenium.webdriver.support.ui** 与 **selenium.webdriver.support.expected_conditions**\n\n\n提供了更高级的等待机制，能够实现“显式等待”（Explicit Wait）。\n\n\n**selenium.common.exceptions**\n\n\n定义了各种可能抛出的异常类型，如 NoSuchElementException, TimeoutException 等，用于捕获与调试。\n\n3.2 WebDriver 与浏览器的通信机制\n\nWebDriver 协议\n\n\nSelenium 4 采用了 W3C WebDriver 标准，通过 HTTP 请求的方式，让 Python 端（客户端）向相应的浏览器驱动（Server）发送命令，浏览器驱动再调用实际浏览器 UI，实现用户行为的模拟。\n简单流程：\n\nPython Client (selenium.webdriver.Chrome) \n       ↓ HTTP\nChromeDriver（可执行） \n       ↓ DevTools Protocol / Browser 交互\nChrome 浏览器\n\n无头(headless)与有头(headed)浏览器\n\n\n有头浏览器指带有 UI 界面的真实浏览器；\n无头浏览器则在后台运行，不会打开可视窗口，适用于服务器端（CI/CD、无界面 Linux 服务器）场景。通过 Options 参数设置。\n\n\n四、基本使用\n4.1 启动与退出浏览器\n\n启动（以 Chrome 为例）：\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\n \noptions = Options()\n# options.add_argument(&quot;--headless&quot;)  # 若需要无头模式，则取消注释\n# 其他可选参数，如禁用 GPU、扩展程序、忽略证书错误等：\n# options.add_argument(&quot;--disable-gpu&quot;)\n# options.add_argument(&quot;--ignore-certificate-errors&quot;)\n \nservice = Service(executable_path=&quot;/path/to/chromedriver&quot;)\ndriver = webdriver.Chrome(service=service, options=options)\n \n# 访问页面\ndriver.get(&quot;www.example.com&quot;)\n\n\n退出：\n\n\ndriver.quit()：关闭所有关联窗口并终止 WebDriver 进程。\n\n\ndriver.close()：仅关闭当前焦点窗口，但如果只有一个窗口，则效果等同 quit()。\n\n\ndriver.close()  # 关闭当前窗口\ndriver.quit()   # 彻底退出\n4.2 页面导航与操作\n\n页面跳转\n\n\ndriver.get(url)：打开指定 URL。\ndriver.back()：后退。\ndriver.forward()：前进。\ndriver.refresh()：刷新当前页面。\n\n\n获取页面信息\n\n\ndriver.title：获取当前页面标题。\ndriver.current_url：获取当前 URL。\ndriver.page_source：获取页面完整 HTML 源代码（字符串形式）。\n\n\n截图\n\n\ndriver.save_screenshot(&quot;screenshot.png&quot;)：保存整页截图。\nelement.screenshot(&quot;elem.png&quot;)：对某个 WebElement 单独截图。\n\n\n五、定位元素（Element Locators）\n定位是使用 Selenium 的核心。Selenium 支持多种定位方式，以下列举常见几种并分别给出示例。\n提示：\n\n在实际项目中，应尽量选择相对稳定且不易更改的定位策略（如 ID、Name、CSS Selector、XPath 等）。\nXPath 强大但复杂，可用于定位动态生成的标签或无法通过其他方式定位时使用；但 XPath 过深可能导致性能下降。\n\n5.1 find_element 与 find_elements 系列接口\n\nfind_element(by, value)：返回匹配到的第一个 WebElement，若找不到则抛出 NoSuchElementException。\nfind_elements(by, value)：返回所有匹配的 WebElement 列表，若找不到则返回空列表（[]）。\n\nfrom selenium.webdriver.common.by import By\n \n# 示例：定位百度首页搜索框\nsearch_input = driver.find_element(By.ID, &quot;kw&quot;)\n# 或者使用 CSS Selector\nsearch_input = driver.find_element(By.CSS_SELECTOR, &quot;input#kw&quot;)\n# XPATH\nsearch_input = driver.find_element(By.XPATH, &quot;//input[@id=&#039;kw&#039;]&quot;)\n5.2 常见定位方式\n\nBy.ID\n\n\n优点：速度快、唯一性强。\n示例：driver.find_element(By.ID, &quot;username&quot;)\n\n\nBy.NAME\n\n\n通过 &lt;input name=&quot;xxx&quot;&gt; 定位，若页面上存在多个同名元素，则返回第一个。\n示例：driver.find_element(By.NAME, &quot;password&quot;)\n\n\nBy.CLASS_NAME\n\n\n通过类名定位，注意若元素的 class 属性中含有多个类名，需提供单个类名字符串。\n示例：driver.find_element(By.CLASS_NAME, &quot;login-button&quot;)\n\n\nBy.TAG_NAME\n\n\n通过标签名定位所有同种标签元素，返回列表或单个元素。\n示例：driver.find_elements(By.TAG_NAME, &quot;a&quot;)（获取页面所有链接）\n\n\nBy.LINK_TEXT（完整匹配文本链接）\n\n\n示例：driver.find_element(By.LINK_TEXT, &quot;下一页&quot;)\n\n\nBy.PARTIAL_LINK_TEXT（部分文本匹配链接）\n\n\n示例：driver.find_element(By.PARTIAL_LINK_TEXT, &quot;更多&quot;)\n\n\nBy.CSS_SELECTOR\n\n\n最常用且兼具速度与灵活性。可使用 ID、类名、属性、层级等组合。\n示例：driver.find_element(By.CSS_SELECTOR, &quot;div.container &gt; ul li:nth-child(2) a&quot;)\n\n\nBy.XPATH\n\n\n功能最强：支持绝对路径、相对路径、属性筛选、文本匹配、逻辑运算等。\n示例：driver.find_element(By.XPATH, &quot;//div[@class=&#039;item&#039;][2]/a[@href=&#039;detail.html&#039;]&quot;)\n\n\n六、操作元素\n在定位到 WebElement 后，可进行点击、输入、获取属性、获取文本等操作。\n6.1 常用方法\n假设已定位到某个输入框和按钮：\nsearch_input = driver.find_element(By.ID, &quot;kw&quot;)\nsearch_button = driver.find_element(By.ID, &quot;su&quot;)\n\n输入文本\n\nsearch_input.clear()            # 清空已有内容（可选）\nsearch_input.send_keys(&quot;Python Selenium 教程&quot;)  # 发送文本\n\n模拟按键操作\n\nfrom selenium.webdriver.common.keys import Keys\n \n# 在输入框中输入后按下回车\nsearch_input.send_keys(Keys.ENTER)\n# 组合键示例：CTRL+A（全选）、DELETE\nsearch_input.send_keys(Keys.CONTROL, &#039;a&#039;)\nsearch_input.send_keys(Keys.DELETE)\n\n点击元素\n\nsearch_button.click()\n\n获取元素属性与文本\n\n# 获取标签属性，例如 href、value、id 等\nhref_value = link_element.get_attribute(&quot;href&quot;)\n# 获取元素可见文本\ntext_content = element.text\n\n执行 JavaScript\n\n\n在某些需要滚动到可见区域或调用 JS 函数的场景下，可通过 execute_script 执行 JS 代码：\n\n# 滚动到页面底部\ndriver.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight);&quot;)\n# 让某个元素在 JS 层面点击（适用于 click 无效时）\ndriver.execute_script(&quot;arguments[0].click();&quot;, element)\n# 修改元素属性值\ndriver.execute_script(&quot;arguments[0].setAttribute(&#039;style&#039;, &#039;border: 2px solid red;&#039;);&quot;, element)\n\n选中复选框/单选框\n\ncheckbox = driver.find_element(By.ID, &quot;rememberMe&quot;)\nif not checkbox.is_selected():\n    checkbox.click()\n\n下拉列表（Select）\n\n\n需要先导入 selenium.webdriver.support.ui.Select 类，将 &lt;select&gt; 元素封装成 Select 对象，进而使用索引、可见文本或 value 来选择项：\n\nfrom selenium.webdriver.support.ui import Select\n \nselect_element = driver.find_element(By.ID, &quot;dropdown&quot;)\nselect_obj = Select(select_element)\nselect_obj.select_by_visible_text(&quot;选项二&quot;)\nselect_obj.select_by_value(&quot;option2&quot;)\nselect_obj.select_by_index(1)\n# 若允许多选，可使用 select_obj.deselect_all() 等方法取消选择\n\n七、等待机制（Implicit Wait 与 Explicit Wait）\n在实际使用中，由于页面加载速度、Ajax 异步加载等原因，若直接去定位还未加载到 DOM 树上的元素，则会抛出 NoSuchElementException。为解决此问题，Selenium 提供了两类等待方式：\n7.1 隐式等待（Implicit Wait）\n\n通过 driver.implicitly_wait(seconds) 设置隐式等待后，在后续的所有 find_element 或 find_elements 操作中，会等待元素出现，最长等待时间为 seconds 秒。若元素在此期间出现，则立即返回。\n\ndriver.implicitly_wait(10)  # 全局设置，最长等 10 秒\ndriver.get(&quot;www.example.com&quot;)\nelement = driver.find_element(By.ID, &quot;delayedElement&quot;)  # 若 10 秒内出现，则继续；否则抛出错误\n\n\n优缺点：\n\n\n优点：简单、代码侵入少。\n\n\n缺点：全局生效，影响整个 WebDriver，有时会导致实际有的场景短暂延迟也要等待指定时间；对特定元素等待失去灵活性。\n\n\n7.2 显式等待（Explicit Wait）\n\n通过 WebDriverWait 搭配 expected_conditions，实现对某一特定元素或条件的等待。例如等待某个元素可点击、可见、存在于 DOM 等。\n\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n \ndriver.get(&quot;www.example.com&quot;)\n \n# 最多等待 15 秒，每 0.5 秒轮询一次，直到元素可点击\nwait = WebDriverWait(driver, 15, poll_frequency=0.5)\n \n# 例：等待 ID 为 submit 的按钮可点击\nsubmit_btn = wait.until(\n    EC.element_to_be_clickable((By.ID, &quot;submit&quot;))\n)\nsubmit_btn.click()\n \n# 例：等待 CSS 选择器为 .result-list 出现\nresults = wait.until(\n    EC.presence_of_element_located((By.CSS_SELECTOR, &quot;.result-list&quot;))\n)\n\n\n常见的 Expected Conditions：\n\n\npresence_of_element_located((by, locator))：元素存在于 DOM，但不一定可见。\n\n\nvisibility_of_element_located((by, locator))：元素存在于 DOM 且可见（height &amp; width &gt; 0）。\n\n\nelement_to_be_clickable((by, locator))：元素可点击（可见且 enabled）。\n\n\ntext_to_be_present_in_element((by, locator), text_)：等待某元素内出现指定文本。\n\n\nalert_is_present()：等待弹窗出现。\n\n\nframe_to_be_available_and_switch_to_it((by, locator))：等待并切换到指定 iframe。\n\n\n注意：显式等待与隐式等待混合使用时，可能会出现不可预见的超时行为，建议只使用一种方式，或将隐式等待设置为较短值，主要以显式等待为主。\n\n\n\n八、浏览器控制与特殊场景\n8.1 窗口与标签页切换\n在自动化流程中，常见会点击某个链接或操作后打开新的窗口/标签，此时需要切换 WebDriver 的句柄到新窗口。\n# 打开页面\ndriver.get(&quot;www.example.com&quot;)\n \n# 点击某个打开新窗口的链接\ndriver.find_element(By.LINK_TEXT, &quot;打开新窗口&quot;).click()\n \n# 获取所有句柄\nall_handles = driver.window_handles  # 列表形式，按打开顺序排列\ncurrent_handle = driver.current_window_handle\n \n# 切换到最新打开的窗口（通常是最后一个）\nfor handle in all_handles:\n    if handle != current_handle:\n        driver.switch_to.window(handle)\n        break\n \n# 现在 driver 操作即在新窗口上\nprint(driver.title)\n \n# 关闭当前窗口，并切回原先窗口\ndriver.close()\ndriver.switch_to.window(current_handle)\nTip：\n\n若并不知道新窗口的 title 或 URL，可在切换前先打印 driver.window_handles 与 driver.current_window_handle 对比。\n切换前最好先做短暂等待（确保新窗口句柄已经产生），如 time.sleep(1) 或显式等待页面某元素出现。\n\n8.2 弹出窗口与对话框（Alert）\n当页面出现 JavaScript 弹窗（alert(), confirm(), prompt()）时，Selenium 提供了 switch_to.alert 来切换并操作。\nfrom selenium.common.exceptions import NoAlertPresentException\n \ntry:\n    # 触发弹窗操作（如点击按钮）\n    driver.find_element(By.ID, &quot;show-alert&quot;).click()\n \n    # 切换到弹窗\n    alert = driver.switch_to.alert\n \n    # 获取弹窗文本\n    text = alert.text\n    print(&quot;Alert 文本：&quot;, text)\n \n    # 接受弹窗（相当于点击“确定”）\n    alert.accept()\n \n    # 或者拒绝弹窗（相当于点击“取消”），用于 confirm()\n    # alert.dismiss()\n \n    # 若是 prompt()，可以先输入文本再 accept()\n    # alert.send_keys(&quot;输入的内容&quot;)\n    # alert.accept()\n \nexcept NoAlertPresentException:\n    print(&quot;当前无弹窗。&quot;)\n8.3 IFrame/Frame 切换\n若要操作位于 &lt;iframe&gt; 或 &lt;frame&gt; 内部的元素，需要先切换至对应 frame。\n# 通过 index 切换（第几个 iframe，索引从 0 开始）\ndriver.switch_to.frame(0)\n \n# 通过 name 或 id 切换\ndriver.switch_to.frame(&quot;frameNameOrId&quot;)\n \n# 通过 WebElement 对象切换\niframe_elem = driver.find_element(By.CSS_SELECTOR, &quot;iframe[class=&#039;content-frame&#039;]&quot;)\ndriver.switch_to.frame(iframe_elem)\n \n# 切换回最外层文档\ndriver.switch_to.default_content()\n8.4 Cookie 操作\n可以读取、添加、删除 Cookie，实现登录状态保持等操作。\n# 获取当前网站所有 cookie，返回 dict 列表\ncookies = driver.get_cookies()\nfor cookie in cookies:\n    print(cookie)\n \n# 添加一个 cookie\ndriver.add_cookie({\n    &quot;name&quot;: &quot;test_cookie&quot;,\n    &quot;value&quot;: &quot;hello_world&quot;,\n    &quot;domain&quot;: &quot;.example.com&quot;,\n    &quot;path&quot;: &quot;/&quot;,\n    # 可选：expires、secure、httpOnly 等\n})\n \n# 删除某个 cookie\ndriver.delete_cookie(&quot;test_cookie&quot;)\n \n# 删除所有 cookie\ndriver.delete_all_cookies()\n8.5 屏幕分辨率与窗口大小控制\n# 获取当前窗口大小\nsize = driver.get_window_size()\nprint(size)  # {&#039;width&#039;: 1200, &#039;height&#039;: 800}\n \n# 设置窗口大小（会改变浏览器可视区域）\ndriver.set_window_size(1366, 768)\n \n# 最大化窗口\ndriver.maximize_window()\n \n# 最小化（将浏览器最小化到任务栏）\ndriver.minimize_window()\n\n九、高级应用\n9.1 浏览器配置与启动选项（Options）\n不同浏览器皆提供了 Options 类，方便添加启动参数、配置用户数据目录、设置代理、禁用通知等。\n以 Chrome 为例：\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\n \nchrome_options = Options()\n \n# 无头模式\nchrome_options.add_argument(&quot;--headless&quot;)\n \n# 禁用 GPU（某些环境下建议加上）\nchrome_options.add_argument(&quot;--disable-gpu&quot;)\n \n# 指定浏览器窗口大小（无头模式下可以设置分辨率）\nchrome_options.add_argument(&quot;--window-size=1920,1080&quot;)\n \n# 隐身模式\nchrome_options.add_argument(&quot;--incognito&quot;)\n \n# 禁用扩展\nchrome_options.add_argument(&quot;--disable-extensions&quot;)\n \n# 禁用通知\nchrome_options.add_argument(&quot;--disable-notifications&quot;)\n \n# 禁用浏览器沙箱（Linux 特殊环境下可能需要）\nchrome_options.add_argument(&quot;--no-sandbox&quot;)\n \n# 使用指定的用户数据目录（可保持已登录的 Session）\nchrome_options.add_argument(r&quot;--user-data-dir=/path/to/your/custom/profile&quot;)\n \n# 设置代理（HTTP/HTTPS）\nchrome_options.add_argument(&quot;--proxy-server=http://127.0.0.1:8080&quot;)\n \n# 通过字典方式设置实验性选项\nprefs = {\n    &quot;profile.default_content_setting_values.notifications&quot;: 2,  # 禁用通知弹框\n    &quot;download.prompt_for_download&quot;: False,  # 禁用下载提示\n    &quot;download.default_directory&quot;: r&quot;/path/to/download&quot;,  # 默认下载路径\n}\nchrome_options.add_experimental_option(&quot;prefs&quot;, prefs)\n \nservice = Service(executable_path=&quot;/path/to/chromedriver&quot;)\ndriver = webdriver.Chrome(service=service, options=chrome_options)\n其他浏览器的 Options\n\nFirefox：from selenium.webdriver.firefox.options import Options，可设置 options.headless = True、options.set_preference(&quot;browser.download.dir&quot;, &quot;/path&quot;) 等。\nEdge：同样有 EdgeOptions。\nSafari 原生支持，无需额外 driver 选项。\n\n9.2 无头模式（Headless）与后台运行\n\n\n适用场景：\n\n\n服务器环境没有图形界面，需在后台进行自动化测试或爬虫。\n\n\n对性能有一定要求时，关闭 UI 能省去渲染开销。\n\n\n注意事项：\n\n\n部分页面在无头模式下表现与有头略有差异，例如 viewport 大小、某些 JS 检测到无头后可能拒绝访问等等。可通过模拟 --window-size、更改 User-Agent 等方式规避。\n\n\n在调试阶段，建议先使用有头模式定位问题，再切换到无头模式执行。\n\n\n9.3 与 JavaScript 的交互\n\n执行任意 JS：通过 driver.execute_script 和 driver.execute_async_script。\n获取 JS 执行结果：若脚本返回值，execute_script 会自动返回相应值（如字符串、数字、字典、列表等可序列化类型，或一个 WebElement 对象）。\n\n# 取 document.title\ntitle = driver.execute_script(&quot;return document.title;&quot;)\n \n# 获取当前页面滚动高度\nheight = driver.execute_script(&quot;return document.body.scrollHeight;&quot;)\n \n# 异步脚本示例：等待 3 秒后返回（callback 方式）\nresult = driver.execute_async_script(&quot;&quot;&quot;\n    var callback = arguments[arguments.length - 1];\n    window.setTimeout(function(){\n        callback(&quot;3 seconds later&quot;);\n    }, 3000);\n&quot;&quot;&quot;)\nprint(result)  # &quot;3 seconds later&quot;\n9.4 处理多标签 &amp; 多窗口 &amp; Cookie &amp; Session\n\n\n已在“窗口切换”与“Cookie 操作”部分玫述，进一步补充：\n\n\nSelenium 每次启动浏览器时都会生成新的临时 Profile（完整隔离环境），若要在同一个浏览器上下文中多次运行脚本、保持登录，可以指定 user-data-dir 并设置 profile-directory。\n\n\n# 使用 Chrome 已存在的用户数据目录（Windows 示例）\nchrome_options.add_argument(r&quot;--user-data-dir=C:\\Users\\&lt;你的用户名&gt;\\AppData\\Local\\Google\\Chrome\\User Data&quot;)\nchrome_options.add_argument(r&#039;--profile-directory=Default&#039;)  # 或者 Profile 1、Profile 2 等\n\n注意： 使用同一个 Profile 时，若手动打开了带有扩展、已经打开的浏览器，二者可能冲突，会提示类似 “cannot open DevTools …” 等，所以建议仅在无人干预的环境中使用。\n\n9.5 文件上传、下载与进度监控\n\n上传文件：Selenium 无法直接打开文件对话框，但可以将 &lt;input type=&quot;file&quot;&gt; 元素的 send_keys 设置为本地文件绝对路径，从而模拟上传。\n\nfile_input = driver.find_element(By.CSS_SELECTOR, &quot;input[type=&#039;file&#039;]&quot;)\nfile_input.send_keys(r&quot;C:\\path\\to\\file.txt&quot;)\n\n\n下载文件：\n\n\n针对 Chrome/Firefox，可以通过配置浏览器首选项，将下载路径定向到指定目录，且取消“每次下载前询问”弹窗。示例已见上文 Options 中 prefs 设置。\n\n\n监控下载进度可在本地对下载目录做轮询：\n\n\nimport time\nimport os\n \ndownload_dir = r&quot;/path/to/download&quot;\nfilename = &quot;report.pdf&quot;\nfile_path = os.path.join(download_dir, filename)\n \n# 发起下载操作\ndriver.find_element(By.ID, &quot;download-btn&quot;).click()\n \n# 简单轮询：等待文件出现且大小不再变化\ntimeout = 60  # 最长等待 60 秒\nstart = time.time()\nwhile True:\n    if os.path.exists(file_path):\n        if os.path.getsize(file_path) &gt; 0:\n            break\n    if time.time() - start &gt; timeout:\n        raise Exception(&quot;下载超时&quot;)\n    time.sleep(1)\nprint(&quot;下载完成&quot;)\n\n十、常见问题与调试思路\n\n**selenium.common.exceptions.NoSuchElementException**\n\n\n\n问题表现：无法定位到元素。\n\n\n排查方向：\n\n\n确认定位方式（ID、XPath、CSS 等）是否正确。\n\n\n确认目标元素在 DOM 中是否存在（使用浏览器 DevTools 查看）。\n\n\n确认是否需要等待（元素是异步加载的？需加显式等待）。\n\n\n确认是否在正确的 frame/iframe 内（若在 iframe 里，需先 switch_to.frame()）。\n\n\n确认定位是针对可见元素还是隐形元素。\n\n\n\n**selenium.common.exceptions.ElementNotInteractableException** / **ElementClickInterceptedException**\n\n\n\n问题表现：元素可见却无法点击或输入。\n\n\n排查方向：\n\n\n是否有遮挡（如弹窗、广告层、灰色蒙层等）。\n\n\n是否需要先滚动到元素可见区域（使用 execute_script(&quot;arguments[0].scrollIntoView();&quot;, element)）。\n\n\n弹窗或浮层是否抢占了焦点（需先关闭或切换）。\n\n\n前后定位的逻辑是否正确（需重新检查）。\n\n\n\n**浏览器驱动版本与浏览器不匹配\n\n\n问题表现：启动报错，如 This version of ChromeDriver only supports Chrome version XX。\n解决：确保 ChromeDriver 与本地 Chrome 浏览器版本对应。可执行 chrome://version/ 查看浏览器版本号，再从 ChromeDriver 官方下载对应版本。\n\n\n**超时（TimeoutException）\n\n\n\n原因：显式等待时条件长时间不满足。\n\n\n排查：\n\n\n检查选择器是否正确。\n\n\n检查是否需要等待页面跳转或 JS 加载完成。\n\n\n适当调整等待时长或换用其他 Expected Condition。\n\n\n\n性能与资源开销\n\n\nSelenium 启动浏览器、渲染页面会消耗较多资源，如 CPU、内存。\n若只是简单抓取文本，不要求 JS 渲染，可考虑使用更轻量的库（如 Requests + BeautifulSoup），仅在必须处理动态渲染时才用 Selenium。\n\n\n网络与隐私问题\n\n\n在某些挖矿脚本较多的网站或做反爬措施的网站上，直接使用 Selenium 通常可绕过简单的反爬；但若部署在云服务器，可能被识别出无头浏览器，需伪装（修改 user-agent、插入随机鼠标移动、合理设置等待等）。\n\n\n十一、示例：综合完整流程\n以下示例以“在百度搜索框输入关键词并点击搜索后，抓取搜索结果标题与链接”作为一个简单的案例，演示从启动浏览器到退出浏览器的完整流程。\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n \ndef main():\n    # 1. 配置 Chrome Options\n    options = Options()\n    options.add_argument(&quot;--headless&quot;)  # 无头模式\n    options.add_argument(&quot;--window-size=1920,1080&quot;)\n \n    # 2. 启动 WebDriver\n    service = Service(executable_path=&quot;/path/to/chromedriver&quot;)\n    driver = webdriver.Chrome(service=service, options=options)\n \n    try:\n        # 3. 访问百度\n        driver.get(&quot;www.baidu.com&quot;)\n \n        # 4. 定位搜索框与按钮，输入关键词并搜索\n        search_input = driver.find_element(By.ID, &quot;kw&quot;)\n        search_input.clear()\n        search_input.send_keys(&quot;Python Selenium 教程&quot;)\n        search_button = driver.find_element(By.ID, &quot;su&quot;)\n        search_button.click()\n \n        # 5. 等待搜索结果加载完毕\n        wait = WebDriverWait(driver, 10)\n        results_ul = wait.until(\n            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;div#content_left&quot;))\n        )\n \n        # 6. 抓取前 5 条搜索结果的标题与链接\n        results = driver.find_elements(By.CSS_SELECTOR, &quot;div#content_left .result-op.c-container&quot;)[:5]\n        for idx, res in enumerate(results, 1):\n            # 每个结果条目里通常包含 &lt;h3&gt; 标签与子 &lt;a&gt; 标签\n            try:\n                title_elem = res.find_element(By.TAG_NAME, &quot;h3&quot;)\n                link_elem = title_elem.find_element(By.TAG_NAME, &quot;a&quot;)\n                title = title_elem.text\n                href = link_elem.get_attribute(&quot;href&quot;)\n                print(f&quot;{idx}. {title}&quot;)\n                print(f&quot;   链接：{href}&quot;)\n            except Exception as e:\n                print(f&quot;第 {idx} 条解析失败：{e}&quot;)\n \n    except Exception as e:\n        print(&quot;运行过程中发生异常：&quot;, e)\n    finally:\n        # 7. 退出浏览器\n        driver.quit()\n \nif __name__ == &quot;__main__&quot;:\n    main()\n\n十二、项目实战建议与最佳实践\n\n目录结构与封装\n\n\n若项目较大，将不同页面/模块的操作封装成 Page Object（页面对象），并将定位与操作分离。例如 pages/home_page.py、pages/login_page.py 等。\n将常用工具与封装（如截图、日志、等待封装）抽取到 utils 或 common 目录中，方便复用。\n\n\n日志与报表\n\n\n对于自动化测试，建议集成 unittest 或 pytest 等框架；执行用例时产生日志或 HTML 报表。\n失败时自动截图，并将截图路径、异常信息记录到日志中，方便排查。\n\n\n资源释放\n\n\n每次脚本结束务必调用 driver.quit()，避免残留浏览器进程。\n对于并发测试、分布式测试，应注意是否需要对浏览器 driver 的并发安全配置进行调整。\n\n\n并发与分布式\n\n\n对于大规模并发自动化测试，可使用 Selenium Grid（集群模式）或第三方平台（如 BrowserStack、Sauce Labs 等）。\n本地执行时，对多线程或多进程并发执行 Selenium，要注意浏览器进程间隔离与资源消耗。\n\n\n等待策略的平衡\n\n\n统一使用显式等待（WebDriverWait + Expected Conditions），减少不必要的 time.sleep()。\n在频繁定位同一元素的地方，可先缓存 WebElement，但需考虑 Stale Element（过期）的问题。\n\n\nAnti-Detection（反检测）\n\n\n对部分网站而言，检测无头浏览器、检查 navigator.webdriver 等方式可能会阻拦。可通过注入 JS、修改 navigator.webdriver=false、使用 undetected-chromedriver 等第三方库绕过。\n但请注意合规与道德风险，尽量在允许范围内对页面进行自动化操作。\n\n\n十三、常见扩展库与工具链\n\nUndetected Chromedriver\n\n\n解决某些网站检测到 Selenium 自动化而阻拦。\n安装：pip install undetected-chromedriver\n用法：\n\nimport undetected_chromedriver as uc\n \ndriver = uc.Chrome()\ndriver.get(&quot;some-anti-bot-website.com&quot;)\n\nSelenium-Base / SeleniumBase\n\n\n在 Selenium 基础上集成了截图、报告、CI 友好、PyTest 兼容等功能。\n安装：pip install seleniumbase\n文档：seleniumbase.io/\n\n\nPyTest + Selenium\n\n\n将 Selenium 测试脚本集成到 pytest 测试框架，利用 fixture 对 WebDriver 进行统一管理，写法更简洁、易于维护。\n示例 conftest.py：\n\nimport pytest\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\n \n@pytest.fixture(scope=&quot;function&quot;)\ndef driver():\n    options = Options()\n    options.add_argument(&quot;--headless&quot;)\n    service = Service(&quot;/path/to/chromedriver&quot;)\n    driver = webdriver.Chrome(service=service, options=options)\n    yield driver\n    driver.quit()\n\n测试用例示例：\n\ndef test_example(driver):\n    driver.get(&quot;www.example.com&quot;)\n    assert &quot;Example Domain&quot; in driver.title\n\n十四、小结\n\nSelenium 是目前最常见、最成熟的 Web 自动化测试与动态爬取工具之一。\n掌握其核心概念（WebDriver、Options、元素定位、等待机制）后，可根据业务场景编写稳定可靠的自动化脚本。\n在实际项目中，应结合页面特点选择合适的定位策略、灵活运用显式等待，并做好异常捕获与日志记录。\n针对无头模式、Anti-Detection、并发场景等复杂需求，可适当引入第三方扩展库（如 undetected-chromedriver）或构建 Selenium Grid 分布式环境。\n永远要注意浏览器版本与驱动版本的一致性，以及对资源（CPU、内存）消耗的监控与优化。\n"},"python/爬虫/requests":{"slug":"python/爬虫/requests","filePath":"python/爬虫/requests.md","title":"requests","links":[],"tags":[],"content":"Python Requests 库完整学习指南\nrequests 模块是 Python 中最受欢迎的 HTTP 客户端库，被誉为”人类友好的 HTTP 库”。它将复杂的 HTTP 协议操作封装成简洁直观的接口，让网络编程变得轻松愉快。无论是进行 API 调用、数据抓取，还是构建 Web 应用的客户端，requests 都是开发者的首选工具。\n\n一、理解 HTTP 基础与 requests 的设计理念\nHTTP 协议核心概念回顾\n在深入学习 requests 之前，让我们先理解它要解决的问题。HTTP（超文本传输协议）是现代互联网的基石，每当你在浏览器中访问网页、提交表单或调用 API 时，都在使用 HTTP 进行通信。\nHTTP 请求包含几个关键组成部分：请求方法（GET、POST 等）、URL、请求头（headers）、请求体（body）。服务器收到请求后返回响应，包含状态码、响应头和响应体。传统的 Python 标准库 urllib 虽然功能完整，但使用起来相当繁琐，需要处理很多底层细节。\nrequests 的设计哲学\nrequests 库的设计遵循”简单胜于复杂”的 Python 哲学。它将常用的 HTTP 操作抽象为简单的函数调用，同时保留了足够的灵活性来处理复杂场景。这种设计让初学者能够快速上手，同时为高级用户提供强大的功能。\n\n二、安装与环境配置\n基础安装\n如果你的系统中尚未安装 requests，可以通过 pip 进行安装：\npip install requests\n对于需要处理特定编码或证书验证的场景，你可能还需要安装额外的依赖：\npip install requests[security]  # 增强安全特性\npip install requests[socks]     # SOCKS 代理支持\n验证安装\n安装完成后，可以通过简单的代码验证是否正常工作：\nimport requests\nprint(requests.__version__)  # 查看版本信息\nresponse = requests.get(&#039;httpbin.org/get&#039;)\nprint(f&quot;状态码: {response.status_code}&quot;)  # 应该输出 200\n\n三、核心概念与基本用法\n1. 理解请求方法\nHTTP 定义了多种请求方法，每种都有特定的语义和用途：\nimport requests\n \n# GET - 获取资源（幂等操作，不应产生副作用）\nresponse = requests.get(&#039;httpbin.org/get&#039;)\nprint(f&quot;GET 请求状态码: {response.status_code}&quot;)\n \n# POST - 创建新资源或提交数据（非幂等，会产生副作用）\ndata = {&#039;name&#039;: &#039;张三&#039;, &#039;age&#039;: 25}\nresponse = requests.post(&#039;httpbin.org/post&#039;, data=data)\nprint(f&quot;POST 请求响应: {response.json()}&quot;)\n \n# PUT - 更新完整资源（幂等操作）\nuser_data = {&#039;id&#039;: 1, &#039;name&#039;: &#039;李四&#039;, &#039;email&#039;: &#039;lisi@example.com&#039;}\nresponse = requests.put(&#039;httpbin.org/put&#039;, json=user_data)\n \n# PATCH - 部分更新资源\nupdate_data = {&#039;email&#039;: &#039;newemail@example.com&#039;}\nresponse = requests.patch(&#039;httpbin.org/patch&#039;, json=update_data)\n \n# DELETE - 删除资源（幂等操作）\nresponse = requests.delete(&#039;httpbin.org/delete&#039;)\n理解这些方法的语义很重要，因为它们不仅仅是技术实现，更体现了 RESTful API 的设计原则。\n2. 深入理解请求参数\nURL 参数（Query Parameters）\nURL 参数用于向服务器传送额外信息，通常用于过滤、排序或分页：\n# 手动构造 URL（不推荐）\nurl = &#039;api.example.com/users#039;\n \n# 使用 params 参数（推荐）\nbase_url = &#039;api.example.com/users&#039;\nparams = {\n    &#039;page&#039;: 2,\n    &#039;limit&#039;: 10,\n    &#039;sort&#039;: &#039;name&#039;,\n    &#039;active&#039;: True  # 布尔值会自动转换为字符串\n}\nresponse = requests.get(base_url, params=params)\nprint(f&quot;实际请求的 URL: {response.url}&quot;)\n使用 params 参数的好处是 requests 会自动处理 URL 编码，避免特殊字符带来的问题。\n请求体数据的不同格式\n根据 API 的要求，你需要选择合适的数据格式：\n# 表单数据（application/x-www-form-urlencoded）\n# 适用于传统的 HTML 表单提交\nform_data = {&#039;username&#039;: &#039;admin&#039;, &#039;password&#039;: &#039;secret&#039;}\nresponse = requests.post(&#039;httpbin.org/post&#039;, data=form_data)\n \n# JSON 数据（application/json）\n# 现代 API 的主流格式\njson_data = {&#039;user&#039;: {&#039;name&#039;: &#039;王五&#039;, &#039;skills&#039;: [&#039;Python&#039;, &#039;JavaScript&#039;]}}\nresponse = requests.post(&#039;httpbin.org/post&#039;, json=json_data)\n \n# 文件上传（multipart/form-data）\n# 用于上传文件或二进制数据\nfiles = {&#039;avatar&#039;: open(&#039;profile.jpg&#039;, &#039;rb&#039;)}\ndata = {&#039;user_id&#039;: &#039;12345&#039;}  # 可以同时传送其他字段\nresponse = requests.post(&#039;httpbin.org/post&#039;, files=files, data=data)\n \n# 原始数据（自定义 Content-Type）\nraw_data = &#039;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;user&gt;&lt;name&gt;赵六&lt;/name&gt;&lt;/user&gt;&#039;\nheaders = {&#039;Content-Type&#039;: &#039;application/xml&#039;}\nresponse = requests.post(&#039;httpbin.org/post&#039;, data=raw_data, headers=headers)\n3. 请求头的重要性\n请求头包含了关于请求的元信息，很多时候是成功与否的关键：\n# 基础请求头设置\nheaders = {\n    &#039;User-Agent&#039;: &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#039;,\n    &#039;Accept&#039;: &#039;application/json&#039;,  # 告诉服务器我们期望的响应格式\n    &#039;Accept-Language&#039;: &#039;zh-CN,zh;q=0.9,en;q=0.8&#039;,  # 语言偏好\n    &#039;Referer&#039;: &#039;example.com&#039;,  # 来源页面\n    &#039;Authorization&#039;: &#039;Bearer your-jwt-token-here&#039;  # 身份验证令牌\n}\n \nresponse = requests.get(&#039;api.example.com/data&#039;, headers=headers)\n不同的请求头有不同的作用：User-Agent 标识客户端类型，Accept 指定期望的响应格式，Authorization 用于身份验证等。\n\n四、响应对象深度解析\nResponse 对象的完整属性\n当你发送请求后，requests 返回一个 Response 对象，它包含了服务器响应的所有信息：\nresponse = requests.get(&#039;httpbin.org/json&#039;)\n \n# 状态相关信息\nprint(f&quot;状态码: {response.status_code}&quot;)  # 200, 404, 500 等\nprint(f&quot;状态描述: {response.reason}&quot;)     # OK, Not Found, Internal Server Error\nprint(f&quot;是否成功: {response.ok}&quot;)         # status_code &lt; 400 时为 True\n \n# URL 相关信息\nprint(f&quot;请求的原始 URL: {response.url}&quot;)\nprint(f&quot;响应历史: {response.history}&quot;)    # 如果有重定向，显示重定向链\n \n# 响应内容\nprint(f&quot;文本内容: {response.text}&quot;)       # 自动解码的字符串\nprint(f&quot;字节内容: {response.content}&quot;)    # 原始字节数据\nprint(f&quot;JSON 数据: {response.json()}&quot;)    # 解析为 Python 对象\n \n# 响应头信息\nprint(f&quot;响应头: {response.headers}&quot;)\nprint(f&quot;内容类型: {response.headers[&#039;Content-Type&#039;]}&quot;)\n \n# 编码信息\nprint(f&quot;检测到的编码: {response.encoding}&quot;)\nprint(f&quot;表观编码: {response.apparent_encoding}&quot;)  # 基于内容猜测的编码\n处理不同类型的响应内容\n# 处理 JSON 响应\ntry:\n    data = response.json()  # 自动解析 JSON\n    print(f&quot;解析的数据: {data}&quot;)\nexcept ValueError as e:  # JSON 解析失败\n    print(f&quot;响应不是有效的 JSON: {e}&quot;)\n \n# 处理二进制内容（图片、PDF 等）\nimg_response = requests.get(&#039;httpbin.org/image/png&#039;)\nwith open(&#039;downloaded_image.png&#039;, &#039;wb&#039;) as f:\n    f.write(img_response.content)  # 使用 content 而不是 text\n \n# 处理大文件（流式下载）\nlarge_file_response = requests.get(&#039;example.com/largefile.zip&#039;, stream=True)\nwith open(&#039;largefile.zip&#039;, &#039;wb&#039;) as f:\n    for chunk in large_file_response.iter_content(chunk_size=8192):\n        if chunk:  # 过滤掉保持连接的空块\n            f.write(chunk)\n\n五、高级功能详解\n1. 会话管理：持久连接与状态保持\nSession 对象是 requests 的强大功能之一，它可以在多个请求之间保持连接和状态：\n# 创建会话对象\nsession = requests.Session()\n \n# 设置会话级别的配置\nsession.headers.update({\n    &#039;User-Agent&#039;: &#039;MyApp/1.0&#039;,\n    &#039;Accept&#039;: &#039;application/json&#039;\n})\n \n# 模拟登录流程\nlogin_data = {&#039;username&#039;: &#039;admin&#039;, &#039;password&#039;: &#039;secret&#039;}\nlogin_response = session.post(&#039;example.com/login&#039;, data=login_data)\n \nif login_response.ok:\n    # 登录成功后，session 会自动保存 cookies\n    # 后续请求会自动携带这些 cookies\n    protected_response = session.get(&#039;example.com/protected-data&#039;)\n    print(&quot;成功访问受保护的资源&quot;)\nelse:\n    print(&quot;登录失败&quot;)\n \n# 会话对象还能提高性能（连接复用）\nfor i in range(10):\n    response = session.get(f&#039;api.example.com/data/{i}&#039;)\n    # 这些请求会复用 TCP 连接，减少握手开销\n2. 超时控制：避免程序假死\n网络请求可能因为各种原因变得很慢，合理的超时设置是稳定程序的关键：\n# 简单超时（总时间限制）\ntry:\n    response = requests.get(&#039;httpbin.org/delay/10&#039;, timeout=5)\nexcept requests.exceptions.Timeout:\n    print(&quot;请求超时了&quot;)\n \n# 精细超时控制（连接超时，读取超时）\ntry:\n    response = requests.get(\n        &#039;httpbin.org/delay/3&#039;,\n        timeout=(3.05, 27)  # (连接超时, 读取超时)\n    )\nexcept requests.exceptions.ConnectTimeout:\n    print(&quot;连接超时&quot;)\nexcept requests.exceptions.ReadTimeout:\n    print(&quot;读取超时&quot;)\n连接超时是建立 TCP 连接的时间限制，读取超时是服务器开始响应后的数据传输时间限制。\n3. 异常处理：构建健壮的网络应用\n网络编程中异常处理至关重要，requests 提供了层次化的异常体系：\nimport requests\nfrom requests.exceptions import RequestException, HTTPError, ConnectionError, Timeout\n \ndef robust_request(url, max_retries=3):\n    &quot;&quot;&quot;一个具有重试机制的健壮请求函数&quot;&quot;&quot;\n    for attempt in range(max_retries):\n        try:\n            response = requests.get(url, timeout=10)\n            response.raise_for_status()  # 检查 HTTP 状态码\n            return response\n        \n        except HTTPError as e:\n            print(f&quot;HTTP 错误 (尝试 {attempt + 1}): {e.response.status_code}&quot;)\n            if e.response.status_code == 404:\n                # 404 错误通常不需要重试\n                raise\n                \n        except ConnectionError:\n            print(f&quot;连接错误 (尝试 {attempt + 1})&quot;)\n            \n        except Timeout:\n            print(f&quot;超时错误 (尝试 {attempt + 1})&quot;)\n            \n        except RequestException as e:\n            print(f&quot;其他请求错误 (尝试 {attempt + 1}): {e}&quot;)\n        \n        if attempt &lt; max_retries - 1:\n            time.sleep(2 ** attempt)  # 指数退避\n    \n    raise RequestException(f&quot;在 {max_retries} 次尝试后仍然失败&quot;)\n \n# 使用示例\ntry:\n    response = robust_request(&#039;httpbin.org/status/503&#039;)\n    print(&quot;请求成功&quot;)\nexcept RequestException:\n    print(&quot;请求最终失败&quot;)\n4. 身份验证：多种认证方式\n现代 Web 应用使用各种身份验证机制：\nfrom requests.auth import HTTPBasicAuth, HTTPDigestAuth\n \n# HTTP 基本认证\nresponse = requests.get(\n    &#039;httpbin.org/basic-auth/user/pass&#039;,\n    auth=HTTPBasicAuth(&#039;user&#039;, &#039;pass&#039;)\n)\n \n# 简化写法\nresponse = requests.get(\n    &#039;httpbin.org/basic-auth/user/pass&#039;,\n    auth=(&#039;user&#039;, &#039;pass&#039;)\n)\n \n# HTTP 摘要认证\nresponse = requests.get(\n    &#039;httpbin.org/digest-auth/auth/user/pass&#039;,\n    auth=HTTPDigestAuth(&#039;user&#039;, &#039;pass&#039;)\n)\n \n# Bearer Token 认证（常用于 API）\nheaders = {&#039;Authorization&#039;: &#039;Bearer your-access-token-here&#039;}\nresponse = requests.get(&#039;api.example.com/data&#039;, headers=headers)\n \n# 自定义认证类\nclass APIKeyAuth:\n    def __init__(self, api_key):\n        self.api_key = api_key\n    \n    def __call__(self, request):\n        request.headers[&#039;X-API-Key&#039;] = self.api_key\n        return request\n \nresponse = requests.get(&#039;api.example.com/data&#039;, auth=APIKeyAuth(&#039;your-api-key&#039;))\n\n六、网络爬虫应用实战\n理解爬虫的工作原理\n网络爬虫本质上是模拟人类浏览网页的行为，通过发送 HTTP 请求获取网页内容，然后从中提取有用信息。requests 在爬虫系统中扮演着”网络通信引擎”的角色。\n一个典型的爬虫工作流程包括：构造请求 → 发送请求 → 获取响应 → 解析内容 → 提取数据 → 存储数据 → 处理反爬策略。\n1. 模拟真实浏览器行为\n许多网站会检查请求的特征来区分人类用户和机器人：\nimport random\nimport time\n \n# 构造真实的浏览器请求头\nuser_agents = [\n    &#039;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&#039;,\n    &#039;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36&#039;,\n    &#039;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36&#039;\n]\n \ndef create_realistic_headers():\n    return {\n        &#039;User-Agent&#039;: random.choice(user_agents),\n        &#039;Accept&#039;: &#039;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#039;,\n        &#039;Accept-Language&#039;: &#039;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#039;,\n        &#039;Accept-Encoding&#039;: &#039;gzip, deflate&#039;,\n        &#039;DNT&#039;: &#039;1&#039;,\n        &#039;Connection&#039;: &#039;keep-alive&#039;,\n        &#039;Upgrade-Insecure-Requests&#039;: &#039;1&#039;\n    }\n \ndef crawl_with_delays(urls):\n    &quot;&quot;&quot;带有随机延时的爬虫函数&quot;&quot;&quot;\n    session = requests.Session()\n    \n    for url in urls:\n        # 随机延时，模拟人类行为\n        time.sleep(random.uniform(1, 3))\n        \n        headers = create_realistic_headers()\n        try:\n            response = session.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n            \n            print(f&quot;成功爬取: {url} (状态码: {response.status_code})&quot;)\n            # 这里处理响应内容...\n            \n        except requests.exceptions.RequestException as e:\n            print(f&quot;爬取失败 {url}: {e}&quot;)\n2. 处理 Cookies 和会话状态\n许多网站需要维持会话状态才能正常访问：\ndef login_and_crawl():\n    &quot;&quot;&quot;登录后爬取受保护内容的示例&quot;&quot;&quot;\n    session = requests.Session()\n    \n    # 第一步：访问登录页面，获取 CSRF token 等信息\n    login_page = session.get(&#039;example.com/login&#039;)\n    # 这里可能需要解析页面获取隐藏的表单字段\n    \n    # 第二步：提交登录表单\n    login_data = {\n        &#039;username&#039;: &#039;your_username&#039;,\n        &#039;password&#039;: &#039;your_password&#039;,\n        # &#039;csrf_token&#039;: extracted_csrf_token  # 如果需要的话\n    }\n    \n    login_response = session.post(&#039;example.com/login&#039;, data=login_data)\n    \n    if &#039;欢迎&#039; in login_response.text:  # 简单的登录成功判断\n        print(&quot;登录成功&quot;)\n        \n        # 第三步：访问需要登录的页面\n        protected_content = session.get(&#039;example.com/protected-area&#039;)\n        return protected_content.text\n    else:\n        print(&quot;登录失败&quot;)\n        return None\n3. 代理池管理\n当需要大规模爬取或绕过 IP 限制时，代理池是常用策略：\nimport itertools\n \nclass ProxyManager:\n    def __init__(self, proxy_list):\n        self.proxy_list = proxy_list\n        self.proxy_cycle = itertools.cycle(proxy_list)  # 创建循环迭代器\n        self.failed_proxies = set()\n    \n    def get_next_proxy(self):\n        &quot;&quot;&quot;获取下一个可用代理&quot;&quot;&quot;\n        attempts = 0\n        while attempts &lt; len(self.proxy_list):\n            proxy = next(self.proxy_cycle)\n            if proxy not in self.failed_proxies:\n                return proxy\n            attempts += 1\n        return None  # 所有代理都失效了\n    \n    def mark_proxy_failed(self, proxy):\n        &quot;&quot;&quot;标记代理失效&quot;&quot;&quot;\n        self.failed_proxies.add(proxy)\n        print(f&quot;代理 {proxy} 已标记为失效&quot;)\n \ndef crawl_with_proxy_rotation(urls):\n    &quot;&quot;&quot;使用代理轮换的爬虫&quot;&quot;&quot;\n    proxy_list = [\n        {&#039;http&#039;: &#039;http://proxy1:8080&#039;, &#039;https&#039;: &#039;https://proxy1:8080&#039;},\n        {&#039;http&#039;: &#039;http://proxy2:8080&#039;, &#039;https&#039;: &#039;https://proxy2:8080&#039;},\n        # 更多代理...\n    ]\n    \n    proxy_manager = ProxyManager(proxy_list)\n    session = requests.Session()\n    \n    for url in urls:\n        current_proxy = proxy_manager.get_next_proxy()\n        if not current_proxy:\n            print(&quot;没有可用的代理了&quot;)\n            break\n            \n        try:\n            response = session.get(\n                url, \n                proxies=current_proxy,\n                timeout=10,\n                headers=create_realistic_headers()\n            )\n            response.raise_for_status()\n            print(f&quot;使用代理 {current_proxy} 成功爬取: {url}&quot;)\n            \n        except requests.exceptions.RequestException as e:\n            print(f&quot;使用代理 {current_proxy} 爬取失败: {e}&quot;)\n            proxy_manager.mark_proxy_failed(current_proxy)\n4. 处理反爬虫机制\n现代网站采用多种反爬虫技术，了解这些机制有助于制定对策：\ndef handle_rate_limiting():\n    &quot;&quot;&quot;处理速率限制的策略&quot;&quot;&quot;\n    session = requests.Session()\n    retry_after = 1  # 初始重试间隔\n    \n    def make_request(url):\n        nonlocal retry_after\n        \n        try:\n            response = session.get(url, timeout=10)\n            \n            if response.status_code == 429:  # Too Many Requests\n                # 检查 Retry-After 头\n                retry_after = int(response.headers.get(&#039;Retry-After&#039;, retry_after * 2))\n                print(f&quot;触发速率限制，等待 {retry_after} 秒&quot;)\n                time.sleep(retry_after)\n                return make_request(url)  # 递归重试\n            \n            response.raise_for_status()\n            retry_after = 1  # 重置重试间隔\n            return response\n            \n        except requests.exceptions.RequestException as e:\n            print(f&quot;请求失败: {e}&quot;)\n            return None\n    \n    return make_request\n \n# 使用示例\nsmart_request = handle_rate_limiting()\nresponse = smart_request(&#039;api.example.com/data&#039;)\n\n七、性能优化与最佳实践\n1. 连接池与会话复用\n理解 requests 的连接管理机制对性能优化很重要：\nimport concurrent.futures\nimport time\n \n# 不推荐：每次请求都创建新连接\ndef inefficient_requests(urls):\n    start_time = time.time()\n    for url in urls:\n        response = requests.get(url)  # 每次都建立新连接\n        print(f&quot;状态码: {response.status_code}&quot;)\n    print(f&quot;耗时: {time.time() - start_time:.2f} 秒&quot;)\n \n# 推荐：使用会话复用连接\ndef efficient_requests(urls):\n    start_time = time.time()\n    session = requests.Session()\n    for url in urls:\n        response = session.get(url)  # 复用连接\n        print(f&quot;状态码: {response.status_code}&quot;)\n    print(f&quot;耗时: {time.time() - start_time:.2f} 秒&quot;)\n \n# 进一步优化：并发请求（注意控制并发数量）\ndef concurrent_requests(urls, max_workers=5):\n    start_time = time.time()\n    \n    def fetch_url(url):\n        session = requests.Session()  # 每个线程使用独立的会话\n        response = session.get(url)\n        return response.status_code\n    \n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = [executor.submit(fetch_url, url) for url in urls]\n        results = [future.result() for future in concurrent.futures.as_completed(futures)]\n    \n    print(f&quot;并发请求耗时: {time.time() - start_time:.2f} 秒&quot;)\n    return results\n2. 流式处理大文件\n当处理大文件时，内存管理变得至关重要：\ndef download_large_file(url, filename):\n    &quot;&quot;&quot;流式下载大文件，避免内存溢出&quot;&quot;&quot;\n    with requests.get(url, stream=True) as response:\n        response.raise_for_status()\n        \n        # 获取文件大小（如果服务器提供的话）\n        total_size = int(response.headers.get(&#039;Content-Length&#039;, 0))\n        downloaded_size = 0\n        \n        with open(filename, &#039;wb&#039;) as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:  # 过滤掉保持连接的空块\n                    file.write(chunk)\n                    downloaded_size += len(chunk)\n                    \n                    # 显示下载进度\n                    if total_size &gt; 0:\n                        progress = (downloaded_size / total_size) * 100\n                        print(f&quot;\\r下载进度: {progress:.1f}%&quot;, end=&#039;&#039;, flush=True)\n        \n        print(f&quot;\\n下载完成: {filename}&quot;)\n \n# 使用示例\ndownload_large_file(&#039;example.com/large-dataset.zip&#039;, &#039;dataset.zip&#039;)\n3. 错误处理与重试策略\n构建健壮的网络应用需要全面的错误处理：\nfrom functools import wraps\nimport random\n \ndef retry_on_failure(max_retries=3, backoff_factor=1, status_forcelist=None):\n    &quot;&quot;&quot;装饰器：为函数添加重试机制&quot;&quot;&quot;\n    if status_forcelist is None:\n        status_forcelist = [500, 502, 503, 504]\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            \n            for attempt in range(max_retries):\n                try:\n                    response = func(*args, **kwargs)\n                    \n                    # 检查是否需要重试的状态码\n                    if hasattr(response, &#039;status_code&#039;) and response.status_code in status_forcelist:\n                        raise requests.exceptions.HTTPError(f&quot;HTTP {response.status_code}&quot;)\n                    \n                    return response\n                    \n                except (requests.exceptions.RequestException, requests.exceptions.HTTPError) as e:\n                    last_exception = e\n                    if attempt &lt; max_retries - 1:\n                        # 指数退避 + 随机抖动\n                        sleep_time = backoff_factor * (2 ** attempt) + random.uniform(0, 1)\n                        print(f&quot;第 {attempt + 1} 次尝试失败，{sleep_time:.2f} 秒后重试...&quot;)\n                        time.sleep(sleep_time)\n                    else:\n                        print(f&quot;所有重试尝试都失败了&quot;)\n            \n            raise last_exception\n        \n        return wrapper\n    return decorator\n \n# 使用示例\n@retry_on_failure(max_retries=3, backoff_factor=2)\ndef reliable_get(url, **kwargs):\n    return requests.get(url, **kwargs)\n \n# 现在这个函数具有自动重试能力\nresponse = reliable_get(&#039;httpbin.org/status/503&#039;, timeout=5)\n\n八、安全考虑与最佳实践\n1. SSL/TLS 证书验证\n在生产环境中，正确处理 SSL 证书至关重要：\n# 默认情况下，requests 会验证 SSL 证书\nresponse = requests.get(&#039;www.google.com&#039;)  # 安全\n \n# 危险操作：跳过证书验证（仅用于测试）\nimport urllib3\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\nresponse = requests.get(&#039;self-signed.badssl.com&#039;, verify=False)\n \n# 推荐做法：使用自定义证书或证书包\nresponse = requests.get(&#039;example.com&#039;, verify=&#039;/path/to/certificate.pem&#039;)\n \n# 为企业内部 CA 配置证书验证\nimport ssl\nimport certifi\n \ndef create_secure_session():\n    session = requests.Session()\n    # 使用系统证书存储\n    session.verify = certifi.where()\n    return session\n2. 敏感信息处理\n避免在代码中硬编码敏感信息：\nimport os\nfrom urllib.parse import urljoin\n \nclass APIClient:\n    def __init__(self):\n        # 从环境变量读取敏感配置\n        self.base_url = os.getenv(&#039;API_BASE_URL&#039;, &#039;api.example.com&#039;)\n        self.api_key = os.getenv(&#039;API_KEY&#039;)\n        \n        if not self.api_key:\n            raise ValueError(&quot;API_KEY 环境变量未设置&quot;)\n        \n        self.session = requests.Session()\n        self.session.headers.update({\n            &#039;Authorization&#039;: f&#039;Bearer {self.api_key}&#039;,\n            &#039;User-Agent&#039;: &#039;MyApp/1.0&#039;\n        })\n    \n    def get(self, endpoint, **kwargs):\n        url = urljoin(self.base_url, endpoint)\n        return self.session.get(url, **kwargs)\n    \n    def post(self, endpoint, **kwargs):\n        url = urljoin(self.base_url, endpoint)\n        return self.session.post(url, **kwargs)\n \n# 使用示例\n# export API_KEY=&quot;your-secret-key&quot;\n# export API_BASE_URL=&quot;api.example.com&quot;\nclient = APIClient()\nresponse = client.get(&#039;/users/profile&#039;)\n3. 防止请求伪造和注入攻击\n在处理用户输入时要格外小心：\nfrom urllib.parse import quote, urljoin\nimport re\n \ndef safe_url_builder(base_url, path, params=None):\n    &quot;&quot;&quot;安全构建 URL，防止注入攻击&quot;&quot;&quot;\n    # 验证基础 URL 格式\n    if not re.match(r&#039;^https?://&#039;, base_url):\n        raise ValueError(&quot;无效的基础 URL&quot;)\n    \n    # 清理路径，防止路径遍历攻击\n    safe_path = quote(path.strip(&#039;/&#039;), safe=&#039;/&#039;)\n    \n    # 构建完整 URL\n    full_url = urljoin(base_url.rstrip(&#039;/&#039;) + &#039;/&#039;, safe_path)\n    \n    if params:\n        # requests 会自动处理参数编码\n        response = requests.get(full_url, params=params)\n    else:\n        response = requests.get(full_url)\n    \n    return response\n \n# 安全使用示例\nuser_input = &quot;../../../etc/passwd&quot;  # 恶意输入\ntry:\n    response = safe_url_builder(&#039;api.example.com&#039;, user_input)\nexcept ValueError as e:\n    print(f&quot;安全检查失败: {e}&quot;)\n\n九、高级应用场景\n1. API 客户端开发\n创建一个功能完整的 API 客户端类：\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\n \nclass RESTAPIClient:\n    &quot;&quot;&quot;通用 REST API 客户端基类&quot;&quot;&quot;\n    \n    def __init__(self, base_url: str, auth_token: str = None, timeout: int = 30):\n        self.base_url = base_url.rstrip(&#039;/&#039;)\n        self.timeout = timeout\n        self.session = requests.Session()\n        \n        # 设置默认请求头\n        self.session.headers.update({\n            &#039;Content-Type&#039;: &#039;application/json&#039;,\n            &#039;Accept&#039;: &#039;application/json&#039;,\n            &#039;User-Agent&#039;: &#039;Python-APIClient/1.0&#039;\n        })\n        \n        if auth_token:\n            self.session.headers[&#039;Authorization&#039;] = f&#039;Bearer {auth_token}&#039;\n        \n        # 令牌过期时间跟踪\n        self.token_expires_at = None\n    \n    def _make_request(self, method: str, endpoint: str, **kwargs) -&gt; requests.Response:\n        &quot;&quot;&quot;发送请求的内部方法&quot;&quot;&quot;\n        url = f&quot;{self.base_url}/{endpoint.lstrip(&#039;/&#039;)}&quot;\n        \n        # 设置默认超时\n        kwargs.setdefault(&#039;timeout&#039;, self.timeout)\n        \n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n            \n        except requests.exceptions.HTTPError as e:\n            # 处理特定的 HTTP 错误\n            if e.response.status_code == 401:\n                raise APIAuthenticationError(&quot;身份验证失败&quot;)\n            elif e.response.status_code == 429:\n                raise APIRateLimitError(&quot;API 调用频率超限&quot;)\n            else:\n                raise APIError(f&quot;API 调用失败: {e.response.status_code}&quot;)\n        \n        except requests.exceptions.RequestException as e:\n            raise APIConnectionError(f&quot;网络连接失败: {e}&quot;)\n    \n    def get(self, endpoint: str, params: Dict = None, **kwargs) -&gt; Dict[str, Any]:\n        &quot;&quot;&quot;GET 请求&quot;&quot;&quot;\n        response = self._make_request(&#039;GET&#039;, endpoint, params=params, **kwargs)\n        return response.json()\n    \n    def post(self, endpoint: str, data: Dict = None, **kwargs) -&gt; Dict[str, Any]:\n        &quot;&quot;&quot;POST 请求&quot;&quot;&quot;\n        if data:\n            kwargs[&#039;json&#039;] = data\n        response = self._make_request(&#039;POST&#039;, endpoint, **kwargs)\n        return response.json()\n    \n    def put(self, endpoint: str, data: Dict = None, **kwargs) -&gt; Dict[str, Any]:\n        &quot;&quot;&quot;PUT 请求&quot;&quot;&quot;\n        if data:\n            kwargs[&#039;json&#039;] = data\n        response = self._make_request(&#039;PUT&#039;, endpoint, **kwargs)\n        return response.json()\n    \n    def delete(self, endpoint: str, **kwargs) -&gt; bool:\n        &quot;&quot;&quot;DELETE 请求&quot;&quot;&quot;\n        response = self._make_request(&#039;DELETE&#039;, endpoint, **kwargs)\n        return response.status_code == 204\n    \n    def refresh_token(self, refresh_token: str) -&gt; str:\n        &quot;&quot;&quot;刷新访问令牌&quot;&quot;&quot;\n        data = {&#039;refresh_token&#039;: refresh_token}\n        response = self.post(&#039;/auth/refresh&#039;, data)\n        \n        new_token = response[&#039;access_token&#039;]\n        self.session.headers[&#039;Authorization&#039;] = f&#039;Bearer {new_token}&#039;\n        \n        # 更新过期时间\n        expires_in = response.get(&#039;expires_in&#039;, 3600)\n        self.token_expires_at = datetime.now() + timedelta(seconds=expires_in)\n        \n        return new_token\n \n# 自定义异常类\nclass APIError(Exception):\n    pass\n \nclass APIAuthenticationError(APIError):\n    pass\n \nclass APIRateLimitError(APIError):\n    pass\n \nclass APIConnectionError(APIError):\n    pass\n \n# 使用示例\napi_client = RESTAPIClient(&#039;api.example.com&#039;, auth_token=&#039;your-token&#039;)\n \ntry:\n    # 获取用户列表\n    users = api_client.get(&#039;/users&#039;, params={&#039;page&#039;: 1, &#039;limit&#039;: 10})\n    \n    # 创建新用户\n    new_user = api_client.post(&#039;/users&#039;, data={&#039;name&#039;: &#039;张三&#039;, &#039;email&#039;: &#039;zhangsan@example.com&#039;})\n    \n    # 更新用户\n    updated_user = api_client.put(f&#039;/users/{new_user[&quot;id&quot;]}&#039;, data={&#039;name&#039;: &#039;李四&#039;})\n    \n    # 删除用户\n    success = api_client.delete(f&#039;/users/{new_user[&quot;id&quot;]}&#039;)\n    \nexcept APIError as e:\n    print(f&quot;API 调用失败: {e}&quot;)\n2. 文件批量处理\n处理文件上传、下载和批量操作：\nimport os\nfrom pathlib import Path\nimport mimetypes\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n \nclass FileManager:\n    &quot;&quot;&quot;文件操作管理器&quot;&quot;&quot;\n    \n    def __init__(self, base_url: str, auth_token: str):\n        self.base_url = base_url\n        self.session = requests.Session()\n        self.session.headers[&#039;Authorization&#039;] = f&#039;Bearer {auth_token}&#039;\n    \n    def upload_file(self, file_path: Path, endpoint: str = &#039;/files/upload&#039;) -&gt; Dict:\n        &quot;&quot;&quot;上传单个文件&quot;&quot;&quot;\n        if not file_path.exists():\n            raise FileNotFoundError(f&quot;文件不存在: {file_path}&quot;)\n        \n        # 自动检测文件类型\n        mime_type, _ = mimetypes.guess_type(str(file_path))\n        \n        with open(file_path, &#039;rb&#039;) as file:\n            files = {\n                &#039;file&#039;: (file_path.name, file, mime_type or &#039;application/octet-stream&#039;)\n            }\n            data = {\n                &#039;filename&#039;: file_path.name,\n                &#039;size&#039;: file_path.stat().st_size\n            }\n            \n            response = self.session.post(\n                f&quot;{self.base_url}{endpoint}&quot;,\n                files=files,\n                data=data,\n                timeout=300  # 5 分钟超时，适合大文件\n            )\n            response.raise_for_status()\n            return response.json()\n    \n    def download_file(self, file_id: str, save_path: Path) -&gt; bool:\n        &quot;&quot;&quot;下载文件&quot;&quot;&quot;\n        url = f&quot;{self.base_url}/files/{file_id}/download&quot;\n        \n        with self.session.get(url, stream=True) as response:\n            response.raise_for_status()\n            \n            # 确保目录存在\n            save_path.parent.mkdir(parents=True, exist_ok=True)\n            \n            with open(save_path, &#039;wb&#039;) as file:\n                for chunk in response.iter_content(chunk_size=8192):\n                    if chunk:\n                        file.write(chunk)\n        \n        return True\n    \n    def batch_upload(self, file_paths: list, max_workers: int = 3) -&gt; Dict:\n        &quot;&quot;&quot;批量上传文件&quot;&quot;&quot;\n        results = {&#039;success&#039;: [], &#039;failed&#039;: []}\n        \n        def upload_single(file_path):\n            try:\n                result = self.upload_file(Path(file_path))\n                return (&#039;success&#039;, file_path, result)\n            except Exception as e:\n                return (&#039;failed&#039;, file_path, str(e))\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # 提交所有上传任务\n            future_to_path = {\n                executor.submit(upload_single, path): path \n                for path in file_paths\n            }\n            \n            # 收集结果\n            for future in as_completed(future_to_path):\n                status, path, result = future.result()\n                results[status].append({&#039;path&#039;: path, &#039;result&#039;: result})\n        \n        return results\n    \n    def get_upload_progress(self, file_path: Path, endpoint: str = &#039;/files/upload&#039;) -&gt; None:\n        &quot;&quot;&quot;带进度显示的文件上传&quot;&quot;&quot;\n        file_size = file_path.stat().st_size\n        \n        class ProgressFile:\n            def __init__(self, file_obj, callback):\n                self.file_obj = file_obj\n                self.callback = callback\n                self.bytes_read = 0\n            \n            def read(self, size=-1):\n                chunk = self.file_obj.read(size)\n                if chunk:\n                    self.bytes_read += len(chunk)\n                    self.callback(self.bytes_read)\n                return chunk\n            \n            def __getattr__(self, name):\n                return getattr(self.file_obj, name)\n        \n        def progress_callback(bytes_read):\n            percent = (bytes_read / file_size) * 100\n            print(f&quot;\\r上传进度: {percent:.1f}% ({bytes_read}/{file_size} 字节)&quot;, \n                  end=&#039;&#039;, flush=True)\n        \n        with open(file_path, &#039;rb&#039;) as file:\n            progress_file = ProgressFile(file, progress_callback)\n            files = {&#039;file&#039;: (file_path.name, progress_file)}\n            \n            response = self.session.post(\n                f&quot;{self.base_url}{endpoint}&quot;,\n                files=files,\n                timeout=300\n            )\n            print()  # 换行\n            response.raise_for_status()\n \n# 使用示例\nfile_manager = FileManager(&#039;api.example.com&#039;, &#039;your-token&#039;)\n \n# 上传单个文件\nresult = file_manager.upload_file(Path(&#039;document.pdf&#039;))\nprint(f&quot;文件上传成功: {result}&quot;)\n \n# 批量上传\nfile_list = [&#039;file1.txt&#039;, &#039;file2.jpg&#039;, &#039;file3.pdf&#039;]\nbatch_results = file_manager.batch_upload(file_list)\nprint(f&quot;成功上传: {len(batch_results[&#039;success&#039;])} 个文件&quot;)\nprint(f&quot;上传失败: {len(batch_results[&#039;failed&#039;])} 个文件&quot;)\n3. 实时数据处理与 WebHook\n处理实时数据和 WebHook 回调：\nimport hashlib\nimport hmac\nfrom typing import Callable\nimport threading\nimport queue\nimport time\n \nclass WebHookProcessor:\n    &quot;&quot;&quot;WebHook 处理器&quot;&quot;&quot;\n    \n    def __init__(self, secret_key: str):\n        self.secret_key = secret_key\n        self.session = requests.Session()\n        self.message_queue = queue.Queue()\n        self.processing_thread = None\n        self.running = False\n    \n    def verify_signature(self, payload: bytes, signature: str) -&gt; bool:\n        &quot;&quot;&quot;验证 WebHook 签名&quot;&quot;&quot;\n        expected_signature = hmac.new(\n            self.secret_key.encode(),\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n        \n        return hmac.compare_digest(f&quot;sha256={expected_signature}&quot;, signature)\n    \n    def process_webhook(self, payload: Dict, signature: str) -&gt; bool:\n        &quot;&quot;&quot;处理 WebHook 请求&quot;&quot;&quot;\n        payload_bytes = json.dumps(payload, sort_keys=True).encode()\n        \n        if not self.verify_signature(payload_bytes, signature):\n            raise ValueError(&quot;WebHook 签名验证失败&quot;)\n        \n        # 将消息加入处理队列\n        self.message_queue.put(payload)\n        return True\n    \n    def start_processing(self, handler: Callable):\n        &quot;&quot;&quot;启动后台处理线程&quot;&quot;&quot;\n        self.running = True\n        self.processing_thread = threading.Thread(\n            target=self._process_messages,\n            args=(handler,)\n        )\n        self.processing_thread.start()\n    \n    def stop_processing(self):\n        &quot;&quot;&quot;停止后台处理&quot;&quot;&quot;\n        self.running = False\n        if self.processing_thread:\n            self.processing_thread.join()\n    \n    def _process_messages(self, handler: Callable):\n        &quot;&quot;&quot;后台消息处理循环&quot;&quot;&quot;\n        while self.running:\n            try:\n                # 从队列获取消息，超时 1 秒\n                message = self.message_queue.get(timeout=1)\n                handler(message)\n                self.message_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f&quot;处理消息时发生错误: {e}&quot;)\n \nclass RealTimeDataCollector:\n    &quot;&quot;&quot;实时数据收集器&quot;&quot;&quot;\n    \n    def __init__(self, api_base_url: str, auth_token: str):\n        self.api_base_url = api_base_url\n        self.session = requests.Session()\n        self.session.headers[&#039;Authorization&#039;] = f&#039;Bearer {auth_token}&#039;\n        self.data_buffer = []\n        self.buffer_size = 100\n        self.last_flush = time.time()\n        self.flush_interval = 60  # 60 秒强制刷新一次\n    \n    def collect_data_point(self, data: Dict):\n        &quot;&quot;&quot;收集单个数据点&quot;&quot;&quot;\n        data[&#039;timestamp&#039;] = datetime.now().isoformat()\n        self.data_buffer.append(data)\n        \n        # 检查是否需要刷新缓冲区\n        if (len(self.data_buffer) &gt;= self.buffer_size or \n            time.time() - self.last_flush &gt;= self.flush_interval):\n            self.flush_buffer()\n    \n    def flush_buffer(self):\n        &quot;&quot;&quot;刷新数据缓冲区到服务器&quot;&quot;&quot;\n        if not self.data_buffer:\n            return\n        \n        try:\n            response = self.session.post(\n                f&quot;{self.api_base_url}/data/batch&quot;,\n                json={&#039;data_points&#039;: self.data_buffer},\n                timeout=30\n            )\n            response.raise_for_status()\n            \n            print(f&quot;成功上传 {len(self.data_buffer)} 个数据点&quot;)\n            self.data_buffer.clear()\n            self.last_flush = time.time()\n            \n        except requests.exceptions.RequestException as e:\n            print(f&quot;数据上传失败: {e}&quot;)\n            # 可以选择重试或者将数据写入本地文件\n    \n    def stream_data(self, data_source_url: str, handler: Callable):\n        &quot;&quot;&quot;流式处理数据&quot;&quot;&quot;\n        try:\n            with self.session.get(data_source_url, stream=True) as response:\n                response.raise_for_status()\n                \n                for line in response.iter_lines():\n                    if line:\n                        try:\n                            data = json.loads(line.decode(&#039;utf-8&#039;))\n                            handler(data)\n                        except json.JSONDecodeError:\n                            print(f&quot;无法解析的数据行: {line}&quot;)\n                        \n        except requests.exceptions.RequestException as e:\n            print(f&quot;流式数据处理失败: {e}&quot;)\n \n# 使用示例\ndef handle_webhook_data(payload):\n    &quot;&quot;&quot;WebHook 数据处理函数&quot;&quot;&quot;\n    event_type = payload.get(&#039;event_type&#039;)\n    print(f&quot;收到 WebHook 事件: {event_type}&quot;)\n    \n    # 根据事件类型进行处理\n    if event_type == &#039;user_signup&#039;:\n        # 处理用户注册事件\n        user_data = payload.get(&#039;data&#039;, {})\n        print(f&quot;新用户注册: {user_data.get(&#039;email&#039;)}&quot;)\n    \n    elif event_type == &#039;payment_completed&#039;:\n        # 处理支付完成事件\n        payment_data = payload.get(&#039;data&#039;, {})\n        print(f&quot;支付完成: {payment_data.get(&#039;amount&#039;)} 元&quot;)\n \n# 设置 WebHook 处理器\nwebhook_processor = WebHookProcessor(&#039;your-webhook-secret&#039;)\nwebhook_processor.start_processing(handle_webhook_data)\n \n# 设置实时数据收集器\ndata_collector = RealTimeDataCollector(&#039;api.example.com&#039;, &#039;your-token&#039;)\n \n# 收集数据点\ndata_collector.collect_data_point({\n    &#039;sensor_id&#039;: &#039;temp_001&#039;,\n    &#039;value&#039;: 23.5,\n    &#039;unit&#039;: &#039;celsius&#039;\n})\n\n十、故障排查与调试技巧\n1. 启用详细日志\n调试网络问题时，详细的日志信息至关重要：\nimport logging\nimport http.client as http_client\n \n# 启用 HTTP 请求日志\nhttp_client.HTTPConnection.debuglevel = 1\n \n# 配置 logging\nlogging.basicConfig()\nlogging.getLogger().setLevel(logging.DEBUG)\nrequests_log = logging.getLogger(&quot;requests.packages.urllib3&quot;)\nrequests_log.setLevel(logging.DEBUG)\nrequests_log.propagate = True\n \n# 现在所有请求都会显示详细日志\nresponse = requests.get(&#039;httpbin.org/get&#039;)\n2. 请求和响应检查工具\n创建调试友好的请求函数：\ndef debug_request(method, url, **kwargs):\n    &quot;&quot;&quot;带调试信息的请求函数&quot;&quot;&quot;\n    print(f&quot;\\n{&#039;=&#039;*50}&quot;)\n    print(f&quot;请求方法: {method.upper()}&quot;)\n    print(f&quot;请求 URL: {url}&quot;)\n    \n    # 显示请求头\n    headers = kwargs.get(&#039;headers&#039;, {})\n    if headers:\n        print(&quot;请求头:&quot;)\n        for key, value in headers.items():\n            print(f&quot;  {key}: {value}&quot;)\n    \n    # 显示请求参数\n    params = kwargs.get(&#039;params&#039;)\n    if params:\n        print(f&quot;URL 参数: {params}&quot;)\n    \n    # 显示请求体\n    data = kwargs.get(&#039;data&#039;)\n    json_data = kwargs.get(&#039;json&#039;)\n    if data:\n        print(f&quot;表单数据: {data}&quot;)\n    if json_data:\n        print(f&quot;JSON 数据: {json.dumps(json_data, indent=2, ensure_ascii=False)}&quot;)\n    \n    # 发送请求\n    start_time = time.time()\n    try:\n        response = requests.request(method, url, **kwargs)\n        elapsed_time = time.time() - start_time\n        \n        print(f&quot;\\n响应信息:&quot;)\n        print(f&quot;状态码: {response.status_code} ({response.reason})&quot;)\n        print(f&quot;响应时间: {elapsed_time:.3f} 秒&quot;)\n        print(f&quot;响应大小: {len(response.content)} 字节&quot;)\n        \n        # 显示响应头\n        print(&quot;响应头:&quot;)\n        for key, value in response.headers.items():\n            print(f&quot;  {key}: {value}&quot;)\n        \n        # 显示响应内容（截断长内容）\n        content_preview = response.text[:500]\n        if len(response.text) &gt; 500:\n            content_preview += &quot;...&quot;\n        print(f&quot;\\n响应内容预览:\\n{content_preview}&quot;)\n        \n        return response\n        \n    except requests.exceptions.RequestException as e:\n        elapsed_time = time.time() - start_time\n        print(f&quot;\\n请求失败:&quot;)\n        print(f&quot;错误类型: {type(e).__name__}&quot;)\n        print(f&quot;错误信息: {e}&quot;)\n        print(f&quot;失败时间: {elapsed_time:.3f} 秒&quot;)\n        raise\n    finally:\n        print(f&quot;{&#039;=&#039;*50}\\n&quot;)\n \n# 使用示例\ndebug_request(&#039;GET&#039;, &#039;httpbin.org/headers&#039;, \n              headers={&#039;User-Agent&#039;: &#039;Debug/1.0&#039;})\n3. 网络连接诊断\n诊断网络连接问题的工具函数：\nimport socket\nfrom urllib.parse import urlparse\n \ndef diagnose_connection(url):\n    &quot;&quot;&quot;诊断到目标 URL 的连接状态&quot;&quot;&quot;\n    parsed = urlparse(url)\n    host = parsed.hostname\n    port = parsed.port or (443 if parsed.scheme == &#039;https&#039; else 80)\n    \n    print(f&quot;诊断连接到 {host}:{port}&quot;)\n    \n    # DNS 解析测试\n    try:\n        ip_address = socket.gethostbyname(host)\n        print(f&quot;✓ DNS 解析成功: {host} -&gt; {ip_address}&quot;)\n    except socket.gaierror as e:\n        print(f&quot;✗ DNS 解析失败: {e}&quot;)\n        return False\n    \n    # TCP 连接测试\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(10)\n        result = sock.connect_ex((host, port))\n        sock.close()\n        \n        if result == 0:\n            print(f&quot;✓ TCP 连接成功&quot;)\n        else:\n            print(f&quot;✗ TCP 连接失败，错误代码: {result}&quot;)\n            return False\n    except Exception as e:\n        print(f&quot;✗ TCP 连接异常: {e}&quot;)\n        return False\n    \n    # HTTP 请求测试\n    try:\n        response = requests.get(url, timeout=10)\n        print(f&quot;✓ HTTP 请求成功，状态码: {response.status_code}&quot;)\n        return True\n    except requests.exceptions.RequestException as e:\n        print(f&quot;✗ HTTP 请求失败: {e}&quot;)\n        return False\n \n# 使用示例\ndiagnose_connection(&#039;www.google.com&#039;)\n\n十一、与其他库的集成\n1. 与数据处理库集成\n结合 pandas 进行数据分析：\nimport pandas as pd\nimport io\n \ndef fetch_csv_data(url, **kwargs):\n    &quot;&quot;&quot;从 URL 获取 CSV 数据并转换为 DataFrame&quot;&quot;&quot;\n    response = requests.get(url, **kwargs)\n    response.raise_for_status()\n    \n    # 使用 StringIO 将响应文本转换为文件对象\n    csv_data = io.StringIO(response.text)\n    df = pd.read_csv(csv_data)\n    \n    return df\n \ndef post_dataframe(url, df, format=&#039;json&#039;, **kwargs):\n    &quot;&quot;&quot;将 DataFrame 发送到服务器&quot;&quot;&quot;\n    if format == &#039;json&#039;:\n        data = df.to_json(orient=&#039;records&#039;)\n        headers = {&#039;Content-Type&#039;: &#039;application/json&#039;}\n    elif format == &#039;csv&#039;:\n        data = df.to_csv(index=False)\n        headers = {&#039;Content-Type&#039;: &#039;text/csv&#039;}\n    else:\n        raise ValueError(&quot;不支持的格式&quot;)\n    \n    kwargs.setdefault(&#039;headers&#039;, {}).update(headers)\n    return requests.post(url, data=data, **kwargs)\n \n# 使用示例\n# df = fetch_csv_data(&#039;example.com/data.csv&#039;)\n# result = post_dataframe(&#039;api.example.com/upload&#039;, df)\n2. 与异步框架集成\n使用 asyncio 和 aiohttp 进行高性能异步请求：\nimport asyncio\nimport aiohttp\nfrom concurrent.futures import ThreadPoolExecutor\n \nclass AsyncRequestsMixin:\n    &quot;&quot;&quot;为 requests 添加异步支持的混入类&quot;&quot;&quot;\n    \n    def __init__(self):\n        self.executor = ThreadPoolExecutor(max_workers=10)\n    \n    async def async_get(self, url, **kwargs):\n        &quot;&quot;&quot;异步 GET 请求&quot;&quot;&quot;\n        loop = asyncio.get_event_loop()\n        return await loop.run_in_executor(\n            self.executor, \n            lambda: requests.get(url, **kwargs)\n        )\n    \n    async def async_post(self, url, **kwargs):\n        &quot;&quot;&quot;异步 POST 请求&quot;&quot;&quot;\n        loop = asyncio.get_event_loop()\n        return await loop.run_in_executor(\n            self.executor,\n            lambda: requests.post(url, **kwargs)\n        )\n    \n    async def batch_requests(self, urls, method=&#039;GET&#039;):\n        &quot;&quot;&quot;批量异步请求&quot;&quot;&quot;\n        tasks = []\n        \n        for url in urls:\n            if method.upper() == &#039;GET&#039;:\n                task = self.async_get(url)\n            elif method.upper() == &#039;POST&#039;:\n                task = self.async_post(url)\n            else:\n                raise ValueError(f&quot;不支持的方法: {method}&quot;)\n            \n            tasks.append(task)\n        \n        responses = await asyncio.gather(*tasks, return_exceptions=True)\n        return responses\n \n# 使用示例\nasync def main():\n    client = AsyncRequestsMixin()\n    \n    urls = [\n        &#039;httpbin.org/delay/1&#039;,\n        &#039;httpbin.org/delay/2&#039;,\n        &#039;httpbin.org/delay/3&#039;\n    ]\n    \n    start_time = time.time()\n    responses = await client.batch_requests(urls)\n    elapsed_time = time.time() - start_time\n    \n    print(f&quot;异步请求完成，耗时: {elapsed_time:.2f} 秒&quot;)\n    for i, response in enumerate(responses):\n        if isinstance(response, Exception):\n            print(f&quot;请求 {i} 失败: {response}&quot;)\n        else:\n            print(f&quot;请求 {i} 成功: {response.status_code}&quot;)\n \n# 运行异步代码\n# asyncio.run(main())\n"},"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/ALTER":{"slug":"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/ALTER","filePath":"数据库/MySQL/SQL 基础语法/DDL（数据定义语言）/ALTER.md","title":"ALTER","links":[],"tags":[],"content":"一、ALTER DATABASE\n用于修改已有数据库的默认字符集与校对规则，也可修改数据库的加密、归档等其它元数据（MySQL 8.0+）。\nALTER DATABASE db_name\n    [CHARACTER SET [=] charset_name]\n    [COLLATE [=] collation_name]\n    [ENCRYPTION = {&#039;Y&#039;|&#039;N&#039;}]\n    [COMMENT = &#039;text&#039;];\n\nCHARACTER SET / COLLATE：更新数据库级别默认，影响后续新建的表和列。\nENCRYPTION：开启或关闭数据文件加密（需要 InnoDB + 支持的密钥管理）。\nCOMMENT：给数据库添加注释。\n\n示例：\n\n将 shop 改为 utf8mb4/utf8mb4_general_ci\n\nALTER DATABASE shop\n  CHARACTER SET = utf8mb4\n  COLLATE    = utf8mb4_general_ci;\n\n为数据库开启加密、添加注释\n\nALTER DATABASE shop\n  ENCRYPTION = &#039;Y&#039;\n  COMMENT    = &#039;线上电商数据库（加密存储）&#039;;\n\n二、ALTER TABLE\nALTER TABLE 是最常用的 DDL 之一，支持列、索引、分区、表选项等各种调整。MySQL 8.0 在 InnoDB 上提供了部分 Online DDL 能力。\nALTER [ONLINE | OFFLINE]\n      TABLE tbl_name\n    action [, action] ...;\n\n\nONLINE/OFFLINE：显式指定在线或离线（MySQL 会根据操作选择最优策略）。\n\n\nALGORITHM:\n\n\nINPLACE：尽量原地修改，不复制表。\n\n\nCOPY：全表复制重建（默认）。\n\n\nINSTANT：仅修改元数据即可生效（仅限部分 ADD COLUMN 操作）。\n\n\nLOCK：\n\n\nNONE：允许读写。\n\n\nSHARED：阻塞写。\n\n\nEXCLUSIVE：阻塞读写。\n\n\n全表锁策略示例\nALTER /*+ ALGORITHM=INPLACE, LOCK=NONE */ TABLE t\n  ADD COLUMN remark VARCHAR(255);\n2.1 常用操作一览\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作语法示例说明添加列`ADD [COLUMN] col_name 定义 [FIRSTAFTER colX]`删除列DROP [COLUMN] col_name重命名/修改列`CHANGE [COLUMN] old_name new_name 定义 [FIRSTAFTER colX] &lt;br&gt;MODIFY [COLUMN] col 定义`添加约束ADD [CONSTRAINT 名称] PRIMARY KEY(cols)  ADD CONSTRAINT 名称 FOREIGN KEY(cols) REFERENCES ref_table(cols) [ON DELETE ...]主键、外键等添加索引`ADD [INDEXKEY] 名称 (cols) &lt;br&gt;ADD UNIQUE [KEY] 名称 (cols)`删除索引DROP INDEX 索引名InnoDB 同 DROP KEY修改表选项ENGINE=InnoDB/ AUTO_INCREMENT=1000/ COMMENT=&#039;...&#039;/ ROW_FORMAT=Compact分区操作ADD PARTITION.../ DROP PARTITION.../ COALESCE PARTITION需根据分区类型谨慎操作\n2.2 支持 Online/Instant 的操作\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作类型MySQL 版本ALGORITHMLOCKADD COLUMN（无默认）8.0.12+INSTANTNONEDROP COLUMN8.0.16+INSTANTNONEADD INDEX5.6+ InnoDBINPLACENONEMODIFY COLUMN部分情况INPLACESHAREDCHANGE COLUMN部分情况COPYEXCLUSIVE更多细节：请参考官方文档 “Online DDL” 部分。\n2.3 典型示例\n\n新增可空列并置于首位\n\nALTER TABLE user\n  ADD COLUMN last_login DATETIME NULL FIRST;\n\n修改列类型并设默认值\n\nALTER TABLE orders\n  MODIFY COLUMN amount DECIMAL(12,2) NOT NULL DEFAULT 0;\n\n重命名列并保留定义\n\nALTER TABLE product\n  CHANGE COLUMN old_name new_name VARCHAR(100) NOT NULL COMMENT &#039;新列名示例&#039;;\n\n添加外键约束\n\nALTER TABLE order_item\n  ADD CONSTRAINT fk_order\n    FOREIGN KEY (order_id)\n    REFERENCES orders(id)\n    ON DELETE CASCADE\n    ON UPDATE RESTRICT;\n\n在线切换存储引擎（InnoDB）\n\nALTER /*+ ALGORITHM=INPLACE, LOCK=NONE */ TABLE my_table\n  ENGINE = InnoDB;\n\n三、ALTER VIEW\n用于重新定义视图的查询逻辑或元数据。\nALTER [ALGORITHM = {UNDEFINED|MERGE|TEMPTABLE}]\n      VIEW view_name [(col_list)]\n    AS select_statement\n    [WITH [CASCADED|LOCAL] CHECK OPTION];\n\n\nALGORITHM：\n\n\nMERGE / TEMPTABLE：同 CREATE VIEW。\n\n\nUNDEFINED：让服务器自动选择。\n\n\ncol_list：可在重定义时调整列名顺序或别名。\n\n\nCHECK OPTION：\n\n\nLOCAL：只检查该视图本身的 WHERE 条件。\n\n\nCASCADED：检查所有基础视图/表的条件。\n\n\n示例：更新视图以限制今年新用户\nALTER VIEW v_active_users\n  AS SELECT id, name, created_at\n  FROM user\n  WHERE created_at &gt;= &#039;2025-01-01&#039;\n  WITH CASCADED CHECK OPTION;\n\n四、其他 ALTER 语句概览\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n语句用途ALTER USER修改用户认证插件、密码、锁定状态、密码过期策略等ALTER ROLEMySQL 8.0+，管理角色成员、权限ALTER PROCEDURE/FUNCTION仅能修改 COMMENT、DETERMINISTIC、SQL SECURITY、LANGUAGE 等元数据ALTER EVENT修改 Event 调度器的执行时间、状态（ENABLE/DISABLE）、定义等ALTER SERVER在 Federated 或 Proxy 环境中调整远程服务器连接参数ALTER LOGFILE GROUP / TABLESPACE针对 InnoDB 引擎高级存储配置\n示例：\n\n修改用户密码并要求下次登录重置\n\nALTER USER &#039;alice&#039;@&#039;%&#039; \n  IDENTIFIED BY &#039;s3cr3t&#039; \n  PASSWORD EXPIRE;\n\n禁用一个定时任务\n\nALTER EVENT cleanup_old_logs\n  DISABLE;\n\n五、实战建议与注意事项\n\n全量备份：大表/生产库改结构前，务必做备份或在测试环境演练；可结合 pt-online-schema-change 实现零宕机改表。\n事务支持：MySQL DDL 大多会提交当前事务，且不可回滚，执行前请谨慎。\n监控锁：改表时关注 INFORMATION_SCHEMA.INNODB_TRX、SHOW PROCESSLIST，避免长时间锁表影响业务。\n版本兼容：Online DDL 能力随版本增强，不同操作在不同版本可能行为截然不同，升级与设计前请查阅对应手册。\n规范命名：索引、外键等显式命名，便于后续维护与定位问题。\n分区表改动：分区表的 ALTER TABLE 语法与普通表类似，但有额外限制，特别是 DROP/REORGANIZE 分区时务必在线上验证。\n"},"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/CREATE":{"slug":"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/CREATE","filePath":"数据库/MySQL/SQL 基础语法/DDL（数据定义语言）/CREATE.md","title":"CREATE","links":[],"tags":[],"content":"下面对常用的 MySQL CREATE 系列语句进行补充和完善，涵盖语法细节、使用场景、权限要求及最佳实践。\n\n1. CREATE DATABASE\n语法\nCREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name\n    [DEFAULT] CHARACTER SET [=] charset_name\n    [DEFAULT] COLLATE [=] collation_name;\n\n\nIF NOT EXISTS：若数据库已存在则不报错。\n\n\nDEFAULT CHARACTER SET / COLLATE：指定默认字符集和校对规则，之后在表或列级别可自行覆盖。\n\n\n权限要求：CREATE 权限可创建；DROP 权限可删除已存在的数据库。\n\n\n常用选项\n\n\nSHOW CREATE DATABASE db_name; 查看当前数据库配置。\n\n\n通过 ALTER DATABASE db_name CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 修改已有数据库默认字符集。\n\n\n示例\n-- 创建 mydb，默认字符集 utf8mb4，校对规则 utf8mb4_unicode_ci\nCREATE DATABASE IF NOT EXISTS mydb\n    DEFAULT CHARACTER SET = utf8mb4\n    DEFAULT COLLATE = utf8mb4_unicode_ci;\n \n-- 查看数据库信息\nSHOW CREATE DATABASE mydb;\n\n2. CREATE TABLE\n语法\nCREATE TABLE [IF NOT EXISTS] tbl_name (\n    column_name data_type [column_option ...],\n    [table_constraint ...]\n)\n[ENGINE = engine_name]\n[DEFAULT CHARSET = charset_name]\n[COLLATE = collation_name]\n[ROW_FORMAT = {DEFAULT | DYNAMIC | COMPRESSED}]\n[AUTO_INCREMENT = N]\n[COMMENT = &#039;table comment&#039;]\n[PARTITION BY ...];\n列定义 (column_option)\n\n\nNULL / NOT NULL\n\n\nDEFAULT &lt;expr&gt;：可使用常量、CURRENT_TIMESTAMP 等。\n\n\nAUTO_INCREMENT\n\n\nUNSIGNED / ZEROFILL\n\n\nCOMMENT &#039;说明&#039;\n\n\nCOLLATE collation_name\n\n\n表级约束 (table_constraint)\n\n\nPRIMARY KEY (col1, col2, ...)\n\n\nUNIQUE [KEY] (col_list)\n\n\nKEY [idx_name] (col_list)\n\n\nFULLTEXT KEY, SPATIAL KEY\n\n\nFOREIGN KEY (col) REFERENCES other_tbl(col) [ON DELETE ...] [ON UPDATE ...]\n\n\n分区策略 (PARTITION BY)\n\n\nRANGE(expr)\n\n\nLIST(expr)\n\n\nHASH(expr) / KEY(col_list)\n\n\n注意事项\n\n\nInnoDB 推荐用于事务与外键；MyISAM 支持全文与空间索引。\n\n\nAUTO_INCREMENT 列必须是索引的一部分。\n\n\n表选项（如 ENGINE / ROW_FORMAT）可影响性能与存储格式。\n\n\n示例\nCREATE TABLE IF NOT EXISTS users (\n    id          INT          UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#039;用户ID&#039;,\n    username    VARCHAR(50)  NOT NULL UNIQUE COMMENT &#039;用户名&#039;,\n    email       VARCHAR(100) NOT NULL COMMENT &#039;邮箱&#039;,\n    profile     JSON                      COMMENT &#039;用户资料(JSON)&#039;,\n    created_at  TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#039;创建时间&#039;,\n    PRIMARY KEY (id)\n)\nENGINE = InnoDB\nDEFAULT CHARSET = utf8mb4\nCOLLATE = utf8mb4_unicode_ci\nROW_FORMAT = DYNAMIC\nCOMMENT = &#039;用户表&#039;\nPARTITION BY HASH(id) PARTITIONS 4;\n\n3. CREATE INDEX\n语法\nCREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX idx_name\n    ON tbl_name (col_name [(length)] [ASC | DESC], ...)\n[USING {BTREE | HASH}];\n\n\nUNIQUE：保证索引列值唯一。\n\n\nFULLTEXT：适合自然语言全文检索（InnoDB/MyISAM）。\n\n\nSPATIAL：用于 GIS 数据（仅 MyISAM）。\n\n\nlength：对前缀索引（如 VARCHAR(100) 上的前 10 个字符）进行索引。\n\n\nUSING：指定索引类型，缺省为 BTREE。\n\n\n注意事项\n\n\n可以在 CREATE TABLE 里内联定义，也可用此命令分离创建。\n\n\n删除索引：DROP INDEX idx_name ON tbl_name;。\n\n\n示例\n-- 在 users.email 上创建唯一索引\nCREATE UNIQUE INDEX idx_users_email ON users (email);\n \n-- 在文章表 content 上创建全文索引\nCREATE FULLTEXT INDEX idx_posts_content ON posts(content);\n\n4. CREATE VIEW\n语法\nCREATE [OR REPLACE] VIEW view_name [(column_list)]\nAS select_statement\n[WITH [CASCADED | LOCAL] CHECK OPTION];\n\n\nOR REPLACE：若视图存在则覆盖。\n\n\nCHECK OPTION：保证通过视图插入/更新的行满足 SELECT 中的条件。\n\n\n不支持在视图中使用 ORDER BY（除非配合 LIMIT）。\n\n\n仅支持可更新视图（视图中不含聚合、DISTINCT、子查询等）。\n\n\n性能与安全\n\n\nMERGE 算法：视图查询展开到主表；\n\n\nTEMPTABLE 算法：先执行视图查询写入临时表再查询。\n\n\n由 DEFINER 决定视图执行时的权限。\n\n\n示例\nCREATE OR REPLACE VIEW active_users AS\nSELECT id, username, email\nFROM users\nWHERE status = &#039;active&#039;\nWITH LOCAL CHECK OPTION;\n\n5. CREATE USER\n语法\nCREATE USER [IF NOT EXISTS] &#039;user&#039;@&#039;host&#039;\n    IDENTIFIED WITH auth_plugin BY &#039;password&#039;\n    [REQUIRE tls_option [AND tls_option] ...]\n    [WITH resource_option ...]\n    [PASSWORD EXPIRE {DEFAULT | NEVER | INTERVAL N DAY}];\n\n\nauth_plugin：如 mysql_native_password、caching_sha2_password。\n\n\ntls_option：SSL, X509, CIPHER &#039;cipher_list&#039; 等。\n\n\nresource_option：MAX_QUERIES_PER_HOUR N, MAX_CONNECTIONS_PER_HOUR N 等。\n\n\n授权：创建后需用 GRANT 赋权。\n\n\n示例\nCREATE USER IF NOT EXISTS &#039;appuser&#039;@&#039;%&#039;\n    IDENTIFIED WITH caching_sha2_password BY &#039;S3cr3tPwd!&#039;\n    REQUIRE SSL\n    WITH MAX_QUERIES_PER_HOUR 1000;\n \n-- 授予权限\nGRANT SELECT, INSERT, UPDATE ON mydb.* TO &#039;appuser&#039;@&#039;%&#039;;\n\n6. CREATE PROCEDURE / FUNCTION\n语法\n-- 存储过程\nCREATE [DEFINER = user] PROCEDURE proc_name(\n    [IN|OUT|INOUT] param_name data_type, ...\n)\n[characteristic ...]\nBEGIN\n    statements;\nEND;\n \n-- 存储函数\nCREATE [DEFINER = user] FUNCTION func_name(\n    [IN] param_name data_type, ...\n)\nRETURNS data_type\n[characteristic ...]\nBEGIN\n    statements;\n    RETURN expr;\nEND;\n\n\ncharacteristic：LANGUAGE SQL, DETERMINISTIC/NOT DETERMINISTIC, CONTAINS SQL/NO SQL/READS SQL DATA/MODIFIES SQL DATA, SQL SECURITY DEFINER/INVOKER。\n\n\n分隔符：过程体内含 ; 时需用 DELIMITER 切换。\n\n\n错误处理：使用 DECLARE ... HANDLER 捕获异常。\n\n\n示例\nDELIMITER $$\nCREATE PROCEDURE add_user(\n    IN p_username VARCHAR(50),\n    IN p_email    VARCHAR(100)\n)\nDETERMINISTIC\nMODIFIES SQL DATA\nBEGIN\n    INSERT INTO users(username, email)\n    VALUES(p_username, p_email);\nEND$$\n \nCREATE FUNCTION get_user_count()\nRETURNS INT\nDETERMINISTIC\nREADS SQL DATA\nBEGIN\n    DECLARE cnt INT;\n    SELECT COUNT(*) INTO cnt FROM users;\n    RETURN cnt;\nEND$$\nDELIMITER ;\n\n7. CREATE TRIGGER\n语法\nCREATE TRIGGER trigger_name\n    {BEFORE | AFTER} {INSERT | UPDATE | DELETE}\n    ON tbl_name\n    FOR EACH ROW\n    [FOLLOWS | PRECEDES existing_trigger]\nBEGIN\n    statements;\nEND;\n\n\nBEFORE/AFTER：行操作前或后触发。\n\n\nNEW / OLD：访问新旧行数据。\n\n\n每个表每种事件可有多个触发器，触发器名唯一。\n\n\n示例\nDELIMITER $$\nCREATE TRIGGER trg_users_before_insert\nBEFORE INSERT ON users\nFOR EACH ROW\nBEGIN\n    SET NEW.username = LOWER(NEW.username);\nEND$$\n \nCREATE TRIGGER trg_update_timestamp\nAFTER UPDATE ON users\nFOR EACH ROW\nBEGIN\n    UPDATE users\n    SET updated_at = CURRENT_TIMESTAMP\n    WHERE id = NEW.id;\nEND$$\nDELIMITER ;\n\n权限一览\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对象所需权限DATABASECREATETABLECREATEINDEXCREATE, ALTERVIEWCREATE VIEWUSERCREATE USERPROCEDURE/FUNCTIONCREATE ROUTINETRIGGERTRIGGER\n\n小结\n\n\n使用 IF NOT EXISTS 或 OR REPLACE 提升 idempotence。\n\n\n结合表/列级别选项优化性能与兼容性。\n\n\n合理分配权限，保持最小授权原则。\n\n\n对存储过程、触发器等复杂对象，注意分隔符与错误处理。\n\n"},"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/DROP":{"slug":"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/DROP","filePath":"数据库/MySQL/SQL 基础语法/DDL（数据定义语言）/DROP.md","title":"DROP","links":[],"tags":[],"content":"一、DROP DATABASE / DROP SCHEMA\n1.1 语法\nDROP {DATABASE | SCHEMA} [IF EXISTS] db_name\n    [RESTRICT | CASCADE];\n\nIF EXISTS：在数据库不存在时不报错，仅产生警告。\nRESTRICT（默认）／CASCADE：目前 MySQL 不区分，始终等同于 RESTRICT，即如果数据库被使用则会拒绝删除。\n\n1.2 权限\n\n需要对目标数据库拥有 DROP 权限，或全局 CREATE 权限。\n\n1.3 注意事项\n\n不可恢复：删除数据库会移除所有表、视图、触发器、事件等元数据及数据文件，操作前请务必备份。\n如果有连接正在使用该数据库，删除会失败或影响连接。\n\n1.4 示例\n-- 安全删除：仅当 shop 库存在时才删除\nDROP DATABASE IF EXISTS shop;\n\n二、DROP TABLE\n2.1 语法\nDROP [TEMPORARY] TABLE [IF EXISTS]\n    tbl_name [, tbl_name] ... \n    [RESTRICT | CASCADE];\n\nTEMPORARY：仅删除当前会话中的临时表。\nIF EXISTS：表不存在时不报错，仅警告。\nRESTRICT/CASCADE：MySQL 不区分，均拒绝删除被外键依赖的表（InnoDB）。\n\n2.2 权限\n\n需要对表有 DROP 权限；若表是临时表，则仅需对临时表拥有权限。\n\n2.3 注意事项\n\n事务行为\n\n\nInnoDB 中 DROP TABLE 会隐含提交当前事务，不可回滚。\n\n\n外键约束\n\n\n若有其他表通过外键引用，删除会失败，需先 ALTER TABLE ... DROP FOREIGN KEY。\n\n\n表名大小写\n\n\n在不区分大小写的文件系统上，DROP TABLE a; DROP TABLE A; 可能会一次性删除同一个 .frm/.ibd 文件。\n\n2.4 示例\n-- 同时删除多个表\nDROP TABLE IF EXISTS t1, t2, t3;\n \n-- 删除会话级临时表\nDROP TEMPORARY TABLE IF EXISTS tmp_users;\n\n三、DROP VIEW\n3.1 语法\nDROP VIEW [IF EXISTS] view_name [, view_name] ... \n    [RESTRICT | CASCADE];\n\nIF EXISTS：视图不存在时只警告。\nRESTRICT/CASCADE：MySQL 同样不区分，拒绝删除被其他视图依赖的情况下。\n\n3.2 权限\n\n需要对视图有 DROP 权限，以及对底层表有 SELECT 权限。\n\n3.3 注意事项\n\n删除视图不会影响底层数据表。\n若存在 视图链（视图依赖视图），先删除上层再删除下层。\n\n3.4 示例\n-- 批量删除视图\nDROP VIEW IF EXISTS v_orders, v_customers;\n\n四、DROP INDEX\n4.1 语法（InnoDB）\nALTER TABLE tbl_name\n  DROP INDEX index_name;  -- 等同于 DROP KEY index_name\n或者对于 MyISAM：\nDROP INDEX index_name\n  ON tbl_name;\n4.2 权限\n\n修改表结构需 ALTER 权限；若是 DROP USER_DEFINED 索引，则需要 INDEX 权限。\n\n4.3 注意事项\n\n删除主键索引请使用 ALTER TABLE ... DROP PRIMARY KEY；\nInnoDB 中主键必须唯一且非空，删除后若无其他唯一索引，表将隐式创建聚簇主键。\n\n4.4 示例\n-- 删除普通索引\nALTER TABLE orders\n  DROP INDEX idx_order_date;\n \n-- 删除唯一索引\nALTER TABLE user\n  DROP INDEX ux_email;\n\n五、DROP TRIGGER\n5.1 语法\nDROP TRIGGER [IF EXISTS] [schema_name.]trigger_name;\n\nIF EXISTS：触发器不存在时不报错。\n\n5.2 权限\n\n需要对触发器所属表具有 ALTER 和 TRIGGER 权限。\n\n5.3 注意事项\n\n删除触发器后，所有与该触发器关联的业务逻辑（如日志记录、级联操作）将不再执行，需谨慎。\n\n5.4 示例\n-- 删除触发表\nDROP TRIGGER IF EXISTS audit_before_insert;\n\n六、DROP PROCEDURE / DROP FUNCTION\n6.1 语法\nDROP {PROCEDURE | FUNCTION} [IF EXISTS]\n     sp_name[, sp_name ...];\n6.2 权限\n\nDROP ROUTINE 或者对该存储例程有 ALTER ROUTINE 权限。\n\n6.3 注意事项\n\n删除前可先 SHOW CREATE PROCEDURE/FUNCTION 备份定义脚本；\n若有其他对象依赖此例程（如事件、触发器），执行前先清理依赖。\n\n6.4 示例\nDROP PROCEDURE IF EXISTS proc_update_stats;\nDROP FUNCTION IF EXISTS fn_calc_tax;\n\n七、DROP EVENT\n7.1 语法\nDROP EVENT [IF EXISTS] event_name;\n7.2 权限\n\n需要对事件有 ALTER ROUTINE 或全局 EVENT 权限。\n\n7.3 注意事项\n\n删除后，调度器不再执行该任务；\n可通过 SHOW EVENTS 查看剩余事件。\n\n7.4 示例\nDROP EVENT IF EXISTS cleanup_daily;\n\n八、DROP USER / DROP ROLE\n8.1 DROP USER\nDROP USER [IF EXISTS] user_spec [, user_spec ...];\n\nuser_spec：&#039;user&#039;@&#039;host&#039;。\n删除用户会同时删除其在 grant tables 中的所有权限。\n\n权限\n\n需要全局 CREATE USER 或 INSERT、DELETE、UPDATE 权限。\n\n示例\nDROP USER IF EXISTS &#039;bob&#039;@&#039;%&#039;;\n8.2 DROP ROLE （MySQL 8.0+）\nDROP ROLE [IF EXISTS] role_name [, role_name ...];\n\n删除角色前，确保已从所有用户和角色中 REVOKE。\n\n权限\n\n需要全局 DROP ROLE 或 SET ROLE 权限。\n\n示例\nDROP ROLE IF EXISTS reporting_analyst;\n\n九、DROP PARTITION\n9.1 语法\nALTER TABLE tbl_name\n  DROP PARTITION p0 [, p1, ...]\n  [UPDATE GLOBAL INDEXES];\n\n只能在分区表上使用，不是独立的 DROP 语句。\n\n9.2 注意事项\n\n数据会被删除且无法恢复；\n若有全局二级索引，需加 UPDATE GLOBAL INDEXES 同步重建。\n\n9.3 示例\nALTER TABLE metrics\n  DROP PARTITION p2025_01, p2025_02\n  UPDATE GLOBAL INDEXES;\n\n十、其他 DROP 语句\n\nDROP SERVER：移除 Federated/MySQL Proxy 远程服务器\nDROP LOGFILE GROUP：删除 InnoDB 日志文件组\nDROP TABLESPACE：删除 InnoDB 表空间\nDROP RESOURCE（8.0.16+）：删除 Resource group\nDROP SPATIAL REFERENCE SYSTEM：移除空间参照系统\n\n-- 删除 Federated 服务器\nDROP SERVER IF EXISTS fed_server;\n \n-- 删除自定义表空间\nDROP TABLESPACE ts1 ENGINE = InnoDB;\n\n十一、实战建议与注意事项\n\n备份优先：任何 DROP 操作执行前，请先备份（mysqldump、文件拷贝或快照）。\n权限审计：合理分离权限，避免误删。生产环境建议启用多级审批流程。\nIF EXISTS：在自动化脚本中加上 IF EXISTS，避免中断批量执行。\n依赖检查：大对象（表／视图／例程）相互依赖时，先用 INFORMATION_SCHEMA 或 SHOW 系列命令检查依赖链。\n清理残留：删除用户或角色后，可通过 SHOW GRANTS 和 mysql.user 表确认权限已清理。\n运维脚本：建议将所有 DROP 操作纳入版本控制，配合审计日志，保障可追溯。\n"},"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/TRUNCATE":{"slug":"数据库/MySQL/SQL-基础语法/DDL（数据定义语言）/TRUNCATE","filePath":"数据库/MySQL/SQL 基础语法/DDL（数据定义语言）/TRUNCATE.md","title":"TRUNCATE","links":[],"tags":[],"content":"一、概述\nTRUNCATE TABLE 用于 快速清空 整个表的所有行，但保留 表结构（包括列、索引、约束等）不变。\n\n本质上它属于 DDL 而非 DML；\n逻辑上等同于 DELETE FROM tbl_name（无 WHERE）或 DROP TABLE + CREATE TABLE 的组合。 dev.mysql.com\n\n\n二、语法与权限\nTRUNCATE [TABLE] tbl_name;\n\nIF EXISTS 不支持；\n多表清空 必须分别对各表执行。\n权限：需要对目标表拥有 DROP 权限。 dev.mysql.com\n\n\n三、关键特性与行为差异\n\nDDL 而非 DML\n\n\n虽然效果类似 DELETE，但分类为 数据定义语句；\n不触发 ON DELETE 触发器。 dev.mysql.com\n\n\n隐式提交\n\n\n执行前后都会自动提交当前事务，无法回滚。 dev.mysql.com\n\n\n性能优势\n\n\n通过 丢弃并重建 表或表空间来清空数据，避免逐行删除，速度极快；\n对大表特别有效。 dev.mysql.com\n\n\n**AUTO_INCREMENT** 重置\n\n\n将自增计数器重置为初始值；\n对 InnoDB、MyISAM 均生效。 dev.mysql.com\n\n\n外键约束限制\n\n\nInnoDB 或 NDB 表如有父—子表（外键）依赖时，无法执行 TRUNCATE；\n同表内自引用外键则允许。 dev.mysql.com\n\n\n表锁要求\n\n\n如会话已持有任何表锁，TRUNCATE 会失败。 dev.mysql.com\n\n\n关闭打开的 HANDLER\n\n\n会关闭所有通过 HANDLER OPEN 打开的句柄。 dev.mysql.com\n\n\n分区表\n\n\n保留分区定义，仅对各分区数据和索引文件执行丢弃重建；\n分区方案及元数据不变。 dev.mysql.com\n\n\n损坏表支持\n\n\n即使数据或索引文件损坏，只要表定义有效，亦能成功清空。 dev.mysql.com\n\n\nPerformance Schema 汇总表\n\n\n用于统计汇总的表被清空时，会将汇总列重置为 0 或 NULL，而不是删除行。 dev.mysql.com\n\n\n四、事务与原子性\n\n对于支持 原子 DDL 的存储引擎（如 InnoDB），TRUNCATE 本身具有原子性：若服务器崩溃，操作要么全量生效，要么全量回滚 dev.mysql.com；\n但在执行过程中仍会产生 隐式提交，不可与其它 DML 一并回滚。 dev.mysql.com\n\n\n五、二进制日志与复制\n\nTRUNCATE TABLE 始终以 DDL 语句 形式记录在 binlog 中，不受 binlog_format（ROW/STATEMENT/MIXED）影响；\n从库按语句方式执行，遵循主库 InnoDB 行为规则。 docs.oracle.com\n\n\n六、存储引擎差异\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n存储引擎行为InnoDB删除并重新创建表（或表空间），重置自增；不触发触发器；需 DROP 权限；外键依赖时失败；支持原子性。 dev.mysql.comMyISAM类似 InnoDB；重置自增；快速丢弃数据文件。 dev.mysql.comMEMORY释放全部内存；同样可使用 TRUNCATE清空表，内存引擎直接回收所有页。 dev.mysql.com\n\n七、典型示例\n-- 基本用法：清空 orders 表\nTRUNCATE TABLE orders;\n \n-- 当有分区时，仅重建数据文件，保留分区定义\nTRUNCATE TABLE user_logs;  \n \n-- 结合外键约束：需先禁用外键检查（不推荐，仅演示）\nSET FOREIGN_KEY_CHECKS = 0;\nTRUNCATE TABLE parent_table;\nSET FOREIGN_KEY_CHECKS = 1;\n\n八、注意事项与最佳实践\n\n务必备份：清空前请先全量备份（mysqldump、快照等），否则数据不可恢复。\n审慎对待外键：如表被其它表引用，应先处理约束再清空。\n避免在高峰期：虽为快速操作，但仍会隐式提交并重建表文件，可能短暂影响并发。\n脚本化谨慎：生产脚本中可加 IF EXISTS 检测（手动包装）或加流程审批。\n区别 DELETE：若需触发器、事务回滚或行级删除计数，应使用 DELETE。\n\n以上便是 MySQL 中 TRUNCATE TABLE 的全面详解，涵盖语法、权限、执行机制、存储引擎差异及实战建议。"},"数据库/MySQL/数据库与表的基本操作/数据库的创建、修改与删除":{"slug":"数据库/MySQL/数据库与表的基本操作/数据库的创建、修改与删除","filePath":"数据库/MySQL/数据库与表的基本操作/数据库的创建、修改与删除.md","title":"数据库的创建、修改与删除","links":[],"tags":[],"content":"MySQL 数据库的创建、修改与删除 (CREATE, ALTER, DROP)\n在 MySQL 中，数据库（Database）是用于存储和组织数据表（Tables）的容器。对数据库本身的管理是进行任何数据操作前所必须掌握的基础知识。本文将详细介绍如何使用 SQL 语句来创建、修改和删除数据库。\n1. 创建数据库 (CREATE DATABASE)\nCREATE DATABASE 语句用于创建一个新的数据库。\n语法\n基本的语法结构如下：\nCREATE DATABASE [IF NOT EXISTS] database_name\n    [CHARACTER SET charset_name]\n    [COLLATE collation_name];\n\ndatabase_name: 您要创建的数据库的名称。\nIF NOT EXISTS (可选): 这是一个非常有用的子句。如果数据库已经存在，使用该子句可以防止 MySQL 报错，它会直接跳过创建操作。强烈建议在脚本中使用此选项。\nCHARACTER SET (可选): 指定数据库的默认字符集。字符集决定了数据库可以存储哪些语言的字符。\nCOLLATE (可选): 指定数据库的默认排序规则。它定义了字符比较、排序的方式（例如，是否区分大小写）。\n\n示例\n示例 1: 创建一个简单的数据库\nCREATE DATABASE my_first_db;\n这条命令会创建一个名为 my_first_db 的数据库，并使用 MySQL 服务器的默认字符集和排序规则。\n示例 2: 创建一个安全的、支持中文和 Emoji 的数据库（推荐）\n为了更好地支持多种语言（尤其是中文）和 Emoji 表情符号，推荐使用 utf8mb4 字符集和 utf8mb4_unicode_ci 排序规则。\nCREATE DATABASE IF NOT EXISTS my_app_db\nCHARACTER SET utf8mb4\nCOLLATE utf8mb4_unicode_ci;\n\n**CHARACTER SET utf8mb4**: 这是 utf8 的超集，完全兼容 utf8，同时可以存储需要 4 个字节编码的字符，比如 Emoji 表情。这是现代应用的首选。\n**COLLATE utf8mb4_unicode_ci**: 这是 utf8mb4 字符集的一种通用排序规则，_ci 表示 “case-insensitive”，即在比较字符串时不区分大小写。\n\n2. 查看与选择数据库\n在修改或删除之前，您需要知道当前有哪些数据库，以及如何查看它们的详细信息。\n查看所有数据库\n使用 SHOW DATABASES 命令可以列出 MySQL 服务器上所有的数据库。\nSHOW DATABASES;\n查看数据库的创建信息\n如果您想查看某个数据库的创建语句（包括其字符集和排序规则），可以使用 SHOW CREATE DATABASE。\nSHOW CREATE DATABASE my_app_db;\n执行后，您会看到类似如下的输出，这对于检查数据库配置非常有用：\n+-----------+-----------------------------------------------------------------------------------------------------------------+\n| Database  | Create Database                                                                                                 |\n+-----------+-----------------------------------------------------------------------------------------------------------------+\n| my_app_db | CREATE DATABASE `my_app_db` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */ /*!80016 ... */ |\n+-----------+-----------------------------------------------------------------------------------------------------------------+\n选择要操作的数据库\n在对数据库中的表进行操作之前，您必须先用 USE 命令“进入”该数据库。\nUSE my_app_db;\n之后，您执行的所有关于表的操作（如 CREATE TABLE, SELECT 等）都将在 my_app_db 这个数据库中进行。\n3. 修改数据库 (ALTER DATABASE)\nALTER DATABASE 语句用于修改数据库的全局特性，最常见的用途是更改数据库的默认字符集和排序规则。\n注意：这个命令只影响未来在该数据库中创建的表的默认设置，它不会改变已经存在的表的字符集和排序规则。\n语法\nALTER DATABASE database_name\n    [CHARACTER SET charset_name]\n    [COLLATE collation_name];\n示例: 修改数据库的字符集和排序规则\n假设您之前创建的 my_first_db 使用了旧的字符集，现在想将其默认设置更新为 utf8mb4。\nALTER DATABASE my_first_db\nCHARACTER SET utf8mb4\nCOLLATE utf8mb4_unicode_ci;\n4. 删除数据库 (DROP DATABASE)\nDROP DATABASE 语句用于永久性地删除一个数据库，包括其中的所有表、视图和数据。\n严重警告：这是一个极其危险的操作！\n\n操作不可逆: 一旦执行，数据库及其中的所有数据都将永久丢失，无法恢复（除非您有备份）。\n请务必谨慎: 在生产环境中执行此命令前，请再三确认，并确保已经做好了万全的备份。\n\n语法\nDROP DATABASE [IF EXISTS] database_name;\n\nIF EXISTS (可选): 如果数据库不存在，使用此子句可以避免 MySQL 报错。同样强烈建议在脚本中使用。\n\n示例\n-- 删除一个名为 my_first_db 的数据库\nDROP DATABASE IF EXISTS my_first_db;"},"数据库/MySQL/数据库与表的基本操作/表属性：字符集、排序规则、行格式":{"slug":"数据库/MySQL/数据库与表的基本操作/表属性：字符集、排序规则、行格式","filePath":"数据库/MySQL/数据库与表的基本操作/表属性：字符集、排序规则、行格式.md","title":"表属性：字符集、排序规则、行格式","links":[],"tags":[],"content":"一、字符集（Character Set）\n1. 概念\n字符集定义了一套“字符 ↔ 二进制编码” 的映射规则。常见字符集包括：\n\nlatin1：单字节，最多支持 256 个字符，适合西欧语系\nutf8：变长，多达 3 字节，支持大部分常用字符，但不含部分罕见汉字、Emoji\nutf8mb4：变长，最多 4 字节，完全支持 Unicode（含 Emoji、扩展汉字）\n\n2. 为什么要选对字符集？\n\n存储空间：单字节 vs 多字节\n兼容性：客户端/服务器需统一，否则会出现“乱码”\n功能完整性：如 Emoji、古文字等必须用 utf8mb4\n\n3. 如何指定\n3.1 创建表时指定\nCREATE TABLE messages (\n  id    INT AUTO_INCREMENT PRIMARY KEY,\n  body  TEXT\n) ENGINE=InnoDB\n  DEFAULT CHARSET = utf8mb4\n  COLLATE = utf8mb4_unicode_ci;\n3.2 修改已有表\nALTER TABLE messages\n  CONVERT TO CHARACTER SET utf8mb4\n  COLLATE utf8mb4_unicode_ci;\n这条命令会：\n\n将表（以及所有 TEXT/CHAR/VARCHAR 列）的字符集转换为 utf8mb4\n转换排序规则为 utf8mb4_unicode_ci\n\n3.3 查看当前字符集\nSHOW CREATE TABLE messages\\G\n或查询 information_schema：\nSELECT TABLE_NAME, TABLE_COLLATION\nFROM information_schema.tables\nWHERE table_schema = &#039;your_db&#039;;\n\n二、排序规则（Collation）\n1. 概念\n排序规则定义了对同一字符集下的“比较与排序”规则，常见后缀：\n\n_ci：case-insensitive，不区分大小写\n_cs：case-sensitive，区分大小写\n_bin：binary，按二进制值比较\n\n2. 常见示例\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n字符集默认排序说明utf8mb4utf8mb4_general_ci一般通用，速度稍快utf8mb4utf8mb4_unicode_ci完整 Unicode 排序，准确性更高utf8mb4utf8mb4_bin严格二进制比较latin1latin1_swedish_ciMySQL 默认，瑞典式排序\n3. 选择建议\n\n常规场景：utf8mb4_unicode_ci\n追求极致性能：utf8mb4_general_ci\n对大小写敏感：utf8mb4_cs 或 utf8mb4_bin\n\n4. 列级覆盖\n可在列定义时单独指定不同排序：\nCREATE TABLE users (\n  name      VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,\n  nickname  VARCHAR(50)  CHARACTER SET utf8mb4 COLLATE utf8mb4_bin\n);\n\n三、行格式（Row Format）\n1. 概念\n行格式决定了 InnoDB 如何在磁盘和内存中存储表的数据行，以及大字段（BLOB/TEXT/JSON）是否“溢出页”存储。主要有：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n格式特点REDUNDANT最早的格式，兼容旧版本；每行存两份部分元数据，空间利用率最低COMPACT默认格式，存一份元数据；主键、定长部分在页内；可 off-page 存储溢出数据DYNAMIC索引列尽量保留在页内，溢出列存外部溢出页；对长字段表现更佳COMPRESSED在 DYNAMIC 基础上压缩数据页，节省磁盘/内存空间；需指定 KEY_BLOCK_SIZE\n2. 选择与使用\n2.1 如何指定\n\n创建表时：\n\nCREATE TABLE docs (\n  id    INT AUTO_INCREMENT PRIMARY KEY,\n  txt   TEXT\n) ENGINE=InnoDB\n  ROW_FORMAT = DYNAMIC;\n\n修改已存在表：\n\nALTER TABLE docs\n  ROW_FORMAT = COMPRESSED\n  KEY_BLOCK_SIZE = 8;  -- 压缩块大小: 1,2,4,8,16 KB\n2.2 查询当前行格式\nSELECT table_name, row_format, data_length, index_length\nFROM information_schema.tables\nWHERE table_schema = &#039;your_db&#039;\n  AND table_name = &#039;docs&#039;;\n2.3 各格式适用场景\n\nCOMPACT（默认）：一般 OLTP 场景，兼顾性能与存储\nDYNAMIC：含大量 BLOB/TEXT/JSON 字段，减少页内溢出\nCOMPRESSED：只读或读多写少、磁盘/内存紧张时，用于节省空间\n\n3. 注意事项\n\n压缩格式限制：COMPRESSED 需 InnoDB Barracuda 文件格式，并且 innodb_file_per_table=ON\n性能权衡：\n\n\nCOMPRESSED 会额外 CPU 开销\nDYNAMIC 和 COMPRESSED 都会增加页分裂风险\n\n\n迁移成本：ALTER TABLE ... ROW_FORMAT 会重建全表，视表大小耗时较长\n"},"数据库/MySQL/数据库与表的基本操作/表的增删改查":{"slug":"数据库/MySQL/数据库与表的基本操作/表的增删改查","filePath":"数据库/MySQL/数据库与表的基本操作/表的增删改查.md","title":"表的增删改查","links":[],"tags":[],"content":"一、创建表：CREATE TABLE\n1.1 语法概览\nCREATE TABLE [IF NOT EXISTS] `table_name` (\n  -- 列定义列表\n  column_name data_type [column_options] [column_constraints],\n  -- 表级约束\n  [CONSTRAINT constraint_name] table_constraint,\n  ...\n)\n[ENGINE = engine_name]\n[DEFAULT CHARSET = charset_name]\n[COLLATE = collation_name]\n[TABLE_COMMENT = &#039;comment&#039;]\n[PARTITION BY ...]\n[其他表选项...];\n\nIF NOT EXISTS：若表已存在则跳过，无错误\n列定义后可直接加索引/约束，也可在末尾集中定义\n\n1.2 常用数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型描述示例整数TINYINT、SMALLINT、MEDIUMINT、INT、BIGINTid INT, age TINYINT UNSIGNED浮点/定点FLOAT(p)、DOUBLE(p,s)、DECIMAL(p,s)price DECIMAL(10,2)字符串CHAR(n)、VARCHAR(n)、TEXT系列name VARCHAR(100), bio TEXT日期/时间DATE、TIME、DATETIME、TIMESTAMP、YEARcreated DATETIME, due DATE枚举/集合ENUM(&#039;a&#039;,&#039;b&#039;,...)、SET(&#039;x&#039;,&#039;y&#039;,...)status ENUM(&#039;on&#039;,&#039;off&#039;)JSON存储 JSON 格式，支持索引profile JSON二进制BINARY(n)、VARBINARY(n)、BLOB系列avatar BLOB\n1.3 列级属性与约束\n\n**NOT NULL** / **NULL**：是否允许空值\n**AUTO_INCREMENT**：配合整数类型，自动生成唯一递增值\n**DEFAULT &lt;value&gt;**：指定默认值，支持函数如 CURRENT_TIMESTAMP\n**ON UPDATE**：更新时间戳，如\n\nupdated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  ON UPDATE CURRENT_TIMESTAMP\n\n**COMMENT &#039;备注&#039;**：添加列注释，利于文档化\n**UNIQUE** / **PRIMARY KEY**：单列唯一约束或主键\n**VISIBLE** / **INVISIBLE**（MySQL 8.0+）：索引可见性控制\n\n1.4 表级约束\n\n主键（Primary Key）\n\nPRIMARY KEY (col1, col2)\n\n唯一键（Unique Key）\n\nUNIQUE KEY uk_name (col)\n\n普通索引（Index / Key）\n\nINDEX idx_email (email)\n\n全文索引（FULLTEXT） / 空间索引（SPATIAL）\n外键（Foreign Key）\n\nCONSTRAINT fk_user_role\n  FOREIGN KEY (role_id)\n  REFERENCES roles(id)\n  ON DELETE SET NULL\n  ON UPDATE CASCADE\n1.5 表级选项\n\n**ENGINE=InnoDB**：事务、外键、行锁\n**CHARSET=utf8mb4** / **COLLATE=utf8mb4_unicode_ci**：字符集与排序规则\n**ROW_FORMAT**：COMPACT / REDUNDANT / DYNAMIC / COMPRESSED\n**AUTO_INCREMENT = n**：指定下一次自增起始值\n**COMMENT=&#039;表备注&#039;**\n分区（Partitioning）\n\nPARTITION BY RANGE (year(created_at)) (\n  PARTITION p2019 VALUES LESS THAN (2020),\n  PARTITION p2020 VALUES LESS THAN (2021),\n  PARTITION pmax VALUES LESS THAN MAXVALUE\n)\n\n二、修改表：ALTER TABLE\n2.1 添加列\nALTER TABLE users\n  ADD COLUMN last_login DATETIME    -- 默认新增到末尾\n    AFTER email;                    -- 指定位置\nALTER TABLE users\n  ADD COLUMN is_active TINYINT(1)   -- 多列一次性添加\n    AFTER created_at,\n  ADD COLUMN bio TEXT AFTER username;\n2.2 修改列\n\n修改类型、长度或属性\n\nALTER TABLE users\n  MODIFY COLUMN username VARCHAR(100) NOT NULL;\n\n改名并修改属性\n\nALTER TABLE users\n  CHANGE COLUMN username user_name VARCHAR(80) NOT NULL COMMENT &#039;登录名&#039;;\n2.3 重命名表\nALTER TABLE users\n  RENAME TO app_users;\n2.4 删除列\nALTER TABLE users\n  DROP COLUMN last_login;\n2.5 添加 / 删除索引\nALTER TABLE users\n  ADD INDEX idx_email (email),\n  ADD UNIQUE KEY uk_username (username);\n \nALTER TABLE users\n  DROP INDEX idx_email,\n  DROP KEY uk_username;   -- UNIQUE 索引也用 DROP KEY\n2.6 添加 / 删除外键\nALTER TABLE orders\n  ADD CONSTRAINT fk_order_user\n    FOREIGN KEY (user_id) REFERENCES users(id)\n      ON DELETE CASCADE ON UPDATE CASCADE;\n \nALTER TABLE orders\n  DROP FOREIGN KEY fk_order_user;\n\n三、删除表：DROP TABLE\n3.1 语法\nDROP TABLE [IF EXISTS] table_name [, table_name2, ...];\n\n多表一次性删除，用逗号分隔\nIF EXISTS 可避免表不存在时报错\n\n3.2 注意事项\n\n彻底删除：连同表结构和所有数据一并清除\n权限要求：需要 DROP 权限\n恢复难度大：务必先备份或使用 SHOW CREATE TABLE + INSERT SELECT 方式保留结构和数据\n\n\n四、清空表：TRUNCATE TABLE\n4.1 语法\nTRUNCATE TABLE table_name;\n4.2 与 DELETE 的主要区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性DELETE FROM tableTRUNCATE TABLE删除方式逐行删除快速重建（高效）日志记录每行删除只记录元数据变更自增计数器重置不重置重置至初始值可回滚（InnoDB）可（事务内）不可（自动提交）触发器（Triggers）会触发 DELETE 触发器不会触发 DELETE 触发器\n4.3 使用建议\n\n清空整个表：推荐 TRUNCATE，更高效\n有事务回滚需求：使用 DELETE\n逻辑删除：若需保留历史，建议在表中加 status 字段而非清空\n"},"数据库/MySQL/数据类型详解/JSON类型":{"slug":"数据库/MySQL/数据类型详解/JSON类型","filePath":"数据库/MySQL/数据类型详解/JSON类型.md","title":"JSON类型","links":[],"tags":[],"content":"一、概念与存储\n\n\n本质：MySQL 的 JSON 并非简单的文本，而是存储为一种紧凑的二进制格式（“JSON binary”），可以快速解析与随机访问。\n\n\n版本支持：从 MySQL 5.7.8 引入，5.7 系列提供基础 CRUD 与函数；MySQL 8.0 大幅增强了 JSON 函数、索引与查询能力。\n\n\n优点：\n\n\n自动验证合法性，插入非法 JSON 会报错（严格模式下）。\n\n\n存储紧凑，节省空间；随机访问子元素无需全行扫描。\n\n\n缺点：\n\n\n不及关系型字段在 JOIN/聚合等场景下灵活，复杂查询需用专门 JSON 函数或 JSON_TABLE()。\n\n\n大量深嵌套 JSON 会导致解析开销、可维护性下降。\n\n\n\n二、定义与基本操作\n2.1 建表时定义 JSON 列\nCREATE TABLE configs (\n  id      INT AUTO_INCREMENT PRIMARY KEY,\n  data    JSON                     NOT NULL,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n) ENGINE=InnoDB;\n2.2 插入与更新\n-- 插入 JSON 对象或数组\nINSERT INTO configs (data) VALUES\n  (&#039;{&quot;theme&quot;:&quot;dark&quot;,&quot;features&quot;:{&quot;beta&quot;:true,&quot;maxItems&quot;:10}}&#039;),\n  (&#039;[1,2,3,{&quot;x&quot;:5}]&#039;);\n \n-- 更新子属性\nUPDATE configs\n  SET data = JSON_SET(data, &#039;$.features.maxItems&#039;, 20)\nWHERE id = 1;\n2.3 验证与转换\n\n验证合法性\n\nSELECT JSON_VALID(data) FROM configs;\n\n从字符串转换\n\nSELECT CAST(&#039;{&quot;a&quot;:1}&#039; AS JSON);\n\n三、JSON 查询与修改函数\n路径 (path) 语法：$ 根；.key 对象；[index] 数组；支持通配 [*]、$.a.b[*].c\n3.1 访问与提取\n\n操作符\n\nSELECT data-&gt;&#039;$.features.beta&#039;    AS beta_flag,   -- JSON 类型\n       data-&gt;&gt;&#039;$.theme&#039;            AS theme_text;  -- 文本\n\nJSON_EXTRACT / JSON_UNQUOTE\n\nSELECT JSON_EXTRACT(data, &#039;$.features.maxItems&#039;) AS maxItems;\nSELECT JSON_UNQUOTE(JSON_EXTRACT(data, &#039;$.theme&#039;)) AS theme;\n3.2 修改与合并\n\nJSON_SET：设置或新增\nJSON_REPLACE：仅当路径存在时替换\nJSON_REMOVE：删除路径\nJSON_MERGE_PRESERVE：合并多个文档，不同 MySQL 版本函数名有细微差异\n\nUPDATE configs\nSET data = JSON_REMOVE(data, &#039;$.features.beta&#039;);\n3.3 数组操作\n\nJSON_ARRAY_APPEND / JSON_ARRAY_INSERT：追加或插入\nJSON_LENGTH：计算数组或对象键数\nJSON_ARRAYAGG / JSON_OBJECTAGG（8.0+）：聚合查询结果\n\nSELECT JSON_ARRAYAGG(user_id) FROM orders WHERE status=&#039;shipped&#039;;\n3.4 搜索与遍历\n\nJSON_SEARCH：查找元素路径\nJSON_CONTAINS / JSON_CONTAINS_PATH：判断包含\n\nSELECT * FROM configs\nWHERE JSON_CONTAINS_PATH(data, &#039;one&#039;, &#039;$.features.beta&#039;);\n\nJSON_TABLE（8.0+）：将 JSON 文档映射为虚拟表，用于 JOIN 与更复杂的关系查询\n\nSELECT * \nFROM configs,\n     JSON_TABLE(data, &#039;$.items[*]&#039;\n       COLUMNS (item_id INT PATH &#039;$&#039;)) AS jt;\n\n四、索引策略\n4.1 直接索引\nMySQL 8.0.17 起支持对 JSON 文档 全文索引：\nALTER TABLE configs\n  ADD FULLTEXT INDEX idx_data (data);\n4.2 虚拟/生成列索引\n最常用方式：创建生成列（VIRTUAL 或 STORED），并对其建立普通或前缀索引：\nALTER TABLE configs\n  ADD COLUMN theme VARCHAR(20) \n    AS (JSON_UNQUOTE(JSON_EXTRACT(data, &#039;$.theme&#039;))) \n    STORED,\n  ADD INDEX idx_theme (theme);\n\n优势：对单一键快速过滤；\n代价：生成列占储存空间（STORED）或计算开销（VIRTUAL）。\n\n\n五、性能与最佳实践\n\n文档大小：尽量让 JSON 文档保持“小而扁平”，避免深度嵌套与超大数组。\n生成列索引：对常查询字段务必用生成列并建索引，避免全表扫描 JSON_EXTRACT。\n合理划分：若 JSON 字段中大部分属性在 WHERE/ORDER BY 中被频繁访问，建议拆到标准列。\n监控与分析：使用 EXPLAIN 查看 JSON_EXTRACT 调用的成本，结合 performance_schema 跟踪慢查询。\nSQL 模式：启用严格模式可防止非法 JSON 插入；关闭 NO_ZERO_DATE 避免自动填入无效日期。\n"},"数据库/MySQL/数据类型详解/地理空间类型":{"slug":"数据库/MySQL/数据类型详解/地理空间类型","filePath":"数据库/MySQL/数据类型详解/地理空间类型.md","title":"地理空间类型","links":[],"tags":[],"content":"一、空间类型概览\nMySQL 支持一组遵循 OGC（Open Geospatial Consortium）标准的几何类型（Geometry Types）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型描述GEOMETRY通用几何类型，任意其他几何类型的超类POINT点：一对（X, Y）坐标LINESTRING折线：由一系列点连接而成的路径POLYGON多边形：由封闭的环（外环 + 0 或多内环）组成MULTIPOINT多点集合MULTILINESTRING多折线集合MULTIPOLYGON多多边形集合GEOMETRYCOLLECTION各类几何对象的混合集合\n\n二、内部存储（Binary 格式）\n\nWKB（Well-Known Binary）：MySQL 将几何体以紧凑的二进制格式存储，包含：\n\n\n字节序标志（1 字节，LE/BE）\n类型码（4 字节）\n可选 SRID（4 字节，MySQL 8.0+）\n坐标数据（浮点数序列，X,Y[,Z][,M]）\n\n\n优点：紧凑、高效；读取时可直接映射到内存结构，无需解析文本。\n\n\n三、SRID 与坐标参考系统\n\nSRID（Spatial Reference ID）：标识坐标系（如 EPSG:4326 表示 WGS84 经纬度）\nMySQL 8.0+ 支持在列定义中指定 SRID，并在插入几何值时检查一致性：\n\nCREATE TABLE places (\n  id    INT PRIMARY KEY AUTO_INCREMENT,\n  geom  POINT NOT NULL SRID 4326\n) ENGINE=InnoDB;\n\n无 SRID：早期版本或未显式指定时，默认为 SRID=0（用户需自行约定坐标系）。\n\n\n四、建表与插入示例\n-- 1. 创建表：存储不同几何类型，并指定 SRID（可选）\nCREATE TABLE spatial_demo (\n  id        INT PRIMARY KEY AUTO_INCREMENT,\n  pt        POINT                 NOT NULL SRID 4326,\n  ln        LINESTRING            NOT NULL SRID 4326,\n  poly      POLYGON               NOT NULL SRID 3857,  -- Web Mercator\n  coll      GEOMETRYCOLLECTION    NULL\n) ENGINE=InnoDB\n  /*!80003 SPATIAL KEY(pt) */;   -- 仅 MySQL 8.0+ 支持 InnoDB SPATIAL 索引\n \n-- 2. 插入数据：使用 WKT (Well-Known Text) 构造\nINSERT INTO spatial_demo (pt, ln, poly) VALUES\n  (\n    ST_GeomFromText(&#039;POINT(-73.97 40.77)&#039;, 4326),\n    ST_GeomFromText(&#039;LINESTRING(0 0,10 10,20 25)&#039;, 4326),\n    ST_GeomFromText(&#039;POLYGON((0 0,4 0,4 4,0 4,0 0))&#039;, 3857)\n  );\n\n五、空间索引（SPATIAL Index）\n\n用途：加速范围查询、相交查询、最近邻等空间操作\n创建：必须在 InnoDB 且列类型为非 NULL 的几何类型上才能建 SPATIAL 索引\n\nALTER TABLE spatial_demo\n  ADD SPATIAL INDEX idx_pt (pt),\n  ADD SPATIAL INDEX idx_ln (ln);\n\n\n实现机制：R-Tree + MBR（最小包围矩形）\n\n\n限制：\n\n\n仅支持二维（X,Y）；\n\n\n不支持 GEOMETRYCOLLECTION；\n\n\n不支持带 NULL 的列；\n\n\n\n六、常用 GIS 函数\n6.1 创建与转换\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明ST_GeomFromText(wkt[, srid])将 WKT 文本解析为几何对象ST_AsText(geom)将几何对象格式化为 WKT 文本ST_GeomFromWKB(wkb[, srid])解析 WKB（二进制）ST_AsWKB(geom)输出 WKB\n6.2 空间关系\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明ST_Contains(a, b)几何 a完全包含 bST_Within(a, b)a完全在 b内ST_Intersects(a, b)a与 b相交ST_Touches(a, b)仅在边界上接触ST_Crosses(a, b)线与线或线与面交叉ST_Disjoint(a, b)完全无重叠\n6.3 度量与距离\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明ST_Distance(a, b)欧几里得距离（同 SRID 单位）ST_Length(a)路径长度，仅限线类型ST_Area(a)面积，仅限面类型\n6.4 辅助函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明ST_Envelope(geom)返回几何最小包围矩形（MBR）ST_Centroid(geom)计算几何中心ST_Buffer(geom, d)生成以 geom为中心、半径 d的缓冲区ST_SRID(geom)获取 SRIDST_SetSRID(geom, srid)设置或转换几何的 SRID\n\n七、使用场景\n\n地图标注：用户位置点、POI（Point of Interest）\n地理围栏：用 ST_Contains() 判断点是否在多边形内\n网络分析：道路网络折线距离与最短路径估算\n地块管理：用多边形表示土地边界，计算面积与相邻关系\n环境监测：传感器分布、监测区范围\n\n\n八、最佳实践与注意事项\n\n选用合适的 SRID：\n\n\n经纬度（地理坐标）：EPSG:4326，单位为度；\n平面投影：EPSG:3857（Web Mercator）或本地投影，单位为米。\n\n\n生成“扁平”几何：避免过度精细节点，减少存储与计算开销。\n空间索引覆盖常用列：对经常做范围/相交查询的列建 SPATIAL 索引。\n查询顺序：先用索引（MBR）过滤，再用精确函数过滤，提升性能：\n\nSELECT * FROM spatial_demo\nWHERE MBRContains(Envelope(ST_GeomFromText(&#039;POLYGON(...)&#039;)), pt)\n  AND ST_Within(pt, ST_GeomFromText(&#039;POLYGON(...)&#039;));\n\n版本依赖：MySQL 8.0 才支持 SRID 校验、更多 GIS 函数与 InnoDB 空间索引；\n在旧版本上，部分函数或索引可能仅在 MyISAM 引擎可用。\n精度与坐标转换：经纬度距离计算需经过坐标变换或使用地理距离公式（Haversine），MySQL 本身仅做平面几何运算。\n"},"数据库/MySQL/数据类型详解/字符串类型":{"slug":"数据库/MySQL/数据类型详解/字符串类型","filePath":"数据库/MySQL/数据类型详解/字符串类型.md","title":"字符串类型","links":[],"tags":[],"content":"1. 定长字符串（CHAR / BINARY）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型最大长度存储开销说明CHAR(M)0 ≤ M ≤ 255 字符固定 M × N 字节（N = 每字符最大字节数）定长字符类型，不足部分以填充字符（CHAR：空格，BINARY：\\0）补齐。适合长度固定的短文本。BINARY(M)0 ≤ M ≤ 255 字节固定 M 字节定长二进制类型，不做字符集/校对处理，按字节存取。\n\n\n存储细节\n\n\n对于多字节字符集（如 utf8mb4，N=4），CHAR(10) 最多占 40 字节。\n\n\n行内始终保留全部空间，读写速度稳定。\n\n\n优缺点\n\n\n访问速度最快，不需存储长度信息\n\n\n– 空间浪费（尤其多余填充）、不适合长度差异大的场景\n\n\n示例\n\n\nCREATE TABLE codes (\n  code CHAR(8)      -- 如固定 8 位的激活码\n) CHARSET = utf8mb4;\n\n2. 可变长字符串（VARCHAR / VARBINARY）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型最大长度存储开销说明VARCHAR(M)0 ≤ M ≤ 65 535 字节（≈64 KB）L + 1 或 2 字节（L 为实际字节数）可变字符类型，按实际长度存储，并保留 1 字节（≤255）或 2 字节（＞255）的长度前缀。VARBINARY(M)同 VARCHAR(M)同 VARCHAR可变二进制类型，不做字符集/校对处理。\n\n\n最大长度限制\n\n\n单行最大 65 535 字节（含所有列、NULL 标志、长度前缀等开销）。\n\n\n在多字节字符集下，VARCHAR(16383) 在 utf8mb4 下最安全（16383×4 ≈ 65532 字节 + 2 字节前缀）。\n\n\n存储与性能\n\n\n适合长度不定且偏短的文本字段，如用户名、标题。\n\n\n存储节省空间，但读取时需先读前缀获知长度。\n\n\n更新时若新长度超出原空间，可能触发行迁移（性能开销）。\n\n\n示例\n\n\nCREATE TABLE users (\n  nickname VARCHAR(50)     -- 变长昵称\n) CHARSET = utf8mb4;\n\n3. 大对象（TEXT / BLOB）\nMySQL 提供四种文本与四种二进制大对象，区别仅在最大长度与存储方式。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型最大长度存储用途示例TINYTEXT255 字节1 字节长度前缀 + L短注释、简短描述TEXT65 535 字节2 字节长度前缀 + L中等文本，如文章摘要MEDIUMTEXT16 777 215 字节3 字节长度前缀 + L大文本，如长篇文章LONGTEXT4 294 967 295 字节4 字节长度前缀 + L超大文本，如日志、文档TINYBLOB255 字节同 TINYTEXT小文件、图标BLOB65 535 字节同 TEXT图片、二进制配置MEDIUMBLOB16 777 215 字节同 MEDIUMTEXT中型文件LONGBLOB4 294 967 295 字节同 LONGTEXT大型文件\n\n\n存储机制\n\n\n默认存储在行外：行内保留 20 字节指针，具体数据页存放实际内容。\n\n\n可通过 ROW_FORMAT=DYNAMIC/COMPRESSED 控制短文本是否保留在行内。\n\n\n索引限制\n\n\n不能对全文字段全文索引（除 FULLTEXT），也不能建立完整索引，只能建立前缀索引：\n\n\nALTER TABLE articles\n  ADD INDEX idx_title_prefix(title(191));\n\n\nutf8mb4 下 191 字符 × 4 字节 = 764 字节，接近 InnoDB 默认 767 字节前缀限制。\n\n\n使用场景\n\n\nTEXT 系列：存储大量可搜索的文本\n\n\nBLOB 系列：存储二进制文件，如图片、压缩包\n\n\n\n4. 枚举与集合（ENUM / SET）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型可选值数存储开销说明ENUM(&#039;a&#039;,&#039;b&#039;,...)最多 65 535 个选项1 或 2 字节 （第 N 项存为整数 N）值必须从预定义列表中选一个，可节省存储并能做约束；适合少量状态码SET(&#039;a&#039;,&#039;b&#039;,...)最多 64 个选项1–8 字节 （位图）值可为多个列表元素的组合，内部按位存储；适合多选标志位，如用户兴趣标签\n\n\n优点\n\n\n存储紧凑，查询时可用 FIND_IN_SET() 或位运算判断。\n\n\n约束强，杜绝非法值插入。\n\n\n缺点\n\n\n扩展字段时需 ALTER TABLE，影响表重建与停机维护。\n\n\n在 SQL 以外的环境（如 ORM）支持度参差。\n\n\n示例\n\n\nCREATE TABLE products (\n  status ENUM(&#039;draft&#039;,&#039;active&#039;,&#039;archived&#039;) NOT NULL DEFAULT &#039;draft&#039;,\n  tags   SET(&#039;hot&#039;,&#039;new&#039;,&#039;sale&#039;,&#039;limited&#039;) NOT NULL\n);\n\n5. JSON（可选）\n虽然 JSON 属于独立类型，但其本质也是字符串存储优化：\nCREATE TABLE configs (\n  data JSON NOT NULL\n);\n\n存储：二进制格式，自动校验合法性\n索引：可对虚拟列建立普通索引\n查询：支持 -&gt;、-&gt;&gt;、JSON_EXTRACT() 等丰富函数\n\n\n小结与选型建议\n\n短定长：CHAR — 如国家码、固定长度哈希\n短可变：VARCHAR — 如姓名、标题\n大文本：TEXT / MEDIUMTEXT — 如文章正文\n二进制：VARBINARY / BLOB — 如文件、图片\n受限枚举：ENUM / SET — 少量固定/多选状态\n半结构化：JSON — 灵活配置、日志、事件数据\n"},"数据库/MySQL/数据类型详解/数值类型":{"slug":"数据库/MySQL/数据类型详解/数值类型","filePath":"数据库/MySQL/数据类型详解/数值类型.md","title":"数值类型","links":[],"tags":[],"content":"MySQL 支持从 1 字节到 8 字节不等的多种整数类型，可根据数据大小和符号需求来选用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型存储大小有符号范围无符号范围备注TINYINT[(M)]1 字节–128 … 1270 … 255TINYINT(1)常用于布尔值；(M)为显示宽度，仅配合 ZEROFILL影响显示。SMALLINT[(M)]2 字节–32,768 … 32,7670 … 65,535MEDIUMINT[(M)]3 字节–8,388,608 … 8,388,6070 … 16,777,215INT[(M)] / INTEGER[(M)]4 字节–2,147,483,648 … 2,147,483,6470 … 4,294,967,295最常用的自增主键类型。BIGINT[(M)]8 字节–9.22×10¹⁸ … 9.22×10¹⁸0 … 1.84×10¹⁹用于超大范围计数，如累计流水号、Unix 时间戳。\n1.1 UNSIGNED 与 ZEROFILL\n\n**UNSIGNED**：仅存储非负值，上表中的“无符号范围”。\n**ZEROFILL**：在查询显示时，用零填充到定义宽度（M 位），隐含 UNSIGNED 属性。\n\n-- 一个 4 位宽度、无符号、自增、前导零填充的整型主键\nCREATE TABLE orders (\n  id INT(4) UNSIGNED ZEROFILL AUTO_INCREMENT PRIMARY KEY,\n  ...\n);\n-- 查询时 id=5 会显示为 0005\n\n2. 定点十进制类型（Fixed-Point Types）\n当需要绝对精度（如金钱、财务计算）时，应使用定点类型。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型存储（字节）说明DECIMAL(M[,D])大约 ⌈M/9⌉×4 + 2精确定点，M为最大总位数（0–65），D为小数位数（0–30）。NUMERIC(M[,D])同 DECIMAL同义词，行为一致。\n2.1 精度与存储\n\nMySQL 将定点值按每 9 位数字压缩存储为 4 字节。\n例如 DECIMAL(10,2) 最多存储 8 位整数 + 2 位小数，总共 10 位，约占 4 + 4 + 2 = 10 字节（粗略估算）。\n\n2.2 运算特点\n\n绝对精确：不会有浮点舍入误差。\n性能开销：比整数和浮点略高，但在财务场景几乎必选。\n\n\n3. 浮点类型（Floating-Point Types）\n用于存储近似值，适合科学计算、统计分析，但不推荐用于财务场景。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型存储大小精度说明FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]4 字节~7 位十进制数单精度，误差 ±1 ULP（unit in last place）DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]8 字节~15 位十进制数双精度，误差更小，适合大多数统计/工程计算。REAL同 DOUBLE—在 MySQL 中为 DOUBLE的同义词（取决于 SQL 模式）。\n3.1 (M,D) 语法\n\n(M,D) 指定 显示 宽度和小数位，但并不改变内部精度。\n通常推荐省略，直接用 FLOAT / DOUBLE。\n\n3.2 舍入与比较\n\n浮点运算存在舍入误差，不应用 = 精确比较，推荐使用范围判断：\n\nWHERE ABS(val - 3.14) &lt; 0.00001\n\n4. 位类型（Bit-Field）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型存储大小说明BIT[(M)]⌈M/8⌉ 字节用于存储二进制位序列，M 范围 1–64。\nCREATE TABLE flags (\n  mask BIT(16) NOT NULL\n);\nINSERT INTO flags (mask) VALUES (b&#039;1011001110001111&#039;);\n\n可用 b&#039;...&#039; 或十六进制 x&#039;...&#039; 文字。\n适用于紧凑存储多路开关、布尔集合。\n\n\n5. 布尔类型（Boolean）\nMySQL 将 BOOL 和 BOOLEAN 当作 TINYINT(1) 的同义词：\nCREATE TABLE settings (\n  feature_enabled BOOLEAN NOT NULL DEFAULT TRUE\n);\n\nTRUE 等价于非零，FALSE 等价于零。\n语义上便于表意，但底层仍是整数。\n\n\n6. 精度、范围与溢出\n\n插入超范围值：MySQL 会根据 SQL 模式决定是截断到边界值并产生警告，还是报错（严格模式）。\n算术溢出：同样依赖 SQL 模式，推荐在生产启用严格模式（STRICT_ALL_TABLES 或 STRICT_TRANS_TABLES）以避免静默截断。\n\n\n7. 选型建议\n\n计数、自增主键：INT（或根据规模选 SMALLINT/BIGINT）。\n状态码、枚举值：可选 TINYINT；若需要位标志或多选，选 BIT。\n财务金额：DECIMAL（如 DECIMAL(10,2)）。\n科学计算/统计：FLOAT（较小数据量）或 DOUBLE（高精度）。\n布尔值：可用 BOOLEAN，语义清晰。\n"},"数据库/MySQL/数据类型详解/日期时间类型":{"slug":"数据库/MySQL/数据类型详解/日期时间类型","filePath":"数据库/MySQL/数据类型详解/日期时间类型.md","title":"日期时间类型","links":[],"tags":[],"content":"一、DATE\n\n存储：3 字节\n取值范围：&#039;1000-01-01&#039; … &#039;9999-12-31&#039;\n格式：&#039;YYYY-MM-DD&#039;\n用途：仅存储“年-月-日”，适合生日、事件日期、到期日等不涉时分秒的场景。\n\nCREATE TABLE events (\n  event_date DATE NOT NULL\n);\n \nINSERT INTO events (event_date)\nVALUES (&#039;2025-06-30&#039;);\n\n\n函数：\n\n\nCURDATE() / CURRENT_DATE → 当前日期\n\n\nDATE(expr) → 提取日期部分\n\n\nDAY(), MONTH(), YEAR() 等 → 单独字段\n\n\n默认与零值：\n\n\n如果未指定且列定义了 NOT NULL，严格模式下报错；非严格模式下默认 &#039;0000-00-00&#039;（可通过 sql_mode 禁用）。\n\n\n索引：可直接建普通索引，用于范围查询或分区。\n\n\n\n二、TIME\n\n存储：3–6 字节（根据是否带小数秒）\n取值范围：&#039;-838:59:59&#039; … &#039;838:59:59&#039;\n格式：&#039;[±]HH:MM:SS[.fraction]&#039;\n用途：存储时间段或时刻，可为负；适合工时、时长、时差、营业时间段等。\n\nCREATE TABLE shifts (\n  duration TIME NOT NULL,\n  start_time TIME NOT NULL\n);\n \nINSERT INTO shifts (duration, start_time)\nVALUES (&#039;08:30:00&#039;, &#039;09:00:00&#039;);\n\n\n小数秒（fsp）：TIME(3) 存毫秒，TIME(6) 存微秒，f-秒精度范围 0–6。\n\n\n函数：\n\n\nCURTIME() → 当前本地时间\n\n\nTIMEDIFF(t1, t2) → 时间差\n\n\nADDTIME()/SUBTIME() → 加减时分秒\n\n\n注意：TIME 可超 24 小时，适合累计或定时器场景。\n\n\n\n三、DATETIME\n\n存储：5–8 字节（取决于 fsp）\n取值范围：&#039;1000-01-01 00:00:00&#039; … &#039;9999-12-31 23:59:59&#039;，加上 &#039;.000000&#039;…&#039;.999999&#039;（fsp 0–6）\n格式：&#039;YYYY-MM-DD HH:MM:SS[.fraction]&#039;\n用途：存储一个绝对的日期和时间，不随时区转换；适合日程、日志时间戳、预约时间等。\n\nCREATE TABLE appointments (\n  start_at DATETIME(3) NOT NULL,\n  end_at   DATETIME(3) NOT NULL\n);\n\n小数秒（fsp）：指定微秒精度，例如 DATETIME(6) 最多保留 6 位小数秒；默认 fsp=0。\n自动初始化/更新（MySQL 5.6+）：\n\ncreated_at DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3),\nupdated_at DATETIME(3)\n  DEFAULT CURRENT_TIMESTAMP(3)\n  ON UPDATE CURRENT_TIMESTAMP(3)\n\n\n时区：不进行任何时区转换，存入什么值取出什么值。\n\n\n函数：\n\n\nNOW() / CURRENT_TIMESTAMP → 当前系统时间\n\n\nDATE_FORMAT(), STR_TO_DATE() → 格式化/解析\n\n\n\n四、TIMESTAMP\n\n存储：4–7 字节（取决于 fsp）\n取值范围：&#039;1970-01-01 00:00:01&#039; UTC … &#039;2038-01-19 03:14:07&#039; UTC；加小数秒 &#039;.000000&#039;…&#039;.999999&#039;（fsp 0–6）\n格式：同 DATETIME\n用途：存储一个相对于 Unix 纪元（1970-01-01）的时间戳，自动随连接时区转换，适合记录修改时间、审计日志。\n\nCREATE TABLE users (\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  last_login TIMESTAMP NULL\n    DEFAULT NULL\n    ON UPDATE CURRENT_TIMESTAMP\n);\n\n\n自动属性：\n\n\nMySQL 5.6+ 支持多个 TIMESTAMP/DATETIME 列使用 DEFAULT CURRENT_TIMESTAMP 与 ON UPDATE。\n\n\n未指定列类型时，最先出现的 TIMESTAMP 列会自动 DEFAULT CURRENT_TIMESTAMP。\n\n\n时区行为：\n\n\n写入：客户端时区 → 转为 UTC 存储\n\n\n读取：UTC → 转为客户端时区\n\n\n应用考量：\n\n\n当应用可能在不同时区部署且希望统一显示当地时间，优先选 TIMESTAMP。\n\n\n注意 2038 年 “千年虫” 问题；如需更宽范围，可用 DATETIME。\n\n\n\n五、YEAR\n\n存储：1 字节\n取值范围：1901 … 2155，以及 0000；若定义为 YEAR(2)，则 00–69 → 2000–2069，70–99 → 1970–1999\n格式：YYYY 或 YY\n用途：仅存储年份，适合财年、毕业年、报表年份等。\n\nCREATE TABLE reports (\n  year YEAR NOT NULL,\n  total DECIMAL(12,2)\n);\n\n注意：YEAR(4) 是默认显示 4 位；YEAR(2) 多为向后兼容，推荐显式使用 YEAR（同 YEAR(4)）。\n\n\n六、选型与最佳实践\n\n存储需求\n\n\n仅日期：DATE\n仅时间量/差：TIME\n本地绝对时间：DATETIME\n需时区转换或审计：TIMESTAMP\n仅年份：YEAR\n\n\n微秒需求：在高精度日志或科学场景下，使用 fsp 参数提升精度（(3) 毫秒、(6) 微秒）。\n默认与自动更新：\n\n\n对审计字段，优先用 TIMESTAMP 的自动属性；\n若需存储历史“原始输入值”，选 DATETIME 并手动赋值。\n\n\nSQL MODE：\n\n\n启用严格模式（STRICT_TRANS_TABLES）可避免无效或零值“静默”插入。\n\n\n索引与分区：\n\n\n大数据量时，可按日期列分区（PARTITION BY RANGE (TO_DAYS(created_at))）或分表；\n建立覆盖索引加速范围扫描。\n"},"数据库/MySQL/数据类型详解/枚举与集合":{"slug":"数据库/MySQL/数据类型详解/枚举与集合","filePath":"数据库/MySQL/数据类型详解/枚举与集合.md","title":"枚举与集合","links":[],"tags":[],"content":"一、ENUM 类型\n1. 定义与语法\ncolumn_name ENUM(&#039;value1&#039;,&#039;value2&#039;,...,&#039;valueN&#039;) [ \n    CHARACTER SET charset_name \n    COLLATE collation_name\n] [ NOT NULL | NULL ] [ DEFAULT &#039;value_default&#039; ]\n\n列值只能是列表中出现的某一个字符串。\n列定义时也可指定字符集与校对规则，否则继承表的 DEFAULT CHARSET/COLLATE。\n\n2. 存储与性能\n\n\n存储开销：\n\n\n枚举成员数 ≤ 255 时，占 1 字节；\n\n\n256–65 535 时，占 2 字节（极少见）。\n\n\n内部表示：按成员在列表中的序号（从 1 开始）存储，0 表示 “空枚举” &#039;&#039;（如果允许 NULL，则 0 与 NULL 不同）。\n\n\n查询比较：比较时先比较内部整数，再按字符串（仅当序号相等时）；非常快。\n\n\n3. 默认值与非法值处理\n\n\n默认值：若未指定，默认值为 第一个枚举成员；在严格模式下，不允许插入非法值。\n\n\n非法值处理：\n\n\n严格模式（STRICT_TRANS_TABLES）：插入不在列表中的值报错；\n\n\n非严格模式：插入非法值时存入空枚举（序号 0），并产生警告。\n\n\n4. 排序行为\n\nORDER BY enum_col 将按定义顺序（其内部整数值）排序，不是字典序。\n\n5. 常用操作\n-- 查询某值的内码\nSELECT column_name+0 FROM table;\n \n-- 按内码排序（等同于默认）\nSELECT * FROM table ORDER BY column_name+0;\n \n-- 按字典序排序\nSELECT * FROM table \nORDER BY CAST(column_name AS CHAR) COLLATE utf8mb4_unicode_ci;\n6. 修改枚举列表\nALTER TABLE t \n  MODIFY COLUMN status \n    ENUM(&#039;draft&#039;,&#039;active&#039;,&#039;archived&#039;,&#039;deleted&#039;) \n    NOT NULL DEFAULT &#039;draft&#039;;\n注意：ALTER TABLE … MODIFY 会重建全表，遍历并验证每行值，开销较大。\n7. 使用场景\n\n状态机（&#039;pending&#039;/&#039;approved&#039;/&#039;rejected&#039;）\n类型分类（性别、等级、颜色码等）\n适合 成员固定且数量少、变动不频繁的场景。\n\n\n二、SET 类型\n1. 定义与语法\ncolumn_name SET(&#039;opt1&#039;,&#039;opt2&#039;,...,&#039;optM&#039;) [ \n    CHARACTER SET charset_name \n    COLLATE collation_name\n] [ NOT NULL | NULL ] [ DEFAULT &#039;&#039; ]\n\n列值可以是列表成员的 任意子集，用逗号连接，如 &#039;opt1,opt3&#039;。\n最多可定义 64 个成员。\n\n2. 存储与性能\n\n存储开销：占用 ⌈M/8⌉ 字节（M 为定义的成员个数）。\n内部表示：将每个成员映射到一个二进制位，组合值即位掩码。\n查询速度：也是整型比较，查询与位运算性能优秀。\n\n3. 默认与非法值处理\n\n默认值：若未指定且允许 NULL，则默认为空字符串 &#039;&#039;（表示空集合）。\n非法值处理：同 ENUM，在严格模式下报错，否则丢弃非法部分并警告。\n\n4. 常用操作\n-- 插入\nINSERT INTO t (tags) VALUES (&#039;hot,new&#039;);  -- 同时选中 hot 和 new\n \n-- 判断包含某一选项\nSELECT * FROM t \nWHERE FIND_IN_SET(&#039;sale&#039;, tags) &gt; 0;\n \n-- 判断包含所有选项\nSELECT * FROM t \nWHERE FIND_IN_SET(&#039;hot&#039;, tags)\n  AND FIND_IN_SET(&#039;new&#039;, tags);\n \n-- 使用位运算（更高效，但需先知道位掩码）\n-- 假设 &#039;hot&#039; 为第 1 位，掩码为 1&lt;&lt;0 = 1\nSELECT * FROM t \nWHERE (tags &amp; 1) &lt;&gt; 0;\n5. 修改集合列表\nALTER TABLE t \n  MODIFY COLUMN tags \n    SET(&#039;hot&#039;,&#039;new&#039;,&#039;sale&#039;,&#039;limited&#039;,&#039;featured&#039;) \n    NOT NULL DEFAULT &#039;&#039;;\n同样会重建全表，谨慎在高峰期执行。\n6. 使用场景\n\n标签/标记：如用户兴趣标签、文章分类标签\n多选项标志：功能开关（feature flags）、权限集合\n\n\n三、ENUM vs SET 对比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性ENUMSET值类型单一成员多成员组合最大成员数65 53564存储1–2 字节（序号）⌈M/8⌉ 字节（位图）是否可为空集/空枚举空枚举 &#039;&#039;与 NULL 不同空集合 &#039;&#039;与 NULL 不同排序按定义顺序按位值大小扩展ALTER 重建全表，影响全量数据同 ENUM查询匹配= &#039;value&#039;FIND_IN_SET()或 位运算推荐场景状态、单选分类标签、多选标志\n\n四、选型与最佳实践\n\n稳定少量单选项 → ENUM\n灵活多选标记 → SET\n强关系/可扩展 → 建议使用 关联表（一对多或多对多），替代过度依赖 ENUM/SET，提升灵活性与可维护性。\n严格模式 下避免非法值沉默失败，开启 STRICT_TRANS_TABLES 可保证数据合法性。\n性能监控：对高写场景慎用 ALTER 操作，改动前应评估重建成本或采用灰度上线。\n"},"数据库/MySQL/概览":{"slug":"数据库/MySQL/概览","filePath":"数据库/MySQL/概览.md","title":"概览","links":[],"tags":[],"content":"MySQL 知识体系大纲\n1. MySQL 概述\n\n1.1 什么是关系型数据库与 MySQL\n1.2 MySQL 发展历史及主要版本\n1.3 MySQL 核心特性与应用场景\n1.4 MySQL 与其他数据库对比\n\n2. 安装与初步配置\n\n2.1 环境要求（操作系统、内存、磁盘）\n2.2 在 Windows、Linux（RPM/DEB）、macOS 上安装\n2.3 配置文件（my.cnf / my.ini）详解\n2.4 启动、停止、重启与服务管理\n2.5 日志文件：错误日志、慢查询日志、通用查询日志\n\n3. 客户端与可视化工具\n\n3.1 命令行工具：mysql、mysqldump 等\n3.2 MySQL Workbench 基本使用\n3.3 phpMyAdmin、Navicat、DBeaver 等\n3.4 常用运维脚本与自动化\n\n4. 数据库与表的基本操作\n\n4.1 数据库的创建、修改与删除\n4.2 表的增，删，改，查\n4.3 表属性：字符集、排序规则、行格式\n4.4 数据导入导出（LOAD DATA、SELECT … INTO OUTFILE）\n\n5. 数据类型详解\n\n5.1 数值类型：INT、BIGINT、DECIMAL、FLOAT、DOUBLE\n5.2 字符串类型：CHAR、VARCHAR、TEXT、BLOB\n5.3 日期/时间类型：DATE、DATETIME、TIMESTAMP、TIME、YEAR\n5.4 枚举与集合：ENUM、SET\n5.5 JSON 与地理空间类型（POINT、GEOMETRY 等）\n\n6. SQL 基础语法\n\n6.1 DDL（数据定义语言）：CREATE、ALTER、DROP、TRUNCATE\n6.2 DML（数据操作语言）：SELECT、INSERT、UPDATE、DELETE、REPLACE\n6.3 DCL（数据控制语言）：GRANT、REVOKE\n6.4 TCL（事务控制语言）：START TRANSACTION、COMMIT、ROLLBACK、SAVEPOINT\n6.5 基本约束：PRIMARY KEY、FOREIGN KEY、UNIQUE、NOT NULL、CHECK\n\n7. 高级查询\n\n7.1 多表连接：INNER/LEFT/RIGHT/CROSS JOIN\n7.2 子查询（标量、行、相关子查询）\n7.3 集合运算：UNION、INTERSECT、EXCEPT\n7.4 排序和分组：ORDER BY、GROUP BY、HAVING\n7.5 窗口函数：ROW_NUMBER、RANK、LAG、LEAD 等\n7.6 公共表表达式（CTE）\n\n8. 索引与执行计划\n\n8.1 索引原理：B+ 树、哈希、全文索引、空间索引\n8.2 索引的创建与维护\n8.3 覆盖索引与前缀索引\n8.4 EXPLAIN/MYSQL TRACE 执行计划分析\n8.5 慢查询日志与诊断\n\n9. 存储引擎\n\n9.1 InnoDB 引擎详解\n9.2 MyISAM 引擎特点\n9.3 Memory、CSV、Archive、Blackhole、NDB Cluster 等\n9.4 不同场景下的存储引擎选型\n\n10. 事务与锁\n\n10.1 事务隔离级别（READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE）\n10.2 InnoDB MVCC 原理\n10.3 锁机制：行锁、表锁、意向锁\n10.4 死锁检测与解决策略\n\n11. 存储过程、函数与触发器\n\n11.1 存储过程（Stored Procedure）\n11.2 用户自定义函数（UDF）\n11.3 触发器（Trigger）使用场景与性能影响\n11.4 游标（Cursor）与异常处理\n\n12. 视图、事件与调度\n\n12.1 视图（View）的创建与限制\n12.2 优化可更新视图\n12.3 事件调度器（Event Scheduler）\n12.4 定时任务管理\n\n13. 安全与权限管理\n\n13.1 用户管理与权限系统\n13.2 密码策略与认证插件\n13.3 SSL/TLS 加密连接\n13.4 数据加密与审计\n\n14. 备份与恢复\n\n14.1 逻辑备份：mysqldump、mysqlpump\n14.2 物理备份：Percona XtraBackup、mysqlbackup\n14.3 热备份与冷备份\n14.4 点-in-时间恢复（PITR）\n14.5 备份验证与演练\n\n15. 复制与高可用\n\n15.1 主从复制原理与配置\n15.2 半同步复制与组复制（Group Replication）\n15.3 主主复制与冲突处理\n15.4 MHA、ProxySQL、Orchestrator 等运维工具\n15.5 InnoDB Cluster 与分布式方案\n\n16. 分库分表与分区\n\n16.1 MySQL 分区表（RANGE、LIST、HASH、KEY）\n16.2 分库分表策略与规范\n16.3 中间件：ShardingSphere、Mycat、Vitess\n\n17. 性能监控与诊断\n\n17.1 Performance Schema 与 Information Schema\n17.2 慢查询日志、锁等待分析\n17.3 常用监控指标与报警方案\n17.4 Grafana + Prometheus + Percona Monitoring (PMM)\n\n18. 新特性与扩展\n\n18.1 MySQL 8.x 新增特性（窗口函数、UTF8MB4 改进、隐式排序索引等）\n18.2 JSON 支持与全文搜索\n18.3 地理空间 (GIS) 功能\n18.4 外部数据源与连接器（Federação）\n\n19. 编程接口与 ORM\n\n19.1 官方 Connector：JDBC、ODBC、C/C++、Python、Node.js、Go 等\n19.2 主流 ORM 框架：Hibernate、MyBatis、Sequelize、ActiveRecord\n19.3 连接池与高并发最佳实践\n\n20. 实战案例与项目经验\n\n20.1 电商系统数据库设计\n20.2 日志与指标采集系统\n20.3 数据仓库 ETL 与 MySQL\n20.4 大数据场景下的 MySQL 混合架构\n\n21. 进阶学习资源\n\n21.1 官方文档与发行说明\n21.2 社区博客与技术论坛\n21.3 推荐书籍（《High Performance MySQL》《MySQL Cookbook》…）\n21.4 开源工具与插件\n"}}