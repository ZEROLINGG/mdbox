


想象一下，你需要编写一个函数来交换两个变量的值。

对于 `int` 类型，你会这样写：

```cpp
void swapInt(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
```

对于 `double` 类型，你又得写一个：

```cpp
void swapDouble(double& a, double& b) {
    double temp = a;
    a = b;
    b = temp;
}
```

对于 `std::string` 类型，还得再写一个...

你会发现，这些函数的**逻辑完全一样**，唯一的区别就是处理的**数据类型不同**。这导致了大量的代码冗余，并且难以维护。如果 `swap` 的逻辑需要修改，你必须修改所有版本的函数。

**函数模板正是为了解决这个问题而生的。**

---

###  函数模板是什么？

#### 核心思想：“代码的蓝图”

函数模板本身并不是一个函数，它是一个**用于生成函数的蓝图或配方**。你告诉编译器：“嘿，这里有一个通用的 `swap` 函数的实现逻辑，你可以用它来为任何支持赋值和拷贝的类型生成具体的 `swap` 函数。”

#### 基本语法和构成

函数模板的定义以 `template` 关键字开头，后跟一个用尖括号 `<>` 包围的模板参数列表。

```cpp
template <typename T>
void swapGeneric(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}
```

让我们分解这个语法：

- `template <...>`: 这是模板声明的开始。
- `typename T`: 这声明了一个**类型模板参数**。

- `typename` 是一个关键字，告诉编译器 `T` 是一个类型名称。
- `T` 是我们给这个通用类型起的名字（一个占位符），你可以用任何合法的标识符代替，比如 `MyType`、`U` 等，但 `T` 是最常用的惯例。

- `void swapGeneric(T& a, T& b)`: 这是函数的签名。注意，我们现在使用占位符 `T` 来代替具体的类型（如 `int` 或 `double`）。

---

### 工作原理：模板实例化

当你调用一个模板函数时，C++ 编译器会执行一个叫做**模板实例化 (Template Instantiation)** 的过程。

1. **检查调用**：编译器看到你这样调用 `swapGeneric(x, y)`，其中 `x` 和 `y` 是 `int` 类型。
2. **参数推导**：编译器会分析函数参数，推断出模板参数 `T` 应该被替换为 `int`。
3. **生成代码**：编译器会根据这个推导结果，使用模板“蓝图”为你**自动生成一个具体的函数**，这个过程仿佛是执行了一次“查找并替换”。生成的代码在概念上等同于：

```cpp
void swapGeneric_for_int(int& a, int& b) { // 函数名在内部可能是经过修饰的
    int temp = a;
    a = b;
    b = temp;
}
```

4. **编译与链接**：之后，编译器就像处理普通函数一样编译这个新生成的函数。

**关键点：** 这个过程发生在**编译时**。最终的可执行文件中并没有“模板”这个东西，只有一堆由模板实例化而来的具体函数。这保证了函数模板和普通函数一样高效，没有运行时开销。

---

### 详细用法与示例

#### 单个类型参数

这就是我们上面看到的 `swapGeneric` 例子。另一个常见的例子是 `max` 函数。

```cpp
#include <iostream>

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Max of 3 and 7 is: " << max(3, 7) << std::endl;         // T 被推导为 int
    std::cout << "Max of 3.14 and 2.71 is: " << max(3.14, 2.71) << std::endl; // T 被推导为 double
    std::cout << "Max of 'a' and 'z' is: " << max('a', 'z') << std::endl;   // T 被推导为 char
}
```

#### 多个类型参数

模板可以有多个参数，允许不同类型的参数参与运算。

```cpp
template <typename T1, typename T2>
void printValues(const T1& val1, const T2& val2) {
    std::cout << "Value 1: " << val1 << std::endl;
    std::cout << "Value 2: " << val2 << std::endl;
}

int main() {
    printValues(10, "Hello"); // T1 -> int, T2 -> const char*
    printValues(3.14, 'C');   // T1 -> double, T2 -> char
}
```

#### 非类型模板参数

模板参数不仅可以是类型，还可以是**具体的常量值**，如 `int`, `bool`, `size_t` 等。

这在需要基于编译时常量来生成代码时非常有用，比如处理固定大小的数组。

```cpp
template <typename T, int Size>
void printArray(const T (&arr)[Size]) {
    std::cout << "Array of size " << Size << ": [ ";
    for (int i = 0; i < Size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "]" << std::endl;
}

int main() {
    int intArray[] = {1, 2, 3, 4, 5};
    double doubleArray[] = {1.1, 2.2, 3.3};
    
    printArray(intArray);   // T -> int, Size -> 5 (编译器自动推导)
    printArray(doubleArray); // T -> double, Size -> 3 (编译器自动推导)
}
```

---

### 模板参数推导

#### 自动推导

如上例所示，大多数情况下，编译器能根据你传入的实参类型自动推导出模板参数 `T` 的类型。

#### 推导失败与显式指定

有时自动推导会失败或产生非预期的结果。

**情况1：参数类型不匹配**

```cpp
max(5, 6.5); // 编译错误！
```

编译器无法决定 `T` 应该是 `int` 还是 `double`。它不会自动进行类型转换来匹配模板。

**解决方法：**

1. **手动转换参数**：`max(static_cast<double>(5), 6.5);`
2. **显式指定模板参数**：使用尖括号语法告诉编译器 `T` 是什么。

```cpp
max<double>(5, 6.5); // 显式指定 T 为 double。int 类型的 5 会被隐式转换为 double。
```

显式指定后，编译器会严格按照你给定的类型来实例化模板。

---

### 高级主题

#### 函数模板重载

你可以同时拥有一个模板函数和一个同名的普通函数。

```cpp
// 普通函数
void print(int x) {
    std::cout << "Printing an integer: " << x << std::endl;
}

// 模板函数
template <typename T>
void print(T x) {
    std::cout << "Template printing: " << x << std::endl;
}

int main() {
    print(10);       // 调用普通函数，因为它是精确匹配
    print(10.5);     // 调用模板函数，因为没有匹配的普通函数
    print("hello");  // 调用模板函数
    print<>(10);     // 使用空尖括号<>，强制编译器使用模板版本
}
```

**重载解析规则：**  
当有多个选择时，编译器会优先选择**最具体**的版本。

1. **首选普通函数**：如果一个普通函数能精确匹配参数，它会被优先选择。
2. **其次是模板特化**（见下文）。
3. **最后是通用模板**。

#### 函数模板特化 (Specialization)

通用模板可能不适用于所有类型。例如，我们的 `max` 模板比较 C 风格字符串 (`const char*`) 时，会比较指针地址，而不是字符串内容，这通常不是我们想要的。

```cpp
const char* s1 = "world";
const char* s2 = "hello";
std::cout << max(s1, s2); // 可能会输出 "hello"，也可能输出 "world"，取决于地址高低
```

这时，我们可以为 `const char*` 类型提供一个**特化版本**。

```cpp
#include <cstring> // for strcmp

// 通用模板
template <typename T>
T max(T a, T b) {
    std::cout << "(Generic version) ";
    return (a > b) ? a : b;
}

// const char* 的特化版本
// `template <>` 表示这是一个特化
template <>
const char* max<const char*>(const char* a, const char* b) {
    std::cout << "(Specialized version for const char*) ";
    return (strcmp(a, b) > 0) ? a : b;
}

int main() {
    std::cout << max(10, 20) << std::endl;                   // 调用通用模板
    std::cout << max("apple", "orange") << std::endl;       // 调用特化版本
}
```

**输出：**

```cpp
(Generic version) 20
(Specialized version for const char*) orange
```

**语法要点：**

- 以 `template <>` 开头，表示这是一个“空的”模板参数列表，因为所有参数都已被特化。
- 函数名后跟尖括号，里面是特化的具体类型 `max<const char*>`。

---

### 最佳实践与注意事项

#### 模板的定义位置（头文件问题）

**重要：** 函数模板的**声明和定义通常都必须放在头文件 (.h 或 .hpp) 中**。

**原因：** 编译器在实例化模板时，需要看到模板的完整定义（“蓝图”），而不仅仅是声明。如果将定义放在 `.cpp` 文件中，其他 `.cpp` 文件在包含头文件时只能看到声明，编译器没有足够的信息来生成代码，最终会导致链接错误（undefined reference）。

#### `typename` vs `class`

在模板参数列表中，`typename` 和 `class` 关键字是完全等价的。

```cpp
template <typename T> // 常用
template <class T>    // 也可以，在早期 C++ 中是唯一选择
```

现代 C++ 程序员更倾向于使用 `typename`，因为它能更清晰地表达“这是一个类型名称”的意图，尤其在嵌套依赖类型名（更高级的话题）中，`typename` 是必需的。但在模板参数声明中，两者可互换。

---

### 总结

|   |   |   |
|---|---|---|
|概念|描述|示例|
|**核心目的**|编写与类型无关的代码，实现泛型编程，减少代码冗余。|`swap(a, b)` 可用于 `int`, `double`, `string` 等。|
|**工作原理**|**编译时**的**模板实例化**，根据调用自动生成具体函数。|`max(3, 7)` 生成 `int max(int, int)`。|
|**语法**|`template <typename T> return_type func_name(T arg)`|`template <typename T> T max(T a, T b)`|
|**参数类型**|可以是**类型参数** (`typename T`) 或**非类型参数** (`int Size`)。|`template <typename T, int Size>`|
|**重载**|普通函数优先于模板函数。|`print(10)` 调用 `void print(int)` 而非 `template<T> void print(T)`|
|**特化**|为特定类型提供专门的实现。|为 `const char*` 提供一个使用 `strcmp` 的 `max` 版本。|
|**放置位置**|**声明和定义都应放在头文件中。**|`my_templates.h`|

函数模板是 C++ 标准库（STL）的基石，像 `std::vector`, `std::sort`, `std::max` 等无数功能都是基于模板实现的。掌握它，是迈向高效、现代 C++ 编程的关键一步。