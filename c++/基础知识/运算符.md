好的，我们来详细讲解 C++ 中的运算符 (Operators)。运算符是 C++ 语言中用于执行计算、比较、逻辑操作等功能的特殊符号。理解运算符是掌握 C++ 编程的基础。

我们将从以下几个方面进行讲解：

1. **运算符的分类**
2. **各类运算符详解（附代码示例）**
3. **运算符的优先级和结合性**
4. **运算符重载**
5. **总结与最佳实践**

---

### 1. 运算符的分类

我们可以从两个维度对运算符进行分类：

**A. 按操作数数量分类：**

- **一元运算符 (Unary Operator)**：只对一个操作数进行操作。例如 `!a` (逻辑非), `-b` (取负), `++c` (自增)。
- **二元运算符 (Binary Operator)**：对两个操作数进行操作。这是最常见的类型，例如 `a + b`, `c > d`。
- **三元运算符 (Ternary Operator)**：对三个操作数进行操作。C++ 中只有一个三元运算符，即条件运算符 `? :`。

**B. 按功能分类（我们将主要按此分类进行讲解）：**

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 成员/指针运算符
- 其他运算符 (如 `sizeof`, 条件运算符等)

---

### 2. 各类运算符详解

#### a) 算术运算符 (Arithmetic Operators)

用于执行基本的数学运算。

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|描述|
|`+`|加法|`a + b`|计算两者之和|
|`-`|减法|`a - b`|计算两者之差|
|`*`|乘法|`a * b`|计算两者之积|
|`/`|除法|`a / b`|计算两者之商。**注意：整数除法会舍弃小数部分**|
|`%`|取模 (取余)|`a % b`|计算 `a` 除以 `b` 的余数。通常只用于整数。|
|`++`|自增|`a++` 或 `++a`|将操作数的值加 1|
|`--`|自减|`a--` 或 `--a`|将操作数的值减 1|

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10, b = 4;
    std::cout << "a + b = " << (a + b) << std::endl; // 14
    std::cout << "a - b = " << (a - b) << std::endl; // 6
    std::cout << "a * b = " << (a * b) << std::endl; // 40
    std::cout << "a / b = " << (a / b) << std::endl; // 2 (整数除法，2.5 被截断)
    std::cout << "a % b = " << (a % b) << std::endl; // 2 (10 = 4*2 + 2)

    // ++ 和 -- 的区别 (前缀与后缀)
    int c = 5;
    // 后缀 a++: 先使用 c 的值 (5)，再将 c 加 1
    std::cout << "c++ is " << c++ << std::endl; // 输出 5
    std::cout << "Now c is " << c << std::endl;   // 输出 6

    int d = 5;
    // 前缀 ++d: 先将 d 加 1，再使用 d 的新值 (6)
    std::cout << "++d is " << ++d << std::endl; // 输出 6
    std::cout << "Now d is " << d << std::endl;   // 输出 6
}
```

#### b) 关系运算符 (Relational Operators)

用于比较两个值，结果为布尔值 `true` 或 `false`。

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|描述|
|`==`|等于|`a == b`|如果 `a` 和 `b` 相等，返回 `true`|
|`!=`|不等于|`a != b`|如果 `a` 和 `b` 不相等，返回 `true`|
|`>`|大于|`a > b`||
|`<`|小于|`a < b`||
|`>=`|大于等于|`a >= b`||
|`<=`|小于等于|`a <= b`||

**代码示例：**

```cpp
#include <iostream>

int main() {
    int x = 5, y = 5, z = 10;
    std::cout << std::boolalpha; // 让 cout 输出 "true"/"false" 而不是 1/0
    std::cout << "x == y: " << (x == y) << std::endl; // true
    std::cout << "x != z: " << (x != z) << std::endl; // true
    std::cout << "x < z: " << (x < z) << std::endl;   // true
}
```

**常见错误：** 把 `==` (比较) 写成 `=` (赋值)。`if (x = 5)` 是合法的，但它的意思是把 `5` 赋给 `x`，然后判断 `5` 的布尔值（非零为 `true`），这几乎总是逻辑错误。

#### c) 逻辑运算符 (Logical Operators)

用于组合多个布尔表达式。

|      |           |                  |                                 |
| ---- | --------- | ---------------- | ------------------------------- |
| 运算符  | 名称        | 示例               | 描述                              |
| `&&` | 逻辑与 (AND) | `expr1 && expr2` | 只有当两个表达式都为 `true` 时，结果才为 `true` |
| `｜｜` | 逻辑或 (OR)  | `expr1 ｜｜ expr2` | 只要任一表达式为 `true`，结果就为 `true`     |
| `!`  | 逻辑非 (NOT) | `!expr`          | 如果表达式为 `true`，结果为 `false`，反之亦然  |

**短路求值 (Short-circuit Evaluation):**

- 对于 `&&`，如果第一个表达式为 `false`，则不再计算第二个表达式。
- 对于 `||`，如果第一个表达式为 `true`，则不再计算第二个表达式。  
    这在代码中非常重要，例如 `if (ptr != nullptr && ptr->value > 10)` 可以安全地防止对空指针解引用。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int age = 25;
    bool has_license = true;
    std::cout << std::boolalpha;

    if (age >= 18 && has_license) {
        std::cout << "Can drive." << std::endl; // Can drive.
    }

    bool is_weekend = true;
    bool is_holiday = false;
    if (is_weekend || is_holiday) {
        std::cout << "Can rest." << std::endl; // Can rest.
    }

    if (!is_holiday) {
        std::cout << "Need to work." << std::endl; // Need to work.
    }
}
```

#### d) 位运算符 (Bitwise Operators)

直接对整数的二进制位进行操作。常用于低级编程、设备驱动和性能优化。

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|描述|
|`&`|按位与 (AND)|`a & b`|对应位都为 1 时，结果位才为 1|
|`｜`|按位或 (OR)|`a ｜ b`|对应位只要有一个为 1，结果位为 1|
|`^`|按位异或 (XOR)|`a ^ b`|对应位不同时，结果位为 1|
|`~`|按位取反 (NOT)|`~a`|翻转所有位 (0变1，1变0)|
|`<<`|左移|`a << n`|将 `a` 的所有位向左移动 `n` 位，右边补 0。相当于 `a * 2^n`|
|`>>`|右移|`a >> n`|将 `a` 的所有位向右移动 `n` 位。对于无符号数，左边补 0；对于有符号数，行为可能取决于实现（通常是补符号位）。相当于 `a / 2^n`|

**代码示例：**

```cpp
#include <iostream>
#include <bitset>

int main() {
    unsigned char a = 5;  // 00000101
    unsigned char b = 12; // 00001100

    std::cout << "a & b = " << (a & b) << " (" << std::bitset<8>(a & b) << ")" << std::endl; // 4 (00000100)
    std::cout << "a | b = " << (a | b) << " (" << std::bitset<8>(a | b) << ")" << std::endl; // 13 (00001101)
    std::cout << "a ^ b = " << (a ^ b) << " (" << std::bitset<8>(a ^ b) << ")" << std::endl; // 9 (00001001)
    std::cout << "~a = " << int(~a) << " (" << std::bitset<8>(~a) << ")" << std::endl; // 250 (11111010)
    std::cout << "a << 2 = " << (a << 2) << " (" << std::bitset<8>(a << 2) << ")" << std::endl; // 20 (00010100)
    std::cout << "b >> 1 = " << (b >> 1) << " (" << std::bitset<8>(b >> 1) << ")" << std::endl; // 6 (00000110)
}
```

#### e) 赋值运算符 (Assignment Operators)

用于给变量赋值。

|       |           |              |
| ----- | --------- | ------------ |
| 运算符   | 示例        | 等价于          |
| `=`   | `a = b`   | `a = b`      |
| `+=`  | `a += b`  | `a = a + b`  |
| `-=`  | `a -= b`  | `a = a - b`  |
| `*=`  | `a *= b`  | `a = a * b`  |
| `/=`  | `a /= b`  | `a = a / b`  |
| `%=`  | `a %= b`  | `a = a % b`  |
| `&=`  | `a &= b`  | `a = a & b`  |
| `｜=`  | `a ｜= b`  | `a = a ｜ b`  |
| `^=`  | `a ^= b`  | `a = a ^ b`  |
| `<<=` | `a <<= b` | `a = a << b` |
| `>>=` | `a >>= b` | `a = a >> b` |

**代码示例：**

```cpp
int x = 10;
x += 5; // x 现在是 15
x *= 2; // x 现在是 30
```

复合赋值运算符 `op=` 不仅是简写，有时也更高效。

#### f) 成员/指针运算符 (Member/Pointer Operators)

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|描述|
|`.`|成员访问|`obj.member`|访问对象或结构体的成员|
|`->`|指针成员访问|`ptr->member`|通过指向对象的指针访问其成员。等价于 `(*ptr).member`|
|`&`|取地址|`&var`|获取变量的内存地址，返回一个指针|
|`*`|解引用|`*ptr`|获取指针所指向地址处的值|

#### g) 其他运算符

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|描述|
|`sizeof`|尺寸|`sizeof(type)` 或 `sizeof(expr)`|在编译时计算类型或表达式结果所占的字节数|
|`?:`|条件 (三元)|`cond ? expr1 : expr2`|如果 `cond` 为 `true`，表达式的值为 `expr1`；否则为 `expr2`|
|`,`|逗号|`expr1, expr2`|先计算 `expr1`，然后丢弃其结果，再计算 `expr2`，整个表达式的值是 `expr2` 的值。**不常用，主要用在** `for` **循环中。**|
|`(type)`|类型转换 (C-style)|`(int)3.14`|将一个表达式强制转换为另一种类型。C++ 推荐使用 `static_cast`, `dynamic_cast` 等|
|`::`|范围解析|`std::cout`|用于指定命名空间或类的范围|
|`<=>`|三路比较 (C++20)|`a <=> b`|"宇宙飞船运算符"，同时进行 `a<b`, `a==b`, `a>b` 的比较，返回一个对象表示小于、等于或大于零。|

---

### 3. 运算符的优先级和结合性

当一个表达式中有多个运算符时，由**优先级 (Precedence)** 和 **结合性 (Associativity)** 决定计算顺序。

- **优先级**：哪个运算符先执行。例如，`*` 和 `/` 的优先级高于 `+` 和 `-`。所以 `a + b * c` 等价于 `a + (b * c)`。
- **结合性**：当多个优先级相同的运算符在一起时，决定计算方向。

- **左结合 (Left-to-Right)**：大多数运算符是左结合。例如 `a - b - c` 等价于 `(a - b) - c`。
- **右结合 (Right-to-Left)**：赋值运算符、一元运算符和三元运算符是右结合。例如 `a = b = c` 等价于 `a = (b = c)`。

**简化的优先级表 (从高到低):**

1. `()` `[]` `.` `->` `::`
2. `++` `--` `!` `~` `*` `&` `sizeof` (一元运算符)
3. `*` `/` `%` (乘除模)
4. `+` `-` (加减)
5. `<<` `>>` (位移)
6. `<` `<=` `>` `>=` (关系)
7. `==` `!=` (相等)
8. `&` (按位与)
9. `^` (按位异或)
10. `|` (按位或)
11. `&&` (逻辑与)
12. `||` (逻辑或)
13. `?:` (条件)
14. `=` `+=` `-=` 等赋值运算符 (右结合)
15. `,` (逗号)

**最佳实践：** 不要去死记硬背完整的优先级表！如果一个表达式的求值顺序不明显，**请使用括号** `()` **来明确指定顺序**。这能极大地提高代码的可读性并避免错误。

---

### 4. 运算符重载 (Operator Overloading)

C++ 允许我们为自定义的类型（类或结构体）重新定义大多数运算符的行为。这使得我们可以写出更直观、更像数学表达的代码。

例如，你可以定义一个 `Vector2D` 类，并重载 `+` 运算符来实现两个向量的相加。

```cpp
#include <iostream>

struct Vector2D {
    double x, y;

    // 重载 + 运算符
    Vector2D operator+(const Vector2D& other) const {
        return {x + other.x, y + other.y};
    }
};

// 重载 << 运算符，使其可以打印 Vector2D 对象
std::ostream& operator<<(std::ostream& os, const Vector2D& vec) {
    os << "(" << vec.x << ", " << vec.y << ")";
    return os;
}

int main() {
    Vector2D v1 = {1.0, 2.0};
    Vector2D v2 = {3.0, 4.0};
    Vector2D sum = v1 + v2; // 直观地调用了重载的 operator+

    std::cout << "v1: " << v1 << std::endl;
    std::cout << "v2: " << v2 << std::endl;
    std::cout << "Sum: " << sum << std::endl; // 输出: Sum: (4, 6)
}
```

---

### 5. 总结与最佳实践

- **明确意图**：使用括号 `()` 避免任何关于优先级和结合性的混淆。
- **注意副作用**：`++` 和 `--` 会修改变量的值，在同一个表达式中对一个变量多次使用它们可能会导致未定义行为（例如 `i = i++`）。
- **区分运算符**：清楚地区分 `&` (按位与) 和 `&&` (逻辑与)，`|` 和 `||`，`=` 和 `==`。
- **短路求值**：善用 `&&` 和 `||` 的短路特性来编写更安全、高效的代码。
- **运算符重载**：谨慎使用，只在行为符合直觉时重载运算符（例如用 `+` 做加法，而不是减法），以保持代码的可读性。
