
本文将分为以下几个部分：

1. **基础概念**：什么是运算符、操作数和表达式。
2. **运算符分类详解**：按功能对 C++ 所有主要运算符进行分类讲解。
3. **运算符的关键属性**：优先级（Precedence）和结合性（Associativity）。
4. **表达式**：表达式的求值、类型和值类别（左值/右值）。
5. **综合示例与最佳实践**。

---

### 1. 基础概念

- **运算符 (Operator)**  
    是一个符号，它告诉编译器执行特定的数学或逻辑操作。例如，`+` 是一个加法运算符。
- **操作数 (Operand)**是运算符操作的数据。在表达式 `5 + 3` 中，`5` 和 `3` 就是操作数。
- **表达式 (Expression)**是由运算符、操作数、字面量（如 `5`、`'a'`）和变量组成的序列，它可以被求值（calculate）从而产生一个结果。这个结果具有**值（value）****和****类型（type）**。例如 `x = a + b * 2;` 整行是一个语句，而 `a + b * 2` 就是一个表达式。

---

### 2. 运算符分类详解

我们可以根据运算符需要几个操作数来分为：

- **一元运算符 (Unary)**：只有一个操作数 (例如: `-a`, `++i`)
- **二元运算符 (Binary)**：有两个操作数 (例如: `a + b`)
- **三元运算符 (Ternary)**：有三个操作数 (C++ 只有一个: `? :`)

更常见的分类方式是按其功能划分：

#### A. 算术运算符 (Arithmetic Operators)

用于执行基本的数学运算。

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|说明|
|`+`|加法|`a + b`||
|`-`|减法|`a - b`||
|`*`|乘法|`a * b`||
|`/`|除法|`a / b`|**注意：** 整数除法会舍弃小数部分，例如 `7 / 2` 的结果是 `3`。|
|`%`|取模|`a % b`|计算整数除法的余数，例如 `7 % 2` 的结果是 `1`。操作数必须是整数类型。|

```
int a = 10, b = 3;
cout << a / b; // 输出 3
cout << a % b; // 输出 1

double x = 10.0, y = 3.0;
cout << x / y; // 输出 3.33333
```

#### B. 关系运算符 (Relational Operators)

用于比较两个值，其结果是一个布尔值 (`true` 或 `false`)。

|   |   |   |
|---|---|---|
|运算符|名称|示例|
|`==`|等于|`a == b`|
|`!=`|不等于|`a != b`|
|`>`|大于|`a > b`|
|`<`|小于|`a < b`|
|`>=`|大于等于|`a >= b`|
|`<=`|小于等于|`a <= b`|

```
int a = 5, b = 5, c = 10;
cout << (a == b); // 输出 1 (true)
cout << (a != c); // 输出 1 (true)
cout << (a > c);  // 输出 0 (false)
```

#### C. 逻辑运算符 (Logical Operators)

用于组合多个关系表达式，其结果也是布尔值 (`true` 或 `false`)。

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|说明|
|`&&`|逻辑与 (AND)|`expr1 && expr2`|两个表达式都为 `true` 时，结果才为 `true`。|
|`||`|逻辑或 (OR)|
|`!`|逻辑非 (NOT)|`!expr`|如果表达式为 `true`，结果为 `false`，反之亦然。|

**短路求值 (Short-circuit Evaluation)** 是逻辑运算符的一个重要特性：

- 对于 `&&`，如果左边的表达式为 `false`，则右边的表达式**不会被执行**，因为整个结果已确定为 `false`。
- 对于 `||`，如果左边的表达式为 `true`，则右边的表达式**不会被执行**，因为整个结果已确定为 `true`。

```
int age = 25;
int score = 95;
if (age > 18 && score > 90) { /* ... */ } // 两个条件都满足

int x = 0;
bool result = (x != 0 && 10 / x > 1); // 安全！因为 x!=0 为 false，后面的 10/x 不会执行，避免了除零错误。
```

#### D. 位运算符 (Bitwise Operators)

直接对整数的二进制位进行操作。

|   |   |   |
|---|---|---|
|运算符|名称|示例|
|`&`|按位与|`a & b`|
|`|`|按位或|
|`^`|按位异或|`a ^ b`|
|`~`|按位取反|`~a`|
|`<<`|左移|`a << n`|
|`>>`|右移|`a >> n`|

```
unsigned char a = 5;  // 二进制: 00000101
unsigned char b = 9;  // 二进制: 00001001

cout << (a & b); // 结果 1 (00000001)
cout << (a | b); // 结果 13 (00001101)
cout << (a << 1); // 结果 10 (00001010)，相当于 a * 2
cout << (b >> 1); // 结果 4 (00000100)，相当于 b / 2
```

#### E. 赋值运算符 (Assignment Operators)

用于给变量赋值。

|   |   |   |
|---|---|---|
|运算符|示例|等价于|
|`=`|`a = b`||
|`+=`|`a += b`|`a = a + b`|
|`-=`|`a -= b`|`a = a - b`|
|`*=`|`a *= b`|`a = a * b`|
|`/=`|`a /= b`|`a = a / b`|
|`%=`|`a %= b`|`a = a % b`|
|`&=`, `|=`, `^=`|`a &= b`|
|`<<=`, `>>=`|`a <<= n`|`a = a << n`|

赋值表达式本身也有值，其值就是被赋的值。这允许链式赋值：  
`int x, y; x = y = 10;` 等价于 `y = 10; x = y;`

#### F. 递增/递减运算符 (Increment/Decrement Operators)

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|说明|
|`++`|递增|`++i` (前置) `i++` (后置)|将变量的值加 1|
|`--`|递减|`--i` (前置) `i--` (后置)|将变量的值减 1|

**前置 (Pre-increment) vs 后置 (Post-increment)** 是一个关键区别：

- **前置** `++i`：先将 `i` 的值加 1，然后返回**加 1 后**的 `i` 的值。
- **后置** `i++`：先返回 `i` 的**原始值**，然后再将 `i` 的值加 1。

```
int a = 5;
int b = ++a; // a 先变成 6, 然后 b 被赋值为 6。此时 a=6, b=6
cout << "a=" << a << ", b=" << b << endl;

int c = 5;
int d = c++; // d 先被赋值为 5, 然后 c 再变成 6。此时 c=6, d=5
cout << "c=" << c << ", d=" << d << endl;
```

**性能提示**：对于自定义类型（如迭代器），前置版本通常比后置版本效率更高，因为后置版本需要创建一个临时对象来保存原始值。因此，在不影响逻辑的情况下，优先使用前置版本 (`++it` 而不是 `it++`)。

#### G. 其他运算符

|   |   |   |   |
|---|---|---|---|
|运算符|名称|示例|说明|
|`sizeof`|尺寸运算符|`sizeof(int)`|在编译时计算类型或变量所占的字节数。|
|`?:`|条件运算符(三元)|`cond ? expr1 : expr2`|如果 `cond` 为 `true`，则表达式的值为 `expr1`；否则为 `expr2`。|
|`,`|逗号运算符|`a=1, b=2, c=3`|从左到右依次计算每个表达式，整个逗号表达式的值是**最右边**表达式的值。|
|`.` `->`|成员访问|`obj.member` `ptr->member`|用于访问类或结构的成员。|
|`&` `*`|指针相关|`&var` (取地址) `*ptr` (解引用)|`&` 获取变量的内存地址，`*` 获取指针指向地址的值。|
|`static_cast`等|类型转换|`static_cast<int>(3.14)`|C++ 风格的类型转换。|

---

### 3. 运算符的关键属性

当一个表达式中包含多个运算符时，由谁先计算？这就需要**优先级**和**结合性**来决定。

#### A. 优先级 (Precedence)

优先级决定了不同运算符的计算顺序。优先级高的运算符先于优先级低的运算符被计算。例如，`*` 和 `/` 的优先级高于 `+` 和 `-`。

`int result = 5 + 3 * 2;`  
这里，`3 * 2` 会先被计算（结果是 `6`），然后才执行 `5 + 6`，所以 `result` 是 `11`，而不是 `16`。

#### B. 结合性 (Associativity)

当多个具有相同优先级的运算符出现在一个表达式中时，结合性决定了它们的计算顺序。

- **左结合性 (Left-to-right)**：从左向右计算。大多数运算符都是左结合的。  
    `int result = 10 - 5 + 3;`  
    `+` 和 `-` 优先级相同，且是左结合性，所以等价于 `(10 - 5) + 3`，结果是 `8`。
- **右结合性 (Right-to-right)**：从右向左计算。赋值运算符、一元运算符和三元条件运算符是右结合的。  
    `int a, b, c; a = b = c = 10;`赋值运算符是右结合性，所以等价于 `a = (b = (c = 10))`。首先 `c`被赋值为`10`，然后`b`被赋值为`c=10`这个表达式的结果（也就是`10`），最后`a`被赋值为`b=...`表达式的结果（也是`10`）。

#### C++ 运算符优先级和结合性简表 (从高到低)

|         |                                                                     |                    |     |
| ------- | ------------------------------------------------------------------- | ------------------ | --- |
| 优先级     | 运算符                                                                 | 描述                 | 结合性 |
| 1 (最高)  | `::` `()` `[]` `.` `->` `++` `--` (后置)                              | 作用域、函数调用、数组下标、成员访问 | 左到右 |
| 2       | `++` `--` (前置) `!` `~` `-` `+` (一元) `&` `*` `sizeof` `new` `delete` | 一元运算符              | 右到左 |
| 3       | `.*` `->*`                                                          | 成员指针访问             | 左到右 |
| 4       | `*` `/` `%`                                                         | 乘法、除法、取模           | 左到右 |
| 5       | `+` `-`                                                             | 加法、减法              | 左到右 |
| 6       | `<<` `>>`                                                           | 位移                 | 左到右 |
| 7       | `<` `<=` `>` `>=`                                                   | 关系                 | 左到右 |
| 8       | `==` `!=`                                                           | 等于、不等于             | 左到右 |
| 9       | `&`                                                                 | 按位与                | 左到右 |
| 10      | `^`                                                                 | 按位异或               | 左到右 |
| 11      | `                                                                   | `                  | 按位或 |
| 12      | `&&`                                                                | 逻辑与                | 左到右 |
| 13      | `                                                                   |                    | `   |
| 14      | `?:`                                                                | 条件(三元)             | 右到左 |
| 15      | `=` `+=` `-=` `*=` `/=` `%=` ...                                    | 赋值                 | 右到左 |
| 16 (最低) | `,`                                                                 | 逗号                 | 左到右 |

**最佳实践**：不要去死记硬背这个复杂的表格！当你不确定优先级时，**使用括号** `()` 来明确指定计算顺序。这不仅能保证正确性，还能大大提高代码的可读性。

例如，写 `(a + b) * c` 而不是依赖 `*` 的高优先级。

---

### 4. 表达式 (Expressions)

#### A. 表达式的求值顺序和副作用

- **副作用 (Side Effect)**：指表达式在求值过程中，除了返回一个值之外，还修改了某些状态（如修改变量的值、进行I/O操作）。例如，`i++` 的副作用就是使 `i` 的值增加。
- **求值顺序 (Order of Evaluation)**：C++ 标准**并未规定**大多数二元运算符（如 `+`, `*`）的操作数的求值顺序。  
    `cout << f1() + f2();`我们无法确定是 `f1()` 先被调用还是 `f2()` 先被调用。

这会导致一个非常危险的问题：**未定义行为 (Undefined Behavior, UB)**。  
如果你在一个表达式中多次修改同一个变量，且没有明确的顺序规定，就会产生 UB。

**错误的例子 (UB!)**：  
`int i = 5;`  
`i = ++i; // UB! i被读取和修改，顺序不确定`  
`cout << i << i++; // UB! 对 i 的使用和修改顺序不确定`

**有顺序保证的运算符**：  
逻辑与(`&&`)、逻辑或(`||`)、逗号(`,`)和条件(`?:`)运算符，它们的操作数求值顺序是确定的（从左到右）。

#### B. 表达式的值类别 (Value Categories)

在现代 C++ 中，表达式的值可以分为几类，最重要的是**左值 (lvalue)** 和**右值 (rvalue)**。

- **左值 (lvalue)**：指代一个内存位置，可以被取地址（用 `&`），并且通常可以被赋值。你可以把它想象成一个有名字、有固定地址的“容器”。

- 变量名 (`int x; x` 是左值)
- 解引用的指针 (`*p`)
- 数组元素 (`arr[0]`)

- **右值 (rvalue)**：通常指一个临时的、即将销毁的值，不能被取地址。你可以把它想象成一个“即用即弃”的临时数据。

- 字面量 (`10`, `true`)
- 算术表达式的结果 (`a + b`)
- 函数返回的非引用临时值

**简单的判断方法**：能对它取地址 (`&`) 的，基本上就是左值。

```
int x = 10;
int* p = &x;     // 正确, x 是左值
int* q = &(x+1); // 错误! x+1 的结果是一个临时值(右值)，没有固定地址
```

这个概念对于理解 C++11 引入的**移动语义 (Move Semantics)** 和**右值引用 (Rvalue Reference,** `&&`**)** 至关重要。

---

### 5. 综合示例与最佳实践

#### 综合示例

分析下面这个复杂的表达式：

```
int a = 5, b = 10, c = 2;
bool result = a * b / c > 8 && b - a == 5;
```

1. **优先级分析**: `*` `/` > `+` `-` > `>` `==` > `&&`
2. **求值步骤**:  
    a. `a * b` (5 * 10 = 50)  
    b. `(结果a) / c` (50 / 2 = 25)  
    c. `(结果b) > 8` (25 > 8 = `true`)  
    d. `b - a` (10 - 5 = 5)  
    e. `(结果d) == 5` (5 == 5 = `true`)  
    f. `(结果c) && (结果e)` (`true && true` = `true`)
3. `result` 的最终值为 `true`。

#### 最佳实践总结

1. **括号是你的好朋友**：在不确定优先级或为了代码清晰时，毫不犹豫地使用括号。
2. **避免未定义行为**：不要在单个表达式中对同一个变量进行多次无序的修改。
3. **理解短路求值**：利用 `&&` 和 `||` 的短路特性来编写更安全、更高效的代码。
4. **优先使用前置递增/递减**：对于非内置类型，`++it` 通常优于 `it++`。
5. **区分位运算符和逻辑运算符**：`&` vs `&&`，`|` vs `||` 是初学者常犯的错误，它们的功能完全不同。
6. **了解整数除法**：记住 `int / int` 的结果仍然是 `int`，小数部分被截断。

希望这份详细的讲解能帮助你彻底掌握 C++ 的运算符与表达式！