C++ 中的数组是存储相同类型元素的连续内存块。数组分为一维数组和多维数组，是程序设计中最基础的数据结构之一。

## 一维数组

### 一维数组的声明和初始化

```cpp
#include <iostream>

int main() {
    // 1. 声明数组（未初始化，包含垃圾值）
    int arr1[5];  // 声明包含5个int元素的数组
    
    // 2. 声明并初始化
    int arr2[5] = {1, 2, 3, 4, 5};  // 完全初始化
    int arr3[5] = {1, 2, 3};        // 部分初始化，剩余元素为0
    int arr4[5] = {0};              // 所有元素初始化为0
    int arr5[5] = {};               // C++11：所有元素初始化为0
    
    // 3. 自动推导数组大小
    int arr6[] = {1, 2, 3, 4, 5, 6};  // 编译器推导大小为6
    
    // 4. C++11 统一初始化
    int arr7{1, 2, 3, 4, 5};
    
    // 5. 字符数组
    char str1[10] = "Hello";     // 字符串字面量初始化
    char str2[] = "World";       // 自动推导大小
    char str3[6] = {'H', 'e', 'l', 'l', 'o', '\0'};  // 字符初始化
    
    // 输出数组内容
    std::cout << "arr2: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr2[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 数组的访问和操作

```cpp
#include <iostream>
#include <algorithm>  // for std::sort, std::find

void printArray(int arr[], int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int numbers[10] = {5, 2, 8, 1, 9, 3, 7, 4, 6, 0};
    int size = sizeof(numbers) / sizeof(numbers[0]);  // 计算数组大小
    
    std::cout << "Original array: ";
    printArray(numbers, size);
    
    // 1. 数组元素访问
    std::cout << "First element: " << numbers[0] << std::endl;
    std::cout << "Last element: " << numbers[size-1] << std::endl;
    
    // 2. 修改数组元素
    numbers[0] = 100;
    numbers[size-1] = 200;
    
    // 3. 遍历数组
    std::cout << "Modified array: ";
    for (int i = 0; i < size; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << std::endl;
    
    // 4. 使用范围for循环（C++11）
    std::cout << "Using range-based for: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 5. 查找元素
    int target = 8;
    int* found = std::find(numbers, numbers + size, target);
    if (found != numbers + size) {
        std::cout << "Found " << target << " at index " 
                  << (found - numbers) << std::endl;
    }
    
    // 6. 排序数组
    std::sort(numbers, numbers + size);
    std::cout << "Sorted array: ";
    printArray(numbers, size);
    
    return 0;
}
```

### 数组作为函数参数

```cpp
#include <iostream>

// 方式1：数组参数（实际上是指针）
void processArray1(int arr[], int size) {
    std::cout << "In function, sizeof(arr) = " << sizeof(arr) << std::endl;  // 指针大小
    for (int i = 0; i < size; ++i) {
        arr[i] *= 2;  // 修改原数组
    }
}

// 方式2：指针参数（等价于方式1）
void processArray2(int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        arr[i] += 10;
    }
}

// 方式3：引用参数（需要指定大小）
void processArray3(int (&arr)[5]) {
    for (int i = 0; i < 5; ++i) {
        arr[i] -= 5;
    }
}

// 方式4：模板参数（C++11）
template<size_t N>
void processArray4(int (&arr)[N]) {
    for (size_t i = 0; i < N; ++i) {
        arr[i] /= 2;
    }
}

// 返回数组（实际返回指针）
int* createArray(int size) {
    int* arr = new int[size];  // 动态分配
    for (int i = 0; i < size; ++i) {
        arr[i] = i + 1;
    }
    return arr;
}

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    
    std::cout << "Original: ";
    for (int num : numbers) std::cout << num << " ";
    std::cout << std::endl;
    
    processArray1(numbers, 5);
    std::cout << "After processArray1: ";
    for (int num : numbers) std::cout << num << " ";
    std::cout << std::endl;
    
    processArray2(numbers, 5);
    std::cout << "After processArray2: ";
    for (int num : numbers) std::cout << num << " ";
    std::cout << std::endl;
    
    processArray3(numbers);
    std::cout << "After processArray3: ";
    for (int num : numbers) std::cout << num << " ";
    std::cout << std::endl;
    
    processArray4(numbers);
    std::cout << "After processArray4: ";
    for (int num : numbers) std::cout << num << " ";
    std::cout << std::endl;
    
    // 动态数组
    int* dynamicArr = createArray(3);
    std::cout << "Dynamic array: ";
    for (int i = 0; i < 3; ++i) {
        std::cout << dynamicArr[i] << " ";
    }
    std::cout << std::endl;
    delete[] dynamicArr;  // 释放内存
    
    return 0;
}
```

## 多维数组

### 二维数组

```cpp
#include <iostream>

int main() {
    // 1. 二维数组的声明和初始化
    int matrix1[3][4];  // 3行4列的矩阵（未初始化）
    
    // 2. 完全初始化
    int matrix2[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    // 3. 部分初始化
    int matrix3[3][4] = {
        {1, 2},        // 第一行：1, 2, 0, 0
        {5, 6, 7},     // 第二行：5, 6, 7, 0
        {}             // 第三行：0, 0, 0, 0
    };
    
    // 4. 一维方式初始化
    int matrix4[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    
    // 5. 全零初始化
    int matrix5[3][4] = {};
    
    // 6. 自动推导第一维大小
    int matrix6[][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8}
    };  // 自动推导为2行4列
    
    // 输出二维数组
    std::cout << "matrix2:" << std::endl;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j) {
            std::cout << matrix2[i][j] << "\t";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### 二维数组的操作

```cpp
#include <iostream>
#include <iomanip>

// 打印二维数组
void printMatrix(int matrix[][4], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 4; ++j) {
            std::cout << std::setw(4) << matrix[i][j];
        }
        std::cout << std::endl;
    }
}

// 矩阵转置
void transpose(int source[][4], int dest[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            dest[j][i] = source[i][j];
        }
    }
}

// 查找元素
bool findElement(int matrix[][4], int rows, int cols, int target, int& row, int& col) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (matrix[i][j] == target) {
                row = i;
                col = j;
                return true;
            }
        }
    }
    return false;
}

int main() {
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    std::cout << "Original matrix:" << std::endl;
    printMatrix(matrix, 3);
    
    // 访问和修改元素
    std::cout << "\nElement at [1][2]: " << matrix[1][2] << std::endl;
    matrix[1][2] = 100;
    std::cout << "After modification:" << std::endl;
    printMatrix(matrix, 3);
    
    // 计算行和列的总和
    std::cout << "\nRow sums: ";
    for (int i = 0; i < 3; ++i) {
        int rowSum = 0;
        for (int j = 0; j < 4; ++j) {
            rowSum += matrix[i][j];
        }
        std::cout << rowSum << " ";
    }
    std::cout << std::endl;
    
    std::cout << "Column sums: ";
    for (int j = 0; j < 4; ++j) {
        int colSum = 0;
        for (int i = 0; i < 3; ++i) {
            colSum += matrix[i][j];
        }
        std::cout << colSum << " ";
    }
    std::cout << std::endl;
    
    // 查找元素
    int row, col;
    if (findElement(matrix, 3, 4, 100, row, col)) {
        std::cout << "\nFound 100 at position [" << row << "][" << col << "]" << std::endl;
    }
    
    // 矩阵转置
    int transposed[4][3];
    transpose(matrix, transposed, 3, 4);
    std::cout << "\nTransposed matrix:" << std::endl;
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 3; ++j) {
            std::cout << std::setw(4) << transposed[i][j];
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### 三维数组和更高维数组

```cpp
#include <iostream>

int main() {
    // 三维数组：可以想象为多个二维数组的集合
    int cube[2][3][4] = {
        {  // 第一个2D数组
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        },
        {  // 第二个2D数组
            {13, 14, 15, 16},
            {17, 18, 19, 20},
            {21, 22, 23, 24}
        }
    };
    
    // 访问三维数组元素
    std::cout << "Three-dimensional array:" << std::endl;
    for (int i = 0; i < 2; ++i) {
        std::cout << "Layer " << i << ":" << std::endl;
        for (int j = 0; j < 3; ++j) {
            for (int k = 0; k < 4; ++k) {
                std::cout << cube[i][j][k] << "\t";
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
    
    // 四维数组示例
    int hyperCube[2][2][2][2];
    
    // 初始化四维数组
    int value = 1;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                for (int l = 0; l < 2; ++l) {
                    hyperCube[i][j][k][l] = value++;
                }
            }
        }
    }
    
    // 输出四维数组的一部分
    std::cout << "Four-dimensional array [0][0]:" << std::endl;
    for (int k = 0; k < 2; ++k) {
        for (int l = 0; l < 2; ++l) {
            std::cout << hyperCube[0][0][k][l] << " ";
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

## 动态数组

动态数组是在程序运行时根据需要分配内存的数组，其大小可以在运行时确定。C++提供了多种创建和管理动态数组的方法。

### 一维动态数组

#### 方法一：使用 new/delete（传统方法）

```cpp
#include <iostream>
#include <memory>

int main() {
    int size;
    std::cout << "请输入数组大小: ";
    std::cin >> size;
    
    // 1. 使用 new/delete
    int* dynamicArray = new int[size];
    
    // 初始化
    for (int i = 0; i < size; ++i) {
        dynamicArray[i] = i * i;
    }
    
    // 使用
    std::cout << "动态数组内容: ";
    for (int i = 0; i < size; ++i) {
        std::cout << dynamicArray[i] << " ";
    }
    std::cout << std::endl;
    
    // 修改数组元素
    dynamicArray[0] = 100;
    std::cout << "修改后第一个元素: " << dynamicArray[0] << std::endl;
    
    // 重要：释放内存
    delete[] dynamicArray;
    dynamicArray = nullptr;  // 避免悬空指针
    
    return 0;
}
```

#### 方法二：使用智能指针（推荐）

```cpp
#include <iostream>
#include <memory>

int main() {
    int size;
    std::cout << "请输入数组大小: ";
    std::cin >> size;
    
    // 使用 unique_ptr 管理动态数组
    std::unique_ptr<int[]> smartArray(new int[size]);
    
    // 或者使用 make_unique (C++14及以后)
    // auto smartArray = std::make_unique<int[]>(size);
    
    // 初始化
    for (int i = 0; i < size; ++i) {
        smartArray[i] = (i + 1) * 10;
    }
    
    // 使用
    std::cout << "智能指针管理的动态数组: ";
    for (int i = 0; i < size; ++i) {
        std::cout << smartArray[i] << " ";
    }
    std::cout << std::endl;
    
    // 自动释放内存，无需手动delete
    return 0;
}
```

#### 方法三：使用 std::vector（最推荐）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int size;
    std::cout << "请输入数组大小: ";
    std::cin >> size;
    
    // 使用 vector
    std::vector<int> dynamicVector(size);
    
    // 初始化
    for (int i = 0; i < size; ++i) {
        dynamicVector[i] = i * 2 + 1;
    }
    
    // 使用
    std::cout << "vector动态数组: ";
    for (const auto& element : dynamicVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // vector的优势：可以动态调整大小
    dynamicVector.push_back(999);  // 添加元素
    std::cout << "添加元素后大小: " << dynamicVector.size() << std::endl;
    
    // 使用算法
    std::sort(dynamicVector.begin(), dynamicVector.end());
    std::cout << "排序后: ";
    for (const auto& element : dynamicVector) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 二维动态数组

#### 方法一：使用指针的指针

```cpp
#include <iostream>

// 创建二维动态数组
int** create2DArray(int rows, int cols) {
    int** array = new int*[rows];
    for (int i = 0; i < rows; ++i) {
        array[i] = new int[cols];
    }
    return array;
}

// 释放二维动态数组
void delete2DArray(int** array, int rows) {
    for (int i = 0; i < rows; ++i) {
        delete[] array[i];
    }
    delete[] array;
}

// 初始化二维数组
void initialize2DArray(int** array, int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            array[i][j] = i * cols + j + 1;
        }
    }
}

// 打印二维数组
void print2DArray(int** array, int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            std::cout << array[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}

int main() {
    int rows, cols;
    std::cout << "请输入行数和列数: ";
    std::cin >> rows >> cols;
    
    // 创建二维动态数组
    int** matrix = create2DArray(rows, cols);
    
    // 初始化
    initialize2DArray(matrix, rows, cols);
    
    // 打印
    std::cout << "二维动态数组内容:" << std::endl;
    print2DArray(matrix, rows, cols);
    
    // 修改某个元素
    matrix[1][1] = 999;
    std::cout << "修改matrix[1][1]后:" << std::endl;
    print2DArray(matrix, rows, cols);
    
    // 释放内存
    delete2DArray(matrix, rows);
    
    return 0;
}
```

#### 方法二：使用一维数组模拟二维数组

```cpp
#include <iostream>
#include <memory>

class Matrix {
private:
    std::unique_ptr<int[]> data;
    int rows, cols;
    
public:
    Matrix(int r, int c) : rows(r), cols(c) {
        data = std::make_unique<int[]>(rows * cols);
    }
    
    // 重载()运算符实现二维访问
    int& operator()(int row, int col) {
        return data[row * cols + col];
    }
    
    const int& operator()(int row, int col) const {
        return data[row * cols + col];
    }
    
    // 获取行数和列数
    int getRows() const { return rows; }
    int getCols() const { return cols; }
    
    // 初始化矩阵
    void initialize() {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                (*this)(i, j) = i * cols + j + 1;
            }
        }
    }
    
    // 打印矩阵
    void print() const {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                std::cout << (*this)(i, j) << "\t";
            }
            std::cout << std::endl;
        }
    }
    
    // 矩阵转置
    Matrix transpose() const {
        Matrix result(cols, rows);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(j, i) = (*this)(i, j);
            }
        }
        return result;
    }
};

int main() {
    int rows, cols;
    std::cout << "请输入矩阵的行数和列数: ";
    std::cin >> rows >> cols;
    
    // 创建矩阵对象
    Matrix matrix(rows, cols);
    
    // 初始化
    matrix.initialize();
    
    std::cout << "原始矩阵:" << std::endl;
    matrix.print();
    
    // 修改元素
    matrix(0, 0) = 100;
    std::cout << "修改matrix(0,0)后:" << std::endl;
    matrix.print();
    
    // 转置矩阵
    Matrix transposed = matrix.transpose();
    std::cout << "转置矩阵:" << std::endl;
    transposed.print();
    
    return 0;
}
```

#### 方法三：使用 std::vector<std::vector>（最推荐）

```cpp
#include <iostream>
#include <vector>
#include <iomanip>

class VectorMatrix {
private:
    std::vector<std::vector<int>> matrix;
    
public:
    VectorMatrix(int rows, int cols) : matrix(rows, std::vector<int>(cols)) {}
    
    // 访问元素
    int& operator()(int row, int col) {
        return matrix[row][col];
    }
    
    const int& operator()(int row, int col) const {
        return matrix[row][col];
    }
    
    // 获取维度
    int rows() const { return matrix.size(); }
    int cols() const { return matrix.empty() ? 0 : matrix[0].size(); }
    
    // 初始化
    void initialize() {
        for (int i = 0; i < rows(); ++i) {
            for (int j = 0; j < cols(); ++j) {
                matrix[i][j] = i * cols() + j + 1;
            }
        }
    }
    
    // 随机初始化
    void randomInitialize() {
        for (int i = 0; i < rows(); ++i) {
            for (int j = 0; j < cols(); ++j) {
                matrix[i][j] = rand() % 100;
            }
        }
    }
    
    // 打印矩阵
    void print() const {
        for (const auto& row : matrix) {
            for (int element : row) {
                std::cout << std::setw(4) << element;
            }
            std::cout << std::endl;
        }
    }
    
    // 添加行
    void addRow(const std::vector<int>& newRow) {
        if (newRow.size() == cols()) {
            matrix.push_back(newRow);
        }
    }
    
    // 添加列
    void addColumn(int value = 0) {
        for (auto& row : matrix) {
            row.push_back(value);
        }
    }
    
    // 矩阵加法
    VectorMatrix operator+(const VectorMatrix& other) const {
        if (rows() != other.rows() || cols() != other.cols()) {
            throw std::invalid_argument("矩阵维度不匹配");
        }
        
        VectorMatrix result(rows(), cols());
        for (int i = 0; i < rows(); ++i) {
            for (int j = 0; j < cols(); ++j) {
                result(i, j) = (*this)(i, j) + other(i, j);
            }
        }
        return result;
    }
    
    // 查找最大值
    int findMax() const {
        int maxVal = matrix[0][0];
        for (const auto& row : matrix) {
            for (int element : row) {
                if (element > maxVal) {
                    maxVal = element;
                }
            }
        }
        return maxVal;
    }
    
    // 计算行和
    std::vector<int> rowSums() const {
        std::vector<int> sums;
        for (const auto& row : matrix) {
            int sum = 0;
            for (int element : row) {
                sum += element;
            }
            sums.push_back(sum);
        }
        return sums;
    }
};

int main() {
    int rows, cols;
    std::cout << "请输入矩阵的行数和列数: ";
    std::cin >> rows >> cols;
    
    // 创建矩阵
    VectorMatrix matrix1(rows, cols);
    VectorMatrix matrix2(rows, cols);
    
    // 初始化
    matrix1.initialize();
    matrix2.randomInitialize();
    
    std::cout << "矩阵1:" << std::endl;
    matrix1.print();
    
    std::cout << "\n矩阵2 (随机):" << std::endl;
    matrix2.print();
    
    // 矩阵运算
    try {
        VectorMatrix sum = matrix1 + matrix2;
        std::cout << "\n矩阵相加结果:" << std::endl;
        sum.print();
        
        // 统计信息
        std::cout << "\n矩阵1的最大值: " << matrix1.findMax() << std::endl;
        
        auto rowSums = matrix1.rowSums();
        std::cout << "矩阵1各行和: ";
        for (int sum : rowSums) {
            std::cout << sum << " ";
        }
        std::cout << std::endl;
        
        // 动态添加行和列
        matrix1.addColumn(999);
        std::vector<int> newRow(matrix1.cols(), 888);
        matrix1.addRow(newRow);
        
        std::cout << "\n添加行和列后的矩阵1:" << std::endl;
        matrix1.print();
        
    } catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 动态数组的最佳实践

#### 内存管理工具类

```cpp
#include <iostream>
#include <memory>
#include <stdexcept>

template<typename T>
class DynamicArray {
private:
    std::unique_ptr<T[]> data;
    size_t size_;
    size_t capacity_;
    
public:
    // 构造函数
    explicit DynamicArray(size_t initialSize = 0) 
        : size_(initialSize), capacity_(initialSize > 0 ? initialSize : 1) {
        data = std::make_unique<T[]>(capacity_);
    }
    
    // 拷贝构造函数
    DynamicArray(const DynamicArray& other) 
        : size_(other.size_), capacity_(other.capacity_) {
        data = std::make_unique<T[]>(capacity_);
        for (size_t i = 0; i < size_; ++i) {
            data[i] = other.data[i];
        }
    }
    
    // 赋值运算符
    DynamicArray& operator=(const DynamicArray& other) {
        if (this != &other) {
            size_ = other.size_;
            capacity_ = other.capacity_;
            data = std::make_unique<T[]>(capacity_);
            for (size_t i = 0; i < size_; ++i) {
                data[i] = other.data[i];
            }
        }
        return *this;
    }
```
