
## 一、成员变量详解

### 1.1 成员变量的类型与声明

```cpp
class MemberVariables {
private:
    // 1. 基本类型成员变量
    int intMember;
    double doubleMember;
    char charMember;
    bool boolMember;
    
    // 2. 指针成员变量
    int* ptrMember;
    char* dynamicArray;
    
    // 3. 引用成员变量（必须在构造函数初始化列表中初始化）
    int& refMember;
    
    // 4. 数组成员变量
    int arrayMember[100];
    std::array<int, 50> stdArrayMember;
    
    // 5. 类类型成员变量
    std::string strMember;
    std::vector<int> vecMember;
    
    // 6. const成员变量（必须在初始化列表中初始化）
    const int constMember;
    
    // 7. mutable成员变量（可在const函数中修改）
    mutable int cacheValue;
    mutable bool cacheValid;
    
    // 8. static成员变量（类级别共享）
    static int staticMember;
    static const int staticConstMember = 100;  // C++11允许类内初始化
    static inline int staticInlineMember = 200; // C++17
    
    // 9. C++11成员初始化
    int modernMember1 = 42;              // 默认成员初始化器
    double modernMember2{3.14};          // 统一初始化
    std::vector<int> modernVec{1,2,3,4}; // 列表初始化
    
public:
    // 构造函数展示初始化
    MemberVariables(int& ref, int constVal) 
        : refMember(ref)           // 引用必须初始化
        , constMember(constVal)    // const必须初始化
        , intMember(0)             // 普通成员初始化
        , ptrMember(nullptr)       // 指针初始化
        , cacheValid(false) {
        // 构造函数体
        dynamicArray = new char[100];
    }
    
    ~MemberVariables() {
        delete[] dynamicArray;
    }
};

// static成员变量定义（类外）
int MemberVariables::staticMember = 0;
```

### 1.2 成员变量的内存布局

```cpp
class MemoryLayoutDemo {
    // 成员变量的对齐和填充
    class AlignmentDemo {
        char a;      // offset 0, size 1
        // padding 3 bytes
        int b;       // offset 4, size 4
        char c;      // offset 8, size 1
        // padding 3 bytes
        int d;       // offset 12, size 4
    }; // total size: 16 bytes
    
    // 使用pragma pack控制对齐
    #pragma pack(push, 1)
    class PackedClass {
        char a;      // offset 0, size 1
        int b;       // offset 1, size 4
        char c;      // offset 5, size 1
        int d;       // offset 6, size 4
    }; // total size: 10 bytes
    #pragma pack(pop)
    
    // 位域成员
    class BitFieldDemo {
        unsigned int flag1 : 1;   // 1 bit
        unsigned int flag2 : 1;   // 1 bit
        unsigned int value : 6;   // 6 bits
        unsigned int reserved : 24; // 24 bits
    }; // total: 32 bits (4 bytes)
    
    // 联合体成员
    class UnionMember {
        union {
            int intValue;
            float floatValue;
            char bytes[4];
        } data;
        
        enum class Type { INT, FLOAT, BYTES } type;
        
    public:
        void setInt(int val) {
            data.intValue = val;
            type = Type::INT;
        }
        
        void setFloat(float val) {
            data.floatValue = val;
            type = Type::FLOAT;
        }
    };
};
```

### 1.3 静态成员变量详解

```cpp
class StaticMemberDemo {
private:
    static int instanceCount;           // 实例计数器
    static const int MAX_INSTANCES = 100; // 编译时常量
    
    // C++17 inline静态成员变量
    inline static std::string className = "StaticMemberDemo";
    
    // 静态成员可以是复杂类型
    static std::map<int, std::string> registry;
    
public:
    StaticMemberDemo() {
        if (++instanceCount > MAX_INSTANCES) {
            throw std::runtime_error("Too many instances");
        }
    }
    
    ~StaticMemberDemo() {
        --instanceCount;
    }
    
    // 静态成员函数访问静态成员
    static int getInstanceCount() {
        return instanceCount;
    }
    
    // 静态局部变量（Meyer's Singleton）
    static StaticMemberDemo& getInstance() {
        static StaticMemberDemo instance;  // 线程安全（C++11）
        return instance;
    }
    
    // 静态成员初始化辅助类
    class StaticInitializer {
    public:
        StaticInitializer() {
            // 复杂的静态成员初始化
            registry[1] = "First";
            registry[2] = "Second";
        }
    };
    
private:
    static StaticInitializer initializer;
};

// 类外定义
int StaticMemberDemo::instanceCount = 0;
std::map<int, std::string> StaticMemberDemo::registry;
StaticMemberDemo::StaticInitializer StaticMemberDemo::initializer;
```

## 二、成员函数详解

### 2.1 成员函数的类型

```cpp
class MemberFunctions {
private:
    int data;
    mutable int cachedValue;
    
public:
    // 1. 普通成员函数
    void normalFunction() {
        data = 10;  // 可以修改成员变量
    }
    
    // 2. const成员函数
    int getValue() const {
        // data = 20;  // 错误：不能修改非mutable成员
        cachedValue = 100;  // 可以修改mutable成员
        return data;
    }
    
    // 3. const和非const重载
    int& getData() { return data; }
    const int& getData() const { return data; }
    
    // 4. volatile成员函数
    void volatileFunction() volatile {
        // 用于volatile对象
    }
    
    // 5. const volatile成员函数
    void constVolatileFunction() const volatile {
        // 最严格的成员函数
    }
    
    // 6. 引用限定成员函数（C++11）
    void processLValue() & {
        std::cout << "Called on lvalue\n";
    }
    
    void processRValue() && {
        std::cout << "Called on rvalue\n";
    }
    
    // 7. 静态成员函数
    static void staticFunction() {
        // 没有this指针，不能访问非静态成员
        // data = 30;  // 错误
    }
    
    // 8. 虚函数
    virtual void virtualFunction() {
        std::cout << "Base virtual function\n";
    }
    
    // 9. 纯虚函数
    virtual void pureVirtualFunction() = 0;
    
    // 10. 内联成员函数
    inline void inlineFunction() {
        data = 40;
    }
    
    // 11. 模板成员函数
    template<typename T>
    void templateFunction(T value) {
        std::cout << "Template value: " << value << "\n";
    }
    
    // 12. friend函数（不是成员函数，但可以访问私有成员）
    friend void friendFunction(MemberFunctions& obj);
};

// 使用示例
void usageExample() {
    MemberFunctions obj;
    obj.processLValue();            // 左值调用
    MemberFunctions().processRValue(); // 右值调用
}
```

### 2.2 成员函数的重载

```cpp
class FunctionOverloading {
private:
    std::vector<int> data;
    
public:
    // 1. 参数数量不同
    void process() {
        std::cout << "No parameters\n";
    }
    
    void process(int x) {
        std::cout << "One parameter: " << x << "\n";
    }
    
    void process(int x, int y) {
        std::cout << "Two parameters: " << x << ", " << y << "\n";
    }
    
    // 2. 参数类型不同
    void process(double x) {
        std::cout << "Double parameter: " << x << "\n";
    }
    
    void process(const std::string& s) {
        std::cout << "String parameter: " << s << "\n";
    }
    
    // 3. const重载
    int& operator[](size_t index) {
        return data[index];
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
    
    // 4. 引用限定符重载（C++11）
    void setValue(int val) & {
        data.push_back(val);
        std::cout << "Set on lvalue\n";
    }
    
    void setValue(int val) && {
        data.push_back(val);
        std::cout << "Set on rvalue (move)\n";
    }
    
    // 5. noexcept重载（C++17）
    void operation() noexcept {
        std::cout << "Noexcept version\n";
    }
    
    void operation() {
        std::cout << "Throwing version\n";
    }
};
```

### 2.3 特殊成员函数

```cpp
class SpecialMemberFunctions {
private:
    int* data;
    size_t size;
    
public:
    // 1. 默认构造函数
    SpecialMemberFunctions() 
        : data(nullptr), size(0) {
        std::cout << "Default constructor\n";
    }
    
    // 2. 参数化构造函数
    explicit SpecialMemberFunctions(size_t n) 
        : data(new int[n]()), size(n) {
        std::cout << "Parameterized constructor\n";
    }
    
    // 3. 拷贝构造函数
    SpecialMemberFunctions(const SpecialMemberFunctions& other)
        : data(new int[other.size]), size(other.size) {
        std::copy(other.data, other.data + size, data);
        std::cout << "Copy constructor\n";
    }
    
    // 4. 移动构造函数
    SpecialMemberFunctions(SpecialMemberFunctions&& other) noexcept
        : data(std::exchange(other.data, nullptr))
        , size(std::exchange(other.size, 0)) {
        std::cout << "Move constructor\n";
    }
    
    // 5. 拷贝赋值运算符
    SpecialMemberFunctions& operator=(const SpecialMemberFunctions& other) {
        std::cout << "Copy assignment\n";
        if (this != &other) {
            // Copy-and-swap idiom
            SpecialMemberFunctions temp(other);
            swap(temp);
        }
        return *this;
    }
    
    // 6. 移动赋值运算符
    SpecialMemberFunctions& operator=(SpecialMemberFunctions&& other) noexcept {
        std::cout << "Move assignment\n";
        if (this != &other) {
            delete[] data;
            data = std::exchange(other.data, nullptr);
            size = std::exchange(other.size, 0);
        }
        return *this;
    }
    
    // 7. 析构函数
    ~SpecialMemberFunctions() {
        delete[] data;
        std::cout << "Destructor\n";
    }
    
    // 辅助函数
    void swap(SpecialMemberFunctions& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
    
    // 转换函数
    explicit operator bool() const {
        return data != nullptr && size > 0;
    }
    
    operator std::vector<int>() const {
        return std::vector<int>(data, data + size);
    }
};
```

## 三、成员函数指针

### 3.1 成员函数指针的定义和使用

```cpp
class MemberFunctionPointers {
private:
    int value;
    
public:
    void setValue(int v) { value = v; }
    int getValue() const { return value; }
    void print() { std::cout << "Value: " << value << "\n"; }
    static void staticPrint() { std::cout << "Static function\n"; }
    
    // 成员函数指针使用示例
    void demonstratePointers() {
        // 1. 定义成员函数指针类型
        using SetterPtr = void (MemberFunctionPointers::*)(int);
        using GetterPtr = int (MemberFunctionPointers::*)() const;
        using PrintPtr = void (MemberFunctionPointers::*)();
        
        // 2. 获取成员函数地址
        SetterPtr setter = &MemberFunctionPointers::setValue;
        GetterPtr getter = &MemberFunctionPointers::getValue;
        PrintPtr printer = &MemberFunctionPointers::print;
        
        // 3. 通过对象调用
        MemberFunctionPointers obj;
        (obj.*setter)(42);           // 对象调用
        int val = (obj.*getter)();   // 获取值
        (obj.*printer)();             // 打印
        
        // 4. 通过指针调用
        MemberFunctionPointers* ptr = &obj;
        (ptr->*setter)(100);          // 指针调用
        val = (ptr->*getter)();
        (ptr->*printer)();
        
        // 5. 静态成员函数指针（普通函数指针）
        void (*staticPtr)() = &MemberFunctionPointers::staticPrint;
        staticPtr();  // 直接调用
    }
};

// 成员函数指针的高级应用
class CommandPattern {
    using Command = void (CommandPattern::*)();
    std::map<std::string, Command> commands;
    
public:
    CommandPattern() {
        commands["open"] = &CommandPattern::open;
        commands["close"] = &CommandPattern::close;
        commands["save"] = &CommandPattern::save;
    }
    
    void execute(const std::string& cmd) {
        auto it = commands.find(cmd);
        if (it != commands.end()) {
            (this->*(it->second))();
        }
    }
    
private:
    void open() { std::cout << "Opening...\n"; }
    void close() { std::cout << "Closing...\n"; }
    void save() { std::cout << "Saving...\n"; }
};
```

## 四、this指针

### 4.1 this指针的本质和使用

```cpp
class ThisPointer {
private:
    int x, y;
    
public:
    // this指针的基本使用
    ThisPointer(int x, int y) {
        this->x = x;  // 区分参数和成员变量
        this->y = y;
    }
    
    // 返回*this实现链式调用
    ThisPointer& setX(int x) {
        this->x = x;
        return *this;
    }
    
    ThisPointer& setY(int y) {
        this->y = y;
        return *this;
    }
    
    // 链式调用示例
    void chainExample() {
        ThisPointer obj(0, 0);
        obj.setX(10).setY(20).print();
    }
    
    void print() const {
        // const成员函数中this是const指针
        // this类型：const ThisPointer* const
        std::cout << "(" << this->x << ", " << this->y << ")\n";
    }
    
    // 比较对象
    bool isEqual(const ThisPointer& other) const {
        return this == &other;  // 比较地址
    }
    
    // 删除自己（危险操作）
    void deleteSelf() {
        delete this;  // 调用后this变为野指针
        // 不能再访问任何成员
    }
    
    // 在成员函数中创建自己的副本
    ThisPointer* clone() const {
        return new ThisPointer(*this);
    }
};
```

## 五、成员访问控制

### 5.1 访问权限的继承和友元

```cpp
class AccessControl {
private:
    int privateData = 10;
    void privateMethod() { std::cout << "Private\n"; }
    
protected:
    int protectedData = 20;
    void protectedMethod() { std::cout << "Protected\n"; }
    
public:
    int publicData = 30;
    void publicMethod() { std::cout << "Public\n"; }
    
    // 友元函数可以访问所有成员
    friend void friendFunction(AccessControl& obj);
    
    // 友元类
    friend class FriendClass;
    
    // 内部类对外部类的访问
    class InnerClass {
    public:
        void accessOuter(AccessControl& outer) {
            outer.privateData = 100;    // 可以访问私有成员
            outer.privateMethod();
        }
    };
};

// 友元函数实现
void friendFunction(AccessControl& obj) {
    obj.privateData = 40;    // 访问私有成员
    obj.privateMethod();
    obj.protectedData = 50;  // 访问保护成员
    obj.protectedMethod();
}

// 继承中的访问控制
class PublicDerived : public AccessControl {
public:
    void useInherited() {
        // privateData = 1;   // 错误：不能访问私有成员
        protectedData = 2;    // 可以访问保护成员
        publicData = 3;       // 可以访问公有成员
    }
};

class ProtectedDerived : protected AccessControl {
    // 所有public成员变为protected
};

class PrivateDerived : private AccessControl {
    // 所有成员变为private
};
```

## 六、成员函数的高级特性

### 6.1 完美转发和可变参数模板

```cpp
class AdvancedFeatures {
private:
    std::vector<std::string> messages;
    
public:
    // 可变参数模板成员函数
    template<typename... Args>
    void log(Args&&... args) {
        std::stringstream ss;
        ((ss << std::forward<Args>(args) << " "), ...);  // C++17 fold expression
        messages.push_back(ss.str());
    }
    
    // 完美转发构造函数
    template<typename... Args>
    void emplace(Args&&... args) {
        messages.emplace_back(std::forward<Args>(args)...);
    }
    
    // SFINAE应用
    template<typename T>
    typename std::enable_if<std::is_integral<T>::value, void>::type
    process(T value) {
        std::cout << "Processing integer: " << value << "\n";
    }
    
    template<typename T>
    typename std::enable_if<std::is_floating_point<T>::value, void>::type
    process(T value) {
        std::cout << "Processing float: " << value << "\n";
    }
    
    // C++20 概念约束
    #if __cplusplus >= 202002L
    template<typename T>
    requires std::integral<T>
    void modernProcess(T value) {
        std::cout << "Processing with concept: " << value << "\n";
    }
    #endif
};
```

### 6.2 lambda表达式和成员函数

```cpp
class LambdaIntegration {
private:
    int value = 42;
    
public:
    // 在成员函数中使用lambda
    void useLambda() {
        // 捕获this指针
        auto lambda1 = [this]() {
            return value * 2;  // 访问成员变量
        };
        
        // C++17 捕获*this（按值捕获对象）
        auto lambda2 = [*this]() {
            return value * 3;  // 访问副本的成员
        };
        
        // 捕获成员变量
        auto lambda3 = [v = value]() {
            return v * 4;
        };
        
        std::cout << lambda1() << ", " 
                  << lambda2() << ", " 
                  << lambda3() << "\n";
    }
    
    // 返回lambda
    std::function<int()> createGetter() {
        return [this]() { return value; };
    }
    
    // 接受lambda作为参数
    template<typename Func>
    void forEach(Func func) {
        func(value);
    }
};
```

## 七、性能优化

### 7.1 内联和优化

```cpp
class PerformanceOptimization {
private:
    int data[1000];
    
public:
    // 显式内联
    inline int getElement(int index) const {
        return data[index];
    }
    
    // 强制内联（编译器特定）
    [[gnu::always_inline]] 
    void alwaysInline() {
        // 函数体
    }
    
    // 禁止内联
    [[gnu::noinline]]
    void neverInline() {
        // 复杂函数体
    }
    
    // constexpr成员函数（编译时计算）
    constexpr int calculate(int x) const {
        return x * x + 2 * x + 1;
    }
    
    // C++20 consteval（必须编译时计算）
    #if __cplusplus >= 202002L
    consteval int mustBeCompileTime(int x) {
        return x * x;
    }
    #endif
    
    // noexcept优化
    void fastOperation() noexcept {
        // 保证不抛出异常，允许更好的优化
    }
    
    // 返回值优化（RVO/NRVO）
    std::vector<int> createVector() {
        std::vector<int> result;
        result.reserve(1000);
        // 填充数据
        return result;  // NRVO优化
    }
};
```

### 7.2 缓存友好的设计

```cpp
class CacheFriendly {
    // 热数据和冷数据分离
    struct HotData {
        int frequentlyUsed1;
        int frequentlyUsed2;
        double frequentlyUsed3;
    };
    
    struct ColdData {
        std::string rarelyUsed1;
        std::vector<int> rarelyUsed2;
        std::map<int, std::string> rarelyUsed3;
    };
    
    HotData hot;
    std::unique_ptr<ColdData> cold;  // 延迟初始化
    
public:
    // 访问热数据（快速）
    int getFrequent() const {
        return hot.frequentlyUsed1;
    }
    
    // 访问冷数据（慢，但不影响热数据缓存）
    const std::string& getRare() {
        if (!cold) {
            cold = std::make_unique<ColdData>();
        }
        return cold->rarelyUsed1;
    }
};
```

