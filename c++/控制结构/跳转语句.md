C++ 中的跳转语句用于改变程序的正常执行流程，使程序跳转到指定位置继续执行。虽然跳转语句功能强大，但过度使用会使代码难以理解和维护。

## break 语句

### 基本用法

break 语句用于立即退出最内层的循环或 switch 语句。

```cpp
// 在循环中使用 break
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // 当 i 等于 5 时退出循环
    }
    std::cout << i << " ";
}
// 输出：0 1 2 3 4

// 在 while 循环中
int count = 0;
while (true) {
    if (count >= 5) {
        break;  // 退出无限循环
    }
    std::cout << count++ << " ";
}

// 在 do-while 循环中
do {
    int input;
    std::cin >> input;
    if (input == -1) {
        break;  // 用户输入 -1 时退出
    }
    process(input);
} while (true);
```

### 在 switch 中使用 break

```cpp
int choice = 2;
switch (choice) {
    case 1:
        std::cout << "Option 1" << std::endl;
        break;  // 防止 fall-through
    case 2:
        std::cout << "Option 2" << std::endl;
        break;
    case 3:
        std::cout << "Option 3" << std::endl;
        break;
    default:
        std::cout << "Invalid option" << std::endl;
        break;  // 虽然是最后一个，但加上 break 是好习惯
}
```

### 嵌套循环中的 break

```cpp
// break 只退出最内层循环
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) {
            break;  // 只退出内层循环
        }
        std::cout << "(" << i << "," << j << ") ";
    }
    std::cout << std::endl;
}
// 输出：
// (0,0)
// (1,0)
// (2,0)

// 使用标志变量退出多层循环
bool shouldBreak = false;
for (int i = 0; i < 10 && !shouldBreak; i++) {
    for (int j = 0; j < 10; j++) {
        if (matrix[i][j] == target) {
            shouldBreak = true;
            break;  // 退出内层循环
        }
    }
}

// 使用函数返回退出多层循环
bool searchMatrix(int matrix[][10], int target) {
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (matrix[i][j] == target) {
                return true;  // 直接退出函数
            }
        }
    }
    return false;
}
```

## continue 语句

### 基本用法

continue 语句跳过当前迭代的剩余部分，直接进入下一次迭代。

```cpp
// 跳过偶数，只打印奇数
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // 跳过偶数
    }
    std::cout << i << " ";
}
// 输出：1 3 5 7 9

// 在 while 循环中使用
int i = 0;
while (i < 10) {
    i++;  // 注意：增量要在 continue 之前
    if (i % 3 == 0) {
        continue;  // 跳过 3 的倍数
    }
    std::cout << i << " ";
}

// 处理无效数据
std::vector<int> data = {1, -2, 3, -4, 5, 0, 7};
for (int value : data) {
    if (value <= 0) {
        continue;  // 跳过非正数
    }
    std::cout << "Processing: " << value << std::endl;
}
```

### continue 的实际应用

```cpp
// 数据过滤
std::vector<Student> students = getStudents();
for (const auto& student : students) {
    if (!student.isActive()) {
        continue;  // 跳过非活跃学生
    }
    if (student.getGrade() < 60) {
        continue;  // 跳过不及格学生
    }
    // 处理符合条件的学生
    processStudent(student);
}

// 输入验证循环
while (true) {
    std::string input;
    std::getline(std::cin, input);
    
    if (input.empty()) {
        continue;  // 跳过空行
    }
    if (input[0] == '#') {
        continue;  // 跳过注释行
    }
    if (input == "quit") {
        break;  // 退出循环
    }
    
    processCommand(input);
}
```

### 嵌套循环中的 continue

```cpp
// continue 只影响最内层循环
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) {
            continue;  // 跳过 j==1 的情况
        }
        std::cout << "(" << i << "," << j << ") ";
    }
    std::cout << std::endl;
}
// 输出：
// (0,0) (0,2)
// (1,0) (1,2)
// (2,0) (2,2)
```

## goto 语句

### 基本语法

goto 语句可以无条件跳转到同一函数内的标签位置。

```cpp
// 基本 goto 语法
void example() {
    int x = 0;
    
start:  // 标签
    x++;
    std::cout << x << " ";
    
    if (x < 5) {
        goto start;  // 跳转到标签
    }
    
    std::cout << "Done" << std::endl;
}

// 向前跳转
void forward_jump() {
    std::cout << "Step 1" << std::endl;
    goto skip;  // 跳过中间代码
    
    std::cout << "Step 2" << std::endl;  // 被跳过
    std::cout << "Step 3" << std::endl;  // 被跳过
    
skip:
    std::cout << "Step 4" << std::endl;
}
```

### goto 的合理使用场景

虽然 goto 通常被认为是不好的编程实践，但在某些情况下它可能是合理的：

```cpp
// 1. 跳出多层嵌套循环
void searchIn3DArray() {
    int arr[10][10][10];
    
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            for (int k = 0; k < 10; k++) {
                if (arr[i][j][k] == target) {
                    goto found;  // 直接跳出所有循环
                }
            }
        }
    }
    
    std::cout << "Not found" << std::endl;
    return;
    
found:
    std::cout << "Found target" << std::endl;
}

// 2. 错误处理和资源清理（C 风格，不推荐）
bool initializeSystem() {
    Resource1* r1 = nullptr;
    Resource2* r2 = nullptr;
    Resource3* r3 = nullptr;
    
    r1 = acquireResource1();
    if (!r1) goto cleanup;
    
    r2 = acquireResource2();
    if (!r2) goto cleanup_r1;
    
    r3 = acquireResource3();
    if (!r3) goto cleanup_r2;
    
    // 成功初始化
    return true;
    
cleanup_r2:
    releaseResource2(r2);
cleanup_r1:
    releaseResource1(r1);
cleanup:
    return false;
}

// 更好的 C++ 方式：使用 RAII
bool initializeSystemRAII() {
    try {
        auto r1 = std::make_unique<Resource1>();
        auto r2 = std::make_unique<Resource2>();
        auto r3 = std::make_unique<Resource3>();
        // 自动清理
        return true;
    } catch (...) {
        return false;
    }
}
```

### goto 的限制

```cpp
// 不能跳过变量初始化
void illegal_goto() {
    goto skip;  // 编译错误！
    
    int x = 10;  // 不能跳过初始化
    
skip:
    // x 在这里使用是未定义的
}

// 正确的做法
void legal_goto() {
    int x;  // 声明但不初始化
    goto skip;
    
    x = 10;
    
skip:
    x = 20;  // 现在可以使用
}

// 不能跳入作用域
void scope_jump() {
    goto label;  // 编译错误！
    
    {
        int y = 10;
    label:  // 不能跳入块作用域
        std::cout << y;
    }
}
```

## return 语句

### 基本用法

return 语句用于从函数返回，可以带返回值或不带返回值。

```cpp
// 无返回值函数
void printMessage(const std::string& msg) {
    if (msg.empty()) {
        return;  // 提前返回
    }
    std::cout << msg << std::endl;
}

// 有返回值函数
int factorial(int n) {
    if (n <= 1) {
        return 1;  // 基本情况
    }
    return n * factorial(n - 1);  // 递归调用
}

// 多个返回点
int findIndex(const std::vector<int>& vec, int target) {
    for (size_t i = 0; i < vec.size(); i++) {
        if (vec[i] == target) {
            return i;  // 找到即返回
        }
    }
    return -1;  // 未找到
}
```

### 返回值优化（RVO/NRVO）

```cpp
// 返回值优化
std::vector<int> createVector() {
    std::vector<int> result;  // NRVO (Named RVO)
    result.reserve(1000);
    for (int i = 0; i < 1000; i++) {
        result.push_back(i);
    }
    return result;  // 编译器优化，避免拷贝
}

// 返回临时对象
std::string getMessage() {
    return std::string("Hello");  // RVO
}

// 使用 std::move 显式移动
std::vector<int> processData(std::vector<int> data) {
    // 处理 data
    return std::move(data);  // 显式移动
}
```

### 结构化绑定返回（C++17）

```cpp
// 返回多个值
std::tuple<bool, int, std::string> getResult() {
    return {true, 42, "Success"};
}

// 使用结构化绑定接收
auto [success, value, message] = getResult();

// 返回结构体
struct Result {
    bool success;
    int value;
    std::string message;
};

Result getStructResult() {
    return {true, 42, "Success"};
}
```

## 高级跳转技巧

### 使用异常代替 goto

```cpp
// 使用异常处理复杂的错误情况
class ProcessingError : public std::exception {
    std::string message;
public:
    ProcessingError(const std::string& msg) : message(msg) {}
    const char* what() const noexcept { return message.c_str(); }
};

void complexProcess() {
    try {
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (errorCondition()) {
                    throw ProcessingError("Error at " + 
                        std::to_string(i) + "," + std::to_string(j));
                }
            }
        }
    } catch (const ProcessingError& e) {
        std::cerr << "Processing failed: " << e.what() << std::endl;
    }
}
```

### 使用 lambda 和早期返回

```cpp
// 使用 lambda 封装复杂逻辑
void processItems(const std::vector<Item>& items) {
    auto processItem = [](const Item& item) -> bool {
        if (!item.isValid()) return false;
        if (!item.isReady()) return false;
        if (!item.hasPermission()) return false;
        
        // 实际处理
        item.process();
        return true;
    };
    
    for (const auto& item : items) {
        if (!processItem(item)) {
            std::cout << "Failed to process item" << std::endl;
        }
    }
}
```

### 状态机中的跳转

```cpp
enum class State { START, PROCESSING, ERROR, DONE };

void stateMachine() {
    State state = State::START;
    
    while (state != State::DONE) {
        switch (state) {
            case State::START:
                std::cout << "Starting..." << std::endl;
                state = State::PROCESSING;
                break;
                
            case State::PROCESSING:
                if (processData()) {
                    state = State::DONE;
                } else {
                    state = State::ERROR;
                }
                break;
                
            case State::ERROR:
                handleError();
                state = State::DONE;
                break;
                
            case State::DONE:
                break;
        }
    }
}
```

## 跳转语句的最佳实践

### 1. 优先使用结构化控制流

```cpp
// 不好：使用 goto
void badExample() {
    int i = 0;
loop:
    if (i >= 10) goto end;
    process(i);
    i++;
    goto loop;
end:
    return;
}

// 好：使用循环
void goodExample() {
    for (int i = 0; i < 10; i++) {
        process(i);
    }
}
```

### 2. 合理使用早期返回

```cpp
// 不好：深层嵌套
int calculate(int x, int y) {
    int result = 0;
    if (x > 0) {
        if (y > 0) {
            result = x + y;
        } else {
            result = x - y;
        }
    } else {
        result = 0;
    }
    return result;
}

// 好：早期返回
int calculate(int x, int y) {
    if (x <= 0) return 0;
    if (y > 0) return x + y;
    return x - y;
}
```

### 3. 使用 RAII 代替 goto 清理

```cpp
// 不好：使用 goto 进行资源清理
void processFile() {
    FILE* file = fopen("data.txt", "r");
    if (!file) goto error;
    
    // 处理文件
    if (errorCondition()) goto cleanup;
    
    // 更多处理
    
cleanup:
    fclose(file);
    return;
    
error:
    std::cerr << "Failed to open file" << std::endl;
}

// 好：使用 RAII
void processFile() {
    std::ifstream file("data.txt");
    if (!file) {
        std::cerr << "Failed to open file" << std::endl;
        return;
    }
    
    // 文件自动关闭
    if (errorCondition()) return;
    
    // 更多处理
}  // 自动清理
```

### 4. 避免过度使用 continue

```cpp
// 不好：多个 continue 使逻辑难以理解
for (const auto& item : items) {
    if (condition1()) continue;
    if (condition2()) continue;
    if (condition3()) continue;
    if (condition4()) continue;
    process(item);
}

// 好：提取为函数
bool shouldProcess(const Item& item) {
    return !condition1() && !condition2() && 
           !condition3() && !condition4();
}

for (const auto& item : items) {
    if (shouldProcess(item)) {
        process(item);
    }
}
```

跳转语句虽然强大，但应该谨慎使用。break 和 continue 在循环控制中很有用，return 是函数返回的标准方式，而 goto 应该尽量避免。现代 C++ 提供了许多更好的替代方案，如 RAII、异常处理、lambda 表达式等，可以让代码更清晰、更安全、更易维护。

|            |                  |                      |                     |
| ---------- | ---------------- | -------------------- | ------------------- |
| 跳转语句       | 作用范围             | 目标                   | 主要用途                |
| `break`    | 最内层的循环或 `switch` | 循环或 `switch` 语句的末尾之后 | 提前退出循环或 `switch` 分支 |
| `continue` | 最内层的循环           | 循环的下一次迭代（更新或条件检查）    | 跳过当前迭代的剩余部分         |
| `return`   | 整个函数             | 函数的调用点               | 退出函数，可选择性地返回值       |
| `goto`     | 整个函数             | 函数内任意 `label:` 标记的位置 | (应避免) 非结构化跳转        |
